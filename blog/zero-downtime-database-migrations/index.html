<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Zero-Downtime Database Migrations: Patterns for Production<!-- --> | CodeSprintPro</title><meta name="description" content="How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/zero-downtime-database-migrations/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Zero-Downtime Database Migrations: Patterns for Production" data-next-head=""/><meta property="og:description" content="How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/zero-downtime-database-migrations/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-06-08" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="database" data-next-head=""/><meta property="article:tag" content="migrations" data-next-head=""/><meta property="article:tag" content="postgresql" data-next-head=""/><meta property="article:tag" content="zero downtime" data-next-head=""/><meta property="article:tag" content="devops" data-next-head=""/><meta property="article:tag" content="schema evolution" data-next-head=""/><meta property="article:tag" content="flyway" data-next-head=""/><meta property="article:tag" content="liquibase" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Zero-Downtime Database Migrations: Patterns for Production" data-next-head=""/><meta name="twitter:description" content="How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-06-08","dateModified":"2025-06-08","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/zero-downtime-database-migrations/"},"keywords":"database, migrations, postgresql, zero downtime, devops, schema evolution, flyway, liquibase","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Zero-Downtime Database Migrations: Patterns for Production</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Zero-Downtime Database Migrations: Patterns for Production</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>June 8, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->database</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->migrations</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->postgresql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->zero downtime</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->devops</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->schema evolution</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->flyway</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->liquibase</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are stateful and often irreversible ‚Äî a dropped column is gone, a renamed column leaves old code broken, an index added with a table lock takes your service down.</p>
<p>The root cause of downtime during migrations is running application code that makes assumptions about schema that don't yet hold (or no longer hold). The solution is a pattern called <strong>expand-contract</strong> combined with backward-compatible intermediate states.</p>
<h2>The Expand-Contract Pattern</h2>
<p>Most schema changes can be decomposed into three phases that can each be deployed independently:</p>
<pre><code>Phase 1: EXPAND ‚Äî Add new schema alongside old (both versions of app work)
Phase 2: MIGRATE ‚Äî Backfill data, transition traffic to new schema
Phase 3: CONTRACT ‚Äî Remove old schema (only new app version exists)
</code></pre>
<p>This works because at any moment during a rolling deployment, some pods run the old code and some run the new code. Both must work against the same database. Backward-compatible intermediate states ensure both versions work simultaneously.</p>
<h2>Pattern 1: Renaming a Column</h2>
<p><strong>The naive approach (causes downtime):</strong></p>
<pre><code class="language-sql">-- This breaks old code immediately:
ALTER TABLE orders RENAME COLUMN customer_id TO user_id;
-- Old code writing to customer_id ‚Üí column not found ‚Üí 500 errors
</code></pre>
<p><strong>The expand-contract approach:</strong></p>
<p><strong>Phase 1: Expand ‚Äî Add new column</strong></p>
<pre><code class="language-sql">-- Migration (deploy with old application code still running):
ALTER TABLE orders ADD COLUMN user_id BIGINT;

-- Application code change (deploy after migration):
-- Write to BOTH old and new column
-- Read from old column (primary), fall back to new
INSERT INTO orders (customer_id, user_id, amount) VALUES (?, ?, ?);
SELECT COALESCE(user_id, customer_id) AS user_id FROM orders WHERE ...;
</code></pre>
<p><strong>Phase 2: Migrate ‚Äî Backfill data</strong></p>
<pre><code class="language-sql">-- Run in batches (don't lock the table):
UPDATE orders SET user_id = customer_id
WHERE user_id IS NULL
AND id BETWEEN ? AND ?;  -- Process in chunks of 10,000 rows

-- Repeat until no NULL user_id remain:
-- SELECT COUNT(*) FROM orders WHERE user_id IS NULL; ‚Üí 0
</code></pre>
<p><strong>Phase 3: Contract ‚Äî Remove old column</strong></p>
<pre><code class="language-sql">-- Application code: read from new column only (deployed first)
-- Then drop old column:
ALTER TABLE orders DROP COLUMN customer_id;
</code></pre>
<p>Three separate deployments, zero downtime at each step. The intermediate state (both columns exist, both written) is ugly but safe.</p>
<h2>Pattern 2: Adding a NOT NULL Column</h2>
<p>Adding a NOT NULL column with no default to an existing table fails immediately (existing rows don't satisfy the constraint). Even with a default, PostgreSQL pre-14 rewrites the entire table to set the default, causing a long lock.</p>
<p><strong>PostgreSQL 11+ approach:</strong></p>
<pre><code class="language-sql">-- Step 1: Add nullable column (fast, no table rewrite):
ALTER TABLE orders ADD COLUMN shipping_address TEXT;

-- Step 2: Application starts writing to new column (deploy new code)

-- Step 3: Backfill existing rows:
UPDATE orders SET shipping_address = 'Unknown' WHERE shipping_address IS NULL;
-- (Run in batches: WHERE id BETWEEN ? AND ?)

-- Step 4: Add NOT NULL constraint (PostgreSQL validates, fast if all rows are set):
ALTER TABLE orders ALTER COLUMN shipping_address SET NOT NULL;
-- Or use a CHECK constraint validated later:
ALTER TABLE orders ADD CONSTRAINT shipping_address_not_null
    CHECK (shipping_address IS NOT NULL) NOT VALID;
-- Then validate in background (doesn't lock writes):
ALTER TABLE orders VALIDATE CONSTRAINT shipping_address_not_null;
-- Then convert to NOT NULL:
ALTER TABLE orders ALTER COLUMN shipping_address SET NOT NULL;
ALTER TABLE orders DROP CONSTRAINT shipping_address_not_null;
</code></pre>
<p><code>NOT VALID</code> constraint + <code>VALIDATE CONSTRAINT</code> is the PostgreSQL pattern for adding constraints on large tables without locking. The <code>NOT VALID</code> constraint applies only to new rows (immediate). <code>VALIDATE</code> scans old rows using a weaker lock (ShareUpdateExclusiveLock) that allows reads and writes to continue.</p>
<h2>Pattern 3: Index Creation Without Locking</h2>
<p>Standard <code>CREATE INDEX</code> acquires a lock that blocks all writes until the index is built. On a large table (100M rows), this can take minutes.</p>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-sql">-- WRONG: Blocks writes for duration of build (potentially hours):
CREATE INDEX ON orders (customer_id);

-- RIGHT: Concurrent build ‚Äî reads and writes continue, 2√ó longer build time:
CREATE INDEX CONCURRENTLY ON orders (customer_id);

-- If CONCURRENTLY fails (crash, etc.), it leaves an INVALID index:
SELECT schemaname, tablename, indexname, indisvalid
FROM pg_indexes
WHERE indisvalid = false;
-- ‚Üí Drop the invalid index and retry

DROP INDEX CONCURRENTLY orders_customer_id_idx;
</code></pre>
<p><code>CREATE INDEX CONCURRENTLY</code> takes about 2-3√ó longer than regular index creation but never blocks reads or writes. Always use it in production.</p>
<p><strong>Adding a unique constraint concurrently:</strong></p>
<pre><code class="language-sql">-- Unique constraint directly ‚Üí table lock
-- Instead: create unique index first, then add constraint using the index
CREATE UNIQUE INDEX CONCURRENTLY orders_external_id_unique ON orders (external_id);

-- Then create constraint using the pre-built index (fast):
ALTER TABLE orders ADD CONSTRAINT orders_external_id_unique
    UNIQUE USING INDEX orders_external_id_unique;
</code></pre>
<h2>Pattern 4: Large Table Alterations</h2>
<p>Some alterations trigger full table rewrites ‚Äî <code>ALTER COLUMN TYPE</code>, adding a column with a volatile default, enabling encryption. In PostgreSQL, these block all reads and writes for the duration.</p>
<p><strong>Strategy: Shadow table swap</strong></p>
<pre><code class="language-sql">-- Create new table with desired schema:
CREATE TABLE orders_new (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,         -- new: renamed from customer_id
    amount NUMERIC(10,2) NOT NULL,
    currency CHAR(3) NOT NULL DEFAULT 'USD',  -- new: added column
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Copy data in batches (reads from old, writes to new):
INSERT INTO orders_new (id, user_id, amount, created_at)
SELECT id, customer_id, amount, created_at
FROM orders
WHERE id BETWEEN ? AND ?;

-- Once backfill is complete, swap tables atomically:
BEGIN;
  LOCK TABLE orders IN ACCESS EXCLUSIVE MODE;  -- Brief lock ‚Äî just for rename
  ALTER TABLE orders RENAME TO orders_old;
  ALTER TABLE orders_new RENAME TO orders;
  -- Update sequences, foreign keys, etc.
COMMIT;

-- Dual-write during backfill period:
-- Application writes to both orders (old) and orders_new simultaneously
-- After swap, drops orders_old
</code></pre>
<p>This pattern is what tools like pt-online-schema-change (Percona Toolkit) and gh-ost (GitHub) automate for MySQL. For PostgreSQL, pglogical-based migration tools do the same.</p>
<h2>Managing Migrations with Flyway/Liquibase</h2>
<p><strong>Flyway versioned migration structure:</strong></p>
<pre><code>db/migration/
  V1__create_orders_table.sql
  V2__add_customer_id_index.sql
  V3__add_user_id_column.sql          ‚Üê expand
  V4__backfill_user_id.sql            ‚Üê migrate (run separately or in batches)
  V5__add_user_id_not_null.sql        ‚Üê contract step 1
  V6__drop_customer_id_column.sql     ‚Üê contract step 2
</code></pre>
<p><strong>Critical Flyway rules for zero-downtime:</strong></p>
<ol>
<li>
<p><strong>Never modify a migration after it's been applied</strong> ‚Äî Flyway checksums every migration; modification causes startup failure. Create a new migration instead.</p>
</li>
<li>
<p><strong>Separate schema migrations from data migrations</strong> ‚Äî Schema migrations (V3) run at deploy time. Data migrations (V4 ‚Äî backfill) should run as background jobs, not blocking app startup.</p>
</li>
<li>
<p><strong>Idempotency for repeatable migrations</strong> ‚Äî Flyway's R__ prefix for repeatable migrations (views, stored procedures) runs them on every change. Schema migrations (V__) run once.</p>
</li>
</ol>
<pre><code class="language-java">// Spring Boot Flyway config:
@Configuration
public class FlywayConfig {

    @Bean
    public FlywayMigrationStrategy flywayMigrationStrategy() {
        return flyway -> {
            // Run baseline repair if needed
            flyway.repair();
            flyway.migrate();
        };
    }
}

// application.properties:
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.out-of-order=false  // Enforce sequential migration order
spring.flyway.validate-on-migrate=true
</code></pre>
<p><strong>Liquibase for multi-database compatibility:</strong></p>
<pre><code class="language-yaml"># liquibase/changelog/0003-add-user-id.yaml
databaseChangeLog:
  - changeSet:
      id: "0003-add-user-id-column"
      author: "engineering"
      runOnChange: false
      failOnError: true
      changes:
        - addColumn:
            tableName: orders
            columns:
              - column:
                  name: user_id
                  type: BIGINT
                  constraints:
                    nullable: true  # Start nullable ‚Äî NOT NULL added later
      rollback:
        - dropColumn:
            tableName: orders
            columnName: user_id
</code></pre>
<h2>Rolling Deployments: The Application Side</h2>
<p>During a rolling deployment, both old and new pod versions run simultaneously against the same database. Write application code to tolerate this:</p>
<pre><code class="language-java">// Old code: reads customer_id
// New code: reads user_id (with fallback during transition)

// Repository method during Phase 1 (both columns exist, old code still deployed):
public Long getUserId(Order order) {
    // New code reads new column, falls back to old if null
    return order.getUserId() != null ? order.getUserId() : order.getCustomerId();
}

// Writes to both during transition:
@Transactional
public Order createOrder(OrderRequest request) {
    Order order = new Order();
    order.setUserId(request.getUserId());      // New column
    order.setCustomerId(request.getUserId());  // Old column (backward compat)
    order.setAmount(request.getAmount());
    return orderRepository.save(order);
}
</code></pre>
<p>This dual-write period is the most fragile moment. Keep it short ‚Äî ideally one deployment cycle (hours, not days). Remove the backward-compatible code in the next deployment.</p>
<h2>Testing Migrations</h2>
<p>Never run migrations only in production. Test them in staging with production-scale data:</p>
<pre><code class="language-bash"># Clone production data (anonymized) to staging:
pg_dump --no-acl --no-owner production_db | psql staging_db

# Run migration and time it:
time psql staging_db -f V5__add_user_id_not_null.sql

# Check for locks during migration:
psql staging_db -c "
SELECT pid, wait_event_type, wait_event, state, query
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY duration DESC;"

# Verify no table rewrites (should show no sequential scans on large tables):
psql staging_db -c "EXPLAIN ANALYZE &#x3C;your migration SQL>;"
</code></pre>
<p><strong>The pre-flight checklist:</strong></p>
<ul>
<li>Is this migration backward-compatible? (Can old app code run with the new schema?)</li>
<li>Will it acquire a lock? For how long? (Check PostgreSQL lock documentation for each <code>ALTER TABLE</code> variant)</li>
<li>Can it be made concurrent? (<code>CREATE INDEX CONCURRENTLY</code>, <code>ADD CONSTRAINT ... NOT VALID</code>)</li>
<li>Is there a rollback path? (For each phase of expand-contract)</li>
<li>Has it been tested on production-scale data?</li>
</ul>
<p>Database migrations are the rare operations where going slow saves time. A 5-minute outage for a botched migration is worth a week's worth of careful planning. The expand-contract pattern is more work than a single ALTER statement, but it's the difference between a boring deploy and an incident postmortem.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Zero-Downtime%20Database%20Migrations%3A%20Patterns%20for%20Production&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fzero-downtime-database-migrations%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fzero-downtime-database-migrations%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-expand-contract-pattern" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Expand-Contract Pattern</a></li><li class=""><a href="#pattern-1-renaming-a-column" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 1: Renaming a Column</a></li><li class=""><a href="#pattern-2-adding-a-not-null-column" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 2: Adding a NOT NULL Column</a></li><li class=""><a href="#pattern-3-index-creation-without-locking" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 3: Index Creation Without Locking</a></li><li class=""><a href="#pattern-4-large-table-alterations" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 4: Large Table Alterations</a></li><li class=""><a href="#managing-migrations-with-flywayliquibase" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Managing Migrations with Flyway/Liquibase</a></li><li class=""><a href="#rolling-deployments-the-application-side" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Rolling Deployments: The Application Side</a></li><li class=""><a href="#testing-migrations" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Testing Migrations</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there&#x27;s no primary, and data placement is determined by partit‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/postgresql-performance-tuning/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they&#x27;re a query design problem that Post‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->databases</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->performance</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶","contentHtml":"\u003cp\u003eDatabase migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are stateful and often irreversible ‚Äî a dropped column is gone, a renamed column leaves old code broken, an index added with a table lock takes your service down.\u003c/p\u003e\n\u003cp\u003eThe root cause of downtime during migrations is running application code that makes assumptions about schema that don't yet hold (or no longer hold). The solution is a pattern called \u003cstrong\u003eexpand-contract\u003c/strong\u003e combined with backward-compatible intermediate states.\u003c/p\u003e\n\u003ch2\u003eThe Expand-Contract Pattern\u003c/h2\u003e\n\u003cp\u003eMost schema changes can be decomposed into three phases that can each be deployed independently:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePhase 1: EXPAND ‚Äî Add new schema alongside old (both versions of app work)\nPhase 2: MIGRATE ‚Äî Backfill data, transition traffic to new schema\nPhase 3: CONTRACT ‚Äî Remove old schema (only new app version exists)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works because at any moment during a rolling deployment, some pods run the old code and some run the new code. Both must work against the same database. Backward-compatible intermediate states ensure both versions work simultaneously.\u003c/p\u003e\n\u003ch2\u003ePattern 1: Renaming a Column\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThe naive approach (causes downtime):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- This breaks old code immediately:\nALTER TABLE orders RENAME COLUMN customer_id TO user_id;\n-- Old code writing to customer_id ‚Üí column not found ‚Üí 500 errors\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eThe expand-contract approach:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePhase 1: Expand ‚Äî Add new column\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Migration (deploy with old application code still running):\nALTER TABLE orders ADD COLUMN user_id BIGINT;\n\n-- Application code change (deploy after migration):\n-- Write to BOTH old and new column\n-- Read from old column (primary), fall back to new\nINSERT INTO orders (customer_id, user_id, amount) VALUES (?, ?, ?);\nSELECT COALESCE(user_id, customer_id) AS user_id FROM orders WHERE ...;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePhase 2: Migrate ‚Äî Backfill data\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Run in batches (don't lock the table):\nUPDATE orders SET user_id = customer_id\nWHERE user_id IS NULL\nAND id BETWEEN ? AND ?;  -- Process in chunks of 10,000 rows\n\n-- Repeat until no NULL user_id remain:\n-- SELECT COUNT(*) FROM orders WHERE user_id IS NULL; ‚Üí 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePhase 3: Contract ‚Äî Remove old column\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Application code: read from new column only (deployed first)\n-- Then drop old column:\nALTER TABLE orders DROP COLUMN customer_id;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThree separate deployments, zero downtime at each step. The intermediate state (both columns exist, both written) is ugly but safe.\u003c/p\u003e\n\u003ch2\u003ePattern 2: Adding a NOT NULL Column\u003c/h2\u003e\n\u003cp\u003eAdding a NOT NULL column with no default to an existing table fails immediately (existing rows don't satisfy the constraint). Even with a default, PostgreSQL pre-14 rewrites the entire table to set the default, causing a long lock.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePostgreSQL 11+ approach:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Step 1: Add nullable column (fast, no table rewrite):\nALTER TABLE orders ADD COLUMN shipping_address TEXT;\n\n-- Step 2: Application starts writing to new column (deploy new code)\n\n-- Step 3: Backfill existing rows:\nUPDATE orders SET shipping_address = 'Unknown' WHERE shipping_address IS NULL;\n-- (Run in batches: WHERE id BETWEEN ? AND ?)\n\n-- Step 4: Add NOT NULL constraint (PostgreSQL validates, fast if all rows are set):\nALTER TABLE orders ALTER COLUMN shipping_address SET NOT NULL;\n-- Or use a CHECK constraint validated later:\nALTER TABLE orders ADD CONSTRAINT shipping_address_not_null\n    CHECK (shipping_address IS NOT NULL) NOT VALID;\n-- Then validate in background (doesn't lock writes):\nALTER TABLE orders VALIDATE CONSTRAINT shipping_address_not_null;\n-- Then convert to NOT NULL:\nALTER TABLE orders ALTER COLUMN shipping_address SET NOT NULL;\nALTER TABLE orders DROP CONSTRAINT shipping_address_not_null;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNOT VALID\u003c/code\u003e constraint + \u003ccode\u003eVALIDATE CONSTRAINT\u003c/code\u003e is the PostgreSQL pattern for adding constraints on large tables without locking. The \u003ccode\u003eNOT VALID\u003c/code\u003e constraint applies only to new rows (immediate). \u003ccode\u003eVALIDATE\u003c/code\u003e scans old rows using a weaker lock (ShareUpdateExclusiveLock) that allows reads and writes to continue.\u003c/p\u003e\n\u003ch2\u003ePattern 3: Index Creation Without Locking\u003c/h2\u003e\n\u003cp\u003eStandard \u003ccode\u003eCREATE INDEX\u003c/code\u003e acquires a lock that blocks all writes until the index is built. On a large table (100M rows), this can take minutes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePostgreSQL:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- WRONG: Blocks writes for duration of build (potentially hours):\nCREATE INDEX ON orders (customer_id);\n\n-- RIGHT: Concurrent build ‚Äî reads and writes continue, 2√ó longer build time:\nCREATE INDEX CONCURRENTLY ON orders (customer_id);\n\n-- If CONCURRENTLY fails (crash, etc.), it leaves an INVALID index:\nSELECT schemaname, tablename, indexname, indisvalid\nFROM pg_indexes\nWHERE indisvalid = false;\n-- ‚Üí Drop the invalid index and retry\n\nDROP INDEX CONCURRENTLY orders_customer_id_idx;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eCREATE INDEX CONCURRENTLY\u003c/code\u003e takes about 2-3√ó longer than regular index creation but never blocks reads or writes. Always use it in production.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAdding a unique constraint concurrently:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Unique constraint directly ‚Üí table lock\n-- Instead: create unique index first, then add constraint using the index\nCREATE UNIQUE INDEX CONCURRENTLY orders_external_id_unique ON orders (external_id);\n\n-- Then create constraint using the pre-built index (fast):\nALTER TABLE orders ADD CONSTRAINT orders_external_id_unique\n    UNIQUE USING INDEX orders_external_id_unique;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ePattern 4: Large Table Alterations\u003c/h2\u003e\n\u003cp\u003eSome alterations trigger full table rewrites ‚Äî \u003ccode\u003eALTER COLUMN TYPE\u003c/code\u003e, adding a column with a volatile default, enabling encryption. In PostgreSQL, these block all reads and writes for the duration.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStrategy: Shadow table swap\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Create new table with desired schema:\nCREATE TABLE orders_new (\n    id BIGINT PRIMARY KEY,\n    user_id BIGINT NOT NULL,         -- new: renamed from customer_id\n    amount NUMERIC(10,2) NOT NULL,\n    currency CHAR(3) NOT NULL DEFAULT 'USD',  -- new: added column\n    created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Copy data in batches (reads from old, writes to new):\nINSERT INTO orders_new (id, user_id, amount, created_at)\nSELECT id, customer_id, amount, created_at\nFROM orders\nWHERE id BETWEEN ? AND ?;\n\n-- Once backfill is complete, swap tables atomically:\nBEGIN;\n  LOCK TABLE orders IN ACCESS EXCLUSIVE MODE;  -- Brief lock ‚Äî just for rename\n  ALTER TABLE orders RENAME TO orders_old;\n  ALTER TABLE orders_new RENAME TO orders;\n  -- Update sequences, foreign keys, etc.\nCOMMIT;\n\n-- Dual-write during backfill period:\n-- Application writes to both orders (old) and orders_new simultaneously\n-- After swap, drops orders_old\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis pattern is what tools like pt-online-schema-change (Percona Toolkit) and gh-ost (GitHub) automate for MySQL. For PostgreSQL, pglogical-based migration tools do the same.\u003c/p\u003e\n\u003ch2\u003eManaging Migrations with Flyway/Liquibase\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eFlyway versioned migration structure:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edb/migration/\n  V1__create_orders_table.sql\n  V2__add_customer_id_index.sql\n  V3__add_user_id_column.sql          ‚Üê expand\n  V4__backfill_user_id.sql            ‚Üê migrate (run separately or in batches)\n  V5__add_user_id_not_null.sql        ‚Üê contract step 1\n  V6__drop_customer_id_column.sql     ‚Üê contract step 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCritical Flyway rules for zero-downtime:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNever modify a migration after it's been applied\u003c/strong\u003e ‚Äî Flyway checksums every migration; modification causes startup failure. Create a new migration instead.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSeparate schema migrations from data migrations\u003c/strong\u003e ‚Äî Schema migrations (V3) run at deploy time. Data migrations (V4 ‚Äî backfill) should run as background jobs, not blocking app startup.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIdempotency for repeatable migrations\u003c/strong\u003e ‚Äî Flyway's R__ prefix for repeatable migrations (views, stored procedures) runs them on every change. Schema migrations (V__) run once.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Spring Boot Flyway config:\n@Configuration\npublic class FlywayConfig {\n\n    @Bean\n    public FlywayMigrationStrategy flywayMigrationStrategy() {\n        return flyway -\u003e {\n            // Run baseline repair if needed\n            flyway.repair();\n            flyway.migrate();\n        };\n    }\n}\n\n// application.properties:\nspring.flyway.locations=classpath:db/migration\nspring.flyway.baseline-on-migrate=true\nspring.flyway.out-of-order=false  // Enforce sequential migration order\nspring.flyway.validate-on-migrate=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eLiquibase for multi-database compatibility:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# liquibase/changelog/0003-add-user-id.yaml\ndatabaseChangeLog:\n  - changeSet:\n      id: \"0003-add-user-id-column\"\n      author: \"engineering\"\n      runOnChange: false\n      failOnError: true\n      changes:\n        - addColumn:\n            tableName: orders\n            columns:\n              - column:\n                  name: user_id\n                  type: BIGINT\n                  constraints:\n                    nullable: true  # Start nullable ‚Äî NOT NULL added later\n      rollback:\n        - dropColumn:\n            tableName: orders\n            columnName: user_id\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRolling Deployments: The Application Side\u003c/h2\u003e\n\u003cp\u003eDuring a rolling deployment, both old and new pod versions run simultaneously against the same database. Write application code to tolerate this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Old code: reads customer_id\n// New code: reads user_id (with fallback during transition)\n\n// Repository method during Phase 1 (both columns exist, old code still deployed):\npublic Long getUserId(Order order) {\n    // New code reads new column, falls back to old if null\n    return order.getUserId() != null ? order.getUserId() : order.getCustomerId();\n}\n\n// Writes to both during transition:\n@Transactional\npublic Order createOrder(OrderRequest request) {\n    Order order = new Order();\n    order.setUserId(request.getUserId());      // New column\n    order.setCustomerId(request.getUserId());  // Old column (backward compat)\n    order.setAmount(request.getAmount());\n    return orderRepository.save(order);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis dual-write period is the most fragile moment. Keep it short ‚Äî ideally one deployment cycle (hours, not days). Remove the backward-compatible code in the next deployment.\u003c/p\u003e\n\u003ch2\u003eTesting Migrations\u003c/h2\u003e\n\u003cp\u003eNever run migrations only in production. Test them in staging with production-scale data:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Clone production data (anonymized) to staging:\npg_dump --no-acl --no-owner production_db | psql staging_db\n\n# Run migration and time it:\ntime psql staging_db -f V5__add_user_id_not_null.sql\n\n# Check for locks during migration:\npsql staging_db -c \"\nSELECT pid, wait_event_type, wait_event, state, query\nFROM pg_stat_activity\nWHERE state != 'idle'\nORDER BY duration DESC;\"\n\n# Verify no table rewrites (should show no sequential scans on large tables):\npsql staging_db -c \"EXPLAIN ANALYZE \u0026#x3C;your migration SQL\u003e;\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eThe pre-flight checklist:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs this migration backward-compatible? (Can old app code run with the new schema?)\u003c/li\u003e\n\u003cli\u003eWill it acquire a lock? For how long? (Check PostgreSQL lock documentation for each \u003ccode\u003eALTER TABLE\u003c/code\u003e variant)\u003c/li\u003e\n\u003cli\u003eCan it be made concurrent? (\u003ccode\u003eCREATE INDEX CONCURRENTLY\u003c/code\u003e, \u003ccode\u003eADD CONSTRAINT ... NOT VALID\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eIs there a rollback path? (For each phase of expand-contract)\u003c/li\u003e\n\u003cli\u003eHas it been tested on production-scale data?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDatabase migrations are the rare operations where going slow saves time. A 5-minute outage for a botched migration is worth a week's worth of careful planning. The expand-contract pattern is more work than a single ALTER statement, but it's the difference between a boring deploy and an incident postmortem.\u003c/p\u003e\n","tableOfContents":[{"id":"the-expand-contract-pattern","text":"The Expand-Contract Pattern","level":2},{"id":"pattern-1-renaming-a-column","text":"Pattern 1: Renaming a Column","level":2},{"id":"pattern-2-adding-a-not-null-column","text":"Pattern 2: Adding a NOT NULL Column","level":2},{"id":"pattern-3-index-creation-without-locking","text":"Pattern 3: Index Creation Without Locking","level":2},{"id":"pattern-4-large-table-alterations","text":"Pattern 4: Large Table Alterations","level":2},{"id":"managing-migrations-with-flywayliquibase","text":"Managing Migrations with Flyway/Liquibase","level":2},{"id":"rolling-deployments-the-application-side","text":"Rolling Deployments: The Application Side","level":2},{"id":"testing-migrations","text":"Testing Migrations","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads","description":"A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.","date":"2025-06-03","category":"Databases","tags":["postgresql","databases","performance","sql","indexing","query optimization"],"featured":false,"affiliateSection":"database-resources","slug":"postgresql-performance-tuning","readingTime":"9 min read","excerpt":"PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they're a query design problem that Post‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"zero-downtime-database-migrations"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>