<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Cassandra Data Modeling: Design for Queries, Not Entities<!-- --> | CodeSprintPro</title><meta name="description" content="Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/cassandra-data-modeling/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Cassandra Data Modeling: Design for Queries, Not Entities" data-next-head=""/><meta property="og:description" content="Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/cassandra-data-modeling/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-06-18" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="cassandra" data-next-head=""/><meta property="article:tag" content="nosql" data-next-head=""/><meta property="article:tag" content="data modeling" data-next-head=""/><meta property="article:tag" content="distributed databases" data-next-head=""/><meta property="article:tag" content="partition key" data-next-head=""/><meta property="article:tag" content="cql" data-next-head=""/><meta property="article:tag" content="time series" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Cassandra Data Modeling: Design for Queries, Not Entities" data-next-head=""/><meta name="twitter:description" content="Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-06-18","dateModified":"2025-06-18","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/cassandra-data-modeling/"},"keywords":"cassandra, nosql, data modeling, distributed databases, partition key, cql, time series","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Cassandra Data Modeling: Design for Queries, Not Entities</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Cassandra Data Modeling: Design for Queries, Not Entities</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>June 18, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->cassandra</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->nosql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->data modeling</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->distributed databases</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->partition key</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->cql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->time series</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partition key hashing. Understanding this architecture is not optional; it directly determines your data model choices.</p>
<p>The cardinal rule of Cassandra modeling: <strong>design your tables around your queries, not your entities</strong>. In relational databases, you normalize data and let the query planner figure out joins. In Cassandra, there is no query planner that helps you. Joins don't exist. <code>ALLOW FILTERING</code> exists but bypasses the index and performs full-table scans. Your schema must anticipate every query pattern in advance.</p>
<h2>The Storage Model</h2>
<p>Before modeling, understand how Cassandra stores data:</p>
<pre><code>Cassandra Storage Architecture:

Partition Key (PK):
  ‚Üí Determines which node stores the data (via consistent hashing)
  ‚Üí ALL data with the same partition key lives on the same node
  ‚Üí One partition key = one "row" in Cassandra's storage engine

Clustering Columns (CC):
  ‚Üí Sort key WITHIN a partition
  ‚Üí Data is physically stored sorted by CC on disk
  ‚Üí Range queries (WHERE cc > x AND cc &#x3C; y) are efficient

Regular Columns:
  ‚Üí Just values, no ordering significance

Physical storage (simplified):
Partition: user_id=1001
  [name="Alice", email="alice@example.com"] ‚Üê static columns (once per partition)
  [ts=2025-01-01, event="login"]            ‚Üê clustering row 1
  [ts=2025-01-02, event="purchase"]          ‚Üê clustering row 2
  [ts=2025-01-03, event="logout"]            ‚Üê clustering row 3
  (sorted by ts ascending)
</code></pre>
<p>A CQL <code>SELECT</code> that specifies the full partition key reads from one node ‚Äî O(1) lookup. A query that doesn't specify the partition key fans out to every node ‚Äî O(n) cluster-wide scan.</p>
<h2>Pattern 1: Query-First Modeling</h2>
<p><strong>Use case: Build a social media activity feed ‚Äî "show user's recent activity, paginated"</strong></p>
<p>Relational model (what you'd do in PostgreSQL):</p>
<pre><code class="language-sql">-- Normalized: store users and events separately
CREATE TABLE users (id UUID PRIMARY KEY, name TEXT);
CREATE TABLE events (id UUID, user_id UUID, type TEXT, created_at TIMESTAMP);
-- Join at query time, ORDER BY created_at
</code></pre>
<p>Cassandra model (design for the query):</p>
<pre><code class="language-sql">-- Table is named for the query it answers
CREATE TABLE user_activity_by_user (
    user_id     UUID,
    occurred_at TIMESTAMP,
    event_type  TEXT,
    payload     TEXT,
    PRIMARY KEY (user_id, occurred_at)  -- PK: user_id | CC: occurred_at
) WITH CLUSTERING ORDER BY (occurred_at DESC);  -- Most recent first

-- Query (efficient ‚Äî hits one partition, reads sequentially):
SELECT * FROM user_activity_by_user
WHERE user_id = ?
ORDER BY occurred_at DESC
LIMIT 20;

-- Pagination: use occurred_at of last seen row as cursor
SELECT * FROM user_activity_by_user
WHERE user_id = ? AND occurred_at &#x3C; ?  -- "before this timestamp"
ORDER BY occurred_at DESC
LIMIT 20;
</code></pre>
<p>Why this works: <code>user_id</code> is the partition key ‚Äî all of a user's events live on the same node, sorted by <code>occurred_at</code> DESC on disk. The query reads a contiguous range of sorted data ‚Äî no scatter, no sort.</p>
<p><strong>Anti-pattern:</strong> <code>SELECT * FROM user_activity WHERE type = 'purchase'</code> ‚Äî no partition key specified. Cassandra must scan every partition on every node. Never do this in production.</p>
<h2>Pattern 2: Compound Partition Keys for Distributed Writes</h2>
<p><strong>Problem: Storing IoT sensor readings</strong></p>
<p>Naive model:</p>
<pre><code class="language-sql">CREATE TABLE sensor_readings (
    sensor_id   UUID,
    recorded_at TIMESTAMP,
    value       DOUBLE,
    PRIMARY KEY (sensor_id, recorded_at)
);
</code></pre>
<p>This works for queries (<code>WHERE sensor_id = ?</code>). But what if you have one sensor generating 10,000 writes/second? All writes for that sensor go to a single partition on a single node. That's a <strong>hot partition</strong> ‚Äî you've created a bottleneck in a supposedly distributed system.</p>
<p>Fix with compound partition key (time bucketing):</p>
<pre><code class="language-sql">CREATE TABLE sensor_readings_v2 (
    sensor_id   UUID,
    bucket      TEXT,        -- 'YYYY-MM-DD' ‚Äî one bucket per day
    recorded_at TIMESTAMP,
    value       DOUBLE,
    PRIMARY KEY ((sensor_id, bucket), recorded_at)  -- compound PK
) WITH CLUSTERING ORDER BY (recorded_at ASC);

-- Write:
INSERT INTO sensor_readings_v2 (sensor_id, bucket, recorded_at, value)
VALUES (?, '2025-01-15', ?, ?);

-- Query (must know the bucket):
SELECT * FROM sensor_readings_v2
WHERE sensor_id = ? AND bucket = '2025-01-15'
AND recorded_at >= '2025-01-15 00:00:00'
AND recorded_at &#x3C; '2025-01-16 00:00:00';

-- Multi-day query (application-level loop):
// Fetch each bucket separately and merge client-side
for (String bucket : getDateRange(startDate, endDate)) {
    results.addAll(query(sensorId, bucket));
}
</code></pre>
<p>The compound partition key <code>(sensor_id, bucket)</code> spreads writes for the same sensor across different partitions (different days hash to different nodes). The tradeoff: your application must know the bucket to query, and cross-bucket queries require multiple round trips.</p>
<p><strong>Partition size guidance:</strong> Keep partitions under 100MB (soft) or 1GB (hard Cassandra limit). For time-series data, choose a bucket size where <code>writes_per_second √ó row_size √ó seconds_in_bucket &#x3C; 100MB</code>. Daily buckets work for most IoT data.</p>
<h2>Pattern 3: Denormalization ‚Äî Duplicate for Query Patterns</h2>
<p>If you need to query the same data in two different ways, you need two tables:</p>
<p><strong>Use case: E-commerce orders ‚Äî query by customer AND by product</strong></p>
<pre><code class="language-sql">-- Table 1: orders by customer (primary access pattern)
CREATE TABLE orders_by_customer (
    customer_id UUID,
    order_id    UUID,
    order_date  TIMESTAMP,
    total_cents BIGINT,
    status      TEXT,
    PRIMARY KEY (customer_id, order_date, order_id)
) WITH CLUSTERING ORDER BY (order_date DESC, order_id ASC);

-- Table 2: orders by product (secondary access pattern)
CREATE TABLE orders_by_product (
    product_id  UUID,
    order_date  TIMESTAMP,
    order_id    UUID,
    customer_id UUID,
    quantity    INT,
    PRIMARY KEY (product_id, order_date, order_id)
) WITH CLUSTERING ORDER BY (order_date DESC, order_id ASC);

-- Application writes to BOTH tables (usually via batch):
BEGIN BATCH
  INSERT INTO orders_by_customer (customer_id, order_id, order_date, total_cents, status)
    VALUES (?, ?, ?, ?, ?);
  INSERT INTO orders_by_product (product_id, order_date, order_id, customer_id, quantity)
    VALUES (?, ?, ?, ?, ?);
APPLY BATCH;
</code></pre>
<p>Cassandra logged batches guarantee atomicity (either both writes succeed or neither does). Use them for maintaining consistency across denormalized tables representing the same logical event.</p>
<p><strong>Storage cost:</strong> You're duplicating data. For most workloads, disk is cheap; latency and availability are expensive. Cassandra clusters typically run with a replication factor of 3, so data is already 3√ó replicated. Duplicating for a query pattern is not a major cost concern.</p>
<h2>Pattern 4: Materialized Views vs. Manual Duplication</h2>
<p>Cassandra offers Materialized Views (MV) ‚Äî automatically maintained denormalized tables:</p>
<pre><code class="language-sql">-- Base table:
CREATE TABLE users (
    user_id   UUID PRIMARY KEY,
    email     TEXT,
    username  TEXT,
    country   TEXT
);

-- Materialized View: query users by email
CREATE MATERIALIZED VIEW users_by_email AS
    SELECT * FROM users
    WHERE email IS NOT NULL AND user_id IS NOT NULL
    PRIMARY KEY (email, user_id);

-- Query:
SELECT * FROM users_by_email WHERE email = 'alice@example.com';
</code></pre>
<p>Cassandra maintains <code>users_by_email</code> automatically on every write to <code>users</code>. No application-level dual-write needed.</p>
<p><strong>Why production teams avoid MVs:</strong></p>
<ul>
<li>MV writes are asynchronous ‚Äî a base table write returns before the MV is updated. Brief inconsistency windows exist.</li>
<li>MV maintenance adds write amplification and coordination overhead ‚Äî increasing latency on the base table.</li>
<li>MV bugs existed in earlier Cassandra versions; some teams distrust them.</li>
</ul>
<p><strong>Production recommendation:</strong> Use manual dual-write (via application code or Kafka + CDC) for critical query patterns. Use MVs only for non-critical secondary indexes where brief staleness is acceptable.</p>
<h2>Pattern 5: Secondary Indexes ‚Äî When and When Not To</h2>
<p>Cassandra's secondary index (<code>CREATE INDEX ON table(column)</code>) enables queries on non-partition-key columns:</p>
<pre><code class="language-sql">CREATE INDEX ON users (country);

-- Now this works:
SELECT * FROM users WHERE country = 'US';
</code></pre>
<p><strong>The hidden danger:</strong> This query fans out to every node. Each node checks its local index, returns matching rows. For high-cardinality columns (many distinct values) this is inefficient but tolerable. For low-cardinality columns on large datasets (e.g., <code>status IN ('active', 'inactive')</code> on 100M users), every node returns millions of rows ‚Äî catastrophic.</p>
<p><strong>Safe secondary index use cases:</strong></p>
<ul>
<li>Low-cardinality columns on small datasets (&#x3C; 1M rows per query result)</li>
<li>Rarely-executed admin queries where full-node-fan-out is acceptable</li>
<li>Columns where you always also filter on the partition key (making it a single-node lookup)</li>
</ul>
<p><strong>For anything else:</strong> Denormalize into a separate table.</p>
<h2>Cassandra Anti-Patterns to Avoid</h2>
<p><strong>1. Large partitions (the tombstone problem)</strong></p>
<p>Deletes in Cassandra write tombstones ‚Äî markers that say "this data was deleted." Tombstones are compacted away during compaction, but until then, they accumulate. Reading a partition requires scanning all tombstones for it.</p>
<pre><code class="language-sql">-- DANGEROUS: Storing all events for a user in one partition
CREATE TABLE user_events (
    user_id UUID,
    event_id UUID,
    data TEXT,
    PRIMARY KEY (user_id, event_id)
);
-- Deleting old events creates tombstones
-- If users have millions of events + deletions: partition becomes unreadable
-- (coordinator times out scanning tombstones, gc_grace_seconds doesn't help)
</code></pre>
<p>Fix: Use time-bucketed partitions. Delete whole partitions (less tombstones) instead of individual rows.</p>
<p><strong>2. Using Cassandra like a relational database</strong></p>
<pre><code class="language-sql">-- BROKEN: This causes a full cluster scan
SELECT * FROM orders WHERE status = 'pending';

-- BROKEN: UPDATE requires partition key
UPDATE orders SET status = 'shipped' WHERE status = 'pending'; -- Not how CQL works

-- BROKEN: Aggregations without partition key
SELECT COUNT(*) FROM orders WHERE created_at > '2025-01-01'; -- Full scan
</code></pre>
<p><strong>3. Unbounded partition growth</strong></p>
<pre><code class="language-sql">-- DANGEROUS: "All events for order 1234" in one partition
-- If an order accumulates 10,000+ events, partition exceeds 100MB limit
PRIMARY KEY (order_id, event_timestamp)

-- FIX: Bucket by time period
PRIMARY KEY ((order_id, week_bucket), event_timestamp)
</code></pre>
<h2>Lightweight Transactions (LWT) and Why to Avoid Them</h2>
<pre><code class="language-sql">-- LWT: Compare-and-set operations using Paxos
INSERT INTO user_sessions (session_id, user_id, created_at)
VALUES (?, ?, ?)
IF NOT EXISTS;  -- Only insert if no row exists with this session_id

UPDATE inventory SET quantity = quantity - 1
WHERE product_id = ?
IF quantity > 0;  -- Only update if condition is true
</code></pre>
<p>LWTs guarantee linearizability ‚Äî exactly one write wins among concurrent writers. This sounds great. The cost:</p>
<ul>
<li>LWT requires 4 round trips (Paxos phases: Prepare, Promise, Propose, Accept)</li>
<li>LWT is 4-10√ó slower than regular writes</li>
<li>LWT reduces throughput by up to 40% under contention</li>
</ul>
<p><strong>Use LWT only for:</strong> Uniqueness constraints (usernames, emails) and inventory reservation. For everything else, design around eventual consistency or use optimistic concurrency at the application layer.</p>
<h2>Choosing Cassandra</h2>
<p>Cassandra is the right tool when:</p>
<ul>
<li>Write throughput is the primary concern (millions of writes/second, linearly scalable)</li>
<li>Time-series or event data with known access patterns</li>
<li>No joins required, query patterns are defined upfront</li>
<li>Multi-region active-active replication is required (no single master)</li>
<li>Availability > consistency (AP system in CAP theorem)</li>
</ul>
<p>Cassandra is the wrong tool when:</p>
<ul>
<li>You need ad-hoc queries or reporting (use PostgreSQL/Elasticsearch)</li>
<li>Complex transactions spanning multiple entities</li>
<li>Unknown query patterns that will evolve (schema changes are expensive)</li>
<li>Small dataset where Cassandra's operational overhead isn't justified</li>
</ul>
<p>The investment in Cassandra pays off at scale ‚Äî the same cluster that handles 10,000 writes/second handles 100,000 writes/second with added nodes, no schema changes, no query rewrites. That linear scalability is why teams adopt it, and why getting the data model right from the start is non-negotiable.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Cassandra%20Data%20Modeling%3A%20Design%20for%20Queries%2C%20Not%20Entities&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fcassandra-data-modeling%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fcassandra-data-modeling%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-storage-model" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Storage Model</a></li><li class=""><a href="#pattern-1-query-first-modeling" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 1: Query-First Modeling</a></li><li class=""><a href="#pattern-2-compound-partition-keys-for-distributed-writes" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 2: Compound Partition Keys for Distributed Writes</a></li><li class=""><a href="#pattern-3-denormalization-duplicate-for-query-patterns" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 3: Denormalization ‚Äî Duplicate for Query Patterns</a></li><li class=""><a href="#pattern-4-materialized-views-vs-manual-duplication" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 4: Materialized Views vs. Manual Duplication</a></li><li class=""><a href="#pattern-5-secondary-indexes-when-and-when-not-to" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pattern 5: Secondary Indexes ‚Äî When and When Not To</a></li><li class=""><a href="#cassandra-anti-patterns-to-avoid" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Cassandra Anti-Patterns to Avoid</a></li><li class=""><a href="#lightweight-transactions-lwt-and-why-to-avoid-them" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Lightweight Transactions (LWT) and Why to Avoid Them</a></li><li class=""><a href="#choosing-cassandra" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Choosing Cassandra</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a><a href="/blog/postgresql-performance-tuning/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they&#x27;re a query design problem that Post‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->databases</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->performance</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶","contentHtml":"\u003cp\u003eCassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partition key hashing. Understanding this architecture is not optional; it directly determines your data model choices.\u003c/p\u003e\n\u003cp\u003eThe cardinal rule of Cassandra modeling: \u003cstrong\u003edesign your tables around your queries, not your entities\u003c/strong\u003e. In relational databases, you normalize data and let the query planner figure out joins. In Cassandra, there is no query planner that helps you. Joins don't exist. \u003ccode\u003eALLOW FILTERING\u003c/code\u003e exists but bypasses the index and performs full-table scans. Your schema must anticipate every query pattern in advance.\u003c/p\u003e\n\u003ch2\u003eThe Storage Model\u003c/h2\u003e\n\u003cp\u003eBefore modeling, understand how Cassandra stores data:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCassandra Storage Architecture:\n\nPartition Key (PK):\n  ‚Üí Determines which node stores the data (via consistent hashing)\n  ‚Üí ALL data with the same partition key lives on the same node\n  ‚Üí One partition key = one \"row\" in Cassandra's storage engine\n\nClustering Columns (CC):\n  ‚Üí Sort key WITHIN a partition\n  ‚Üí Data is physically stored sorted by CC on disk\n  ‚Üí Range queries (WHERE cc \u003e x AND cc \u0026#x3C; y) are efficient\n\nRegular Columns:\n  ‚Üí Just values, no ordering significance\n\nPhysical storage (simplified):\nPartition: user_id=1001\n  [name=\"Alice\", email=\"alice@example.com\"] ‚Üê static columns (once per partition)\n  [ts=2025-01-01, event=\"login\"]            ‚Üê clustering row 1\n  [ts=2025-01-02, event=\"purchase\"]          ‚Üê clustering row 2\n  [ts=2025-01-03, event=\"logout\"]            ‚Üê clustering row 3\n  (sorted by ts ascending)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA CQL \u003ccode\u003eSELECT\u003c/code\u003e that specifies the full partition key reads from one node ‚Äî O(1) lookup. A query that doesn't specify the partition key fans out to every node ‚Äî O(n) cluster-wide scan.\u003c/p\u003e\n\u003ch2\u003ePattern 1: Query-First Modeling\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eUse case: Build a social media activity feed ‚Äî \"show user's recent activity, paginated\"\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRelational model (what you'd do in PostgreSQL):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Normalized: store users and events separately\nCREATE TABLE users (id UUID PRIMARY KEY, name TEXT);\nCREATE TABLE events (id UUID, user_id UUID, type TEXT, created_at TIMESTAMP);\n-- Join at query time, ORDER BY created_at\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCassandra model (design for the query):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Table is named for the query it answers\nCREATE TABLE user_activity_by_user (\n    user_id     UUID,\n    occurred_at TIMESTAMP,\n    event_type  TEXT,\n    payload     TEXT,\n    PRIMARY KEY (user_id, occurred_at)  -- PK: user_id | CC: occurred_at\n) WITH CLUSTERING ORDER BY (occurred_at DESC);  -- Most recent first\n\n-- Query (efficient ‚Äî hits one partition, reads sequentially):\nSELECT * FROM user_activity_by_user\nWHERE user_id = ?\nORDER BY occurred_at DESC\nLIMIT 20;\n\n-- Pagination: use occurred_at of last seen row as cursor\nSELECT * FROM user_activity_by_user\nWHERE user_id = ? AND occurred_at \u0026#x3C; ?  -- \"before this timestamp\"\nORDER BY occurred_at DESC\nLIMIT 20;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhy this works: \u003ccode\u003euser_id\u003c/code\u003e is the partition key ‚Äî all of a user's events live on the same node, sorted by \u003ccode\u003eoccurred_at\u003c/code\u003e DESC on disk. The query reads a contiguous range of sorted data ‚Äî no scatter, no sort.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAnti-pattern:\u003c/strong\u003e \u003ccode\u003eSELECT * FROM user_activity WHERE type = 'purchase'\u003c/code\u003e ‚Äî no partition key specified. Cassandra must scan every partition on every node. Never do this in production.\u003c/p\u003e\n\u003ch2\u003ePattern 2: Compound Partition Keys for Distributed Writes\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eProblem: Storing IoT sensor readings\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNaive model:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE TABLE sensor_readings (\n    sensor_id   UUID,\n    recorded_at TIMESTAMP,\n    value       DOUBLE,\n    PRIMARY KEY (sensor_id, recorded_at)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works for queries (\u003ccode\u003eWHERE sensor_id = ?\u003c/code\u003e). But what if you have one sensor generating 10,000 writes/second? All writes for that sensor go to a single partition on a single node. That's a \u003cstrong\u003ehot partition\u003c/strong\u003e ‚Äî you've created a bottleneck in a supposedly distributed system.\u003c/p\u003e\n\u003cp\u003eFix with compound partition key (time bucketing):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE TABLE sensor_readings_v2 (\n    sensor_id   UUID,\n    bucket      TEXT,        -- 'YYYY-MM-DD' ‚Äî one bucket per day\n    recorded_at TIMESTAMP,\n    value       DOUBLE,\n    PRIMARY KEY ((sensor_id, bucket), recorded_at)  -- compound PK\n) WITH CLUSTERING ORDER BY (recorded_at ASC);\n\n-- Write:\nINSERT INTO sensor_readings_v2 (sensor_id, bucket, recorded_at, value)\nVALUES (?, '2025-01-15', ?, ?);\n\n-- Query (must know the bucket):\nSELECT * FROM sensor_readings_v2\nWHERE sensor_id = ? AND bucket = '2025-01-15'\nAND recorded_at \u003e= '2025-01-15 00:00:00'\nAND recorded_at \u0026#x3C; '2025-01-16 00:00:00';\n\n-- Multi-day query (application-level loop):\n// Fetch each bucket separately and merge client-side\nfor (String bucket : getDateRange(startDate, endDate)) {\n    results.addAll(query(sensorId, bucket));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe compound partition key \u003ccode\u003e(sensor_id, bucket)\u003c/code\u003e spreads writes for the same sensor across different partitions (different days hash to different nodes). The tradeoff: your application must know the bucket to query, and cross-bucket queries require multiple round trips.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePartition size guidance:\u003c/strong\u003e Keep partitions under 100MB (soft) or 1GB (hard Cassandra limit). For time-series data, choose a bucket size where \u003ccode\u003ewrites_per_second √ó row_size √ó seconds_in_bucket \u0026#x3C; 100MB\u003c/code\u003e. Daily buckets work for most IoT data.\u003c/p\u003e\n\u003ch2\u003ePattern 3: Denormalization ‚Äî Duplicate for Query Patterns\u003c/h2\u003e\n\u003cp\u003eIf you need to query the same data in two different ways, you need two tables:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUse case: E-commerce orders ‚Äî query by customer AND by product\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Table 1: orders by customer (primary access pattern)\nCREATE TABLE orders_by_customer (\n    customer_id UUID,\n    order_id    UUID,\n    order_date  TIMESTAMP,\n    total_cents BIGINT,\n    status      TEXT,\n    PRIMARY KEY (customer_id, order_date, order_id)\n) WITH CLUSTERING ORDER BY (order_date DESC, order_id ASC);\n\n-- Table 2: orders by product (secondary access pattern)\nCREATE TABLE orders_by_product (\n    product_id  UUID,\n    order_date  TIMESTAMP,\n    order_id    UUID,\n    customer_id UUID,\n    quantity    INT,\n    PRIMARY KEY (product_id, order_date, order_id)\n) WITH CLUSTERING ORDER BY (order_date DESC, order_id ASC);\n\n-- Application writes to BOTH tables (usually via batch):\nBEGIN BATCH\n  INSERT INTO orders_by_customer (customer_id, order_id, order_date, total_cents, status)\n    VALUES (?, ?, ?, ?, ?);\n  INSERT INTO orders_by_product (product_id, order_date, order_id, customer_id, quantity)\n    VALUES (?, ?, ?, ?, ?);\nAPPLY BATCH;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCassandra logged batches guarantee atomicity (either both writes succeed or neither does). Use them for maintaining consistency across denormalized tables representing the same logical event.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eStorage cost:\u003c/strong\u003e You're duplicating data. For most workloads, disk is cheap; latency and availability are expensive. Cassandra clusters typically run with a replication factor of 3, so data is already 3√ó replicated. Duplicating for a query pattern is not a major cost concern.\u003c/p\u003e\n\u003ch2\u003ePattern 4: Materialized Views vs. Manual Duplication\u003c/h2\u003e\n\u003cp\u003eCassandra offers Materialized Views (MV) ‚Äî automatically maintained denormalized tables:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Base table:\nCREATE TABLE users (\n    user_id   UUID PRIMARY KEY,\n    email     TEXT,\n    username  TEXT,\n    country   TEXT\n);\n\n-- Materialized View: query users by email\nCREATE MATERIALIZED VIEW users_by_email AS\n    SELECT * FROM users\n    WHERE email IS NOT NULL AND user_id IS NOT NULL\n    PRIMARY KEY (email, user_id);\n\n-- Query:\nSELECT * FROM users_by_email WHERE email = 'alice@example.com';\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCassandra maintains \u003ccode\u003eusers_by_email\u003c/code\u003e automatically on every write to \u003ccode\u003eusers\u003c/code\u003e. No application-level dual-write needed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhy production teams avoid MVs:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMV writes are asynchronous ‚Äî a base table write returns before the MV is updated. Brief inconsistency windows exist.\u003c/li\u003e\n\u003cli\u003eMV maintenance adds write amplification and coordination overhead ‚Äî increasing latency on the base table.\u003c/li\u003e\n\u003cli\u003eMV bugs existed in earlier Cassandra versions; some teams distrust them.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eProduction recommendation:\u003c/strong\u003e Use manual dual-write (via application code or Kafka + CDC) for critical query patterns. Use MVs only for non-critical secondary indexes where brief staleness is acceptable.\u003c/p\u003e\n\u003ch2\u003ePattern 5: Secondary Indexes ‚Äî When and When Not To\u003c/h2\u003e\n\u003cp\u003eCassandra's secondary index (\u003ccode\u003eCREATE INDEX ON table(column)\u003c/code\u003e) enables queries on non-partition-key columns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE INDEX ON users (country);\n\n-- Now this works:\nSELECT * FROM users WHERE country = 'US';\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eThe hidden danger:\u003c/strong\u003e This query fans out to every node. Each node checks its local index, returns matching rows. For high-cardinality columns (many distinct values) this is inefficient but tolerable. For low-cardinality columns on large datasets (e.g., \u003ccode\u003estatus IN ('active', 'inactive')\u003c/code\u003e on 100M users), every node returns millions of rows ‚Äî catastrophic.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSafe secondary index use cases:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLow-cardinality columns on small datasets (\u0026#x3C; 1M rows per query result)\u003c/li\u003e\n\u003cli\u003eRarely-executed admin queries where full-node-fan-out is acceptable\u003c/li\u003e\n\u003cli\u003eColumns where you always also filter on the partition key (making it a single-node lookup)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eFor anything else:\u003c/strong\u003e Denormalize into a separate table.\u003c/p\u003e\n\u003ch2\u003eCassandra Anti-Patterns to Avoid\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e1. Large partitions (the tombstone problem)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eDeletes in Cassandra write tombstones ‚Äî markers that say \"this data was deleted.\" Tombstones are compacted away during compaction, but until then, they accumulate. Reading a partition requires scanning all tombstones for it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- DANGEROUS: Storing all events for a user in one partition\nCREATE TABLE user_events (\n    user_id UUID,\n    event_id UUID,\n    data TEXT,\n    PRIMARY KEY (user_id, event_id)\n);\n-- Deleting old events creates tombstones\n-- If users have millions of events + deletions: partition becomes unreadable\n-- (coordinator times out scanning tombstones, gc_grace_seconds doesn't help)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFix: Use time-bucketed partitions. Delete whole partitions (less tombstones) instead of individual rows.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. Using Cassandra like a relational database\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- BROKEN: This causes a full cluster scan\nSELECT * FROM orders WHERE status = 'pending';\n\n-- BROKEN: UPDATE requires partition key\nUPDATE orders SET status = 'shipped' WHERE status = 'pending'; -- Not how CQL works\n\n-- BROKEN: Aggregations without partition key\nSELECT COUNT(*) FROM orders WHERE created_at \u003e '2025-01-01'; -- Full scan\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Unbounded partition growth\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- DANGEROUS: \"All events for order 1234\" in one partition\n-- If an order accumulates 10,000+ events, partition exceeds 100MB limit\nPRIMARY KEY (order_id, event_timestamp)\n\n-- FIX: Bucket by time period\nPRIMARY KEY ((order_id, week_bucket), event_timestamp)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eLightweight Transactions (LWT) and Why to Avoid Them\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- LWT: Compare-and-set operations using Paxos\nINSERT INTO user_sessions (session_id, user_id, created_at)\nVALUES (?, ?, ?)\nIF NOT EXISTS;  -- Only insert if no row exists with this session_id\n\nUPDATE inventory SET quantity = quantity - 1\nWHERE product_id = ?\nIF quantity \u003e 0;  -- Only update if condition is true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLWTs guarantee linearizability ‚Äî exactly one write wins among concurrent writers. This sounds great. The cost:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLWT requires 4 round trips (Paxos phases: Prepare, Promise, Propose, Accept)\u003c/li\u003e\n\u003cli\u003eLWT is 4-10√ó slower than regular writes\u003c/li\u003e\n\u003cli\u003eLWT reduces throughput by up to 40% under contention\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eUse LWT only for:\u003c/strong\u003e Uniqueness constraints (usernames, emails) and inventory reservation. For everything else, design around eventual consistency or use optimistic concurrency at the application layer.\u003c/p\u003e\n\u003ch2\u003eChoosing Cassandra\u003c/h2\u003e\n\u003cp\u003eCassandra is the right tool when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWrite throughput is the primary concern (millions of writes/second, linearly scalable)\u003c/li\u003e\n\u003cli\u003eTime-series or event data with known access patterns\u003c/li\u003e\n\u003cli\u003eNo joins required, query patterns are defined upfront\u003c/li\u003e\n\u003cli\u003eMulti-region active-active replication is required (no single master)\u003c/li\u003e\n\u003cli\u003eAvailability \u003e consistency (AP system in CAP theorem)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCassandra is the wrong tool when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need ad-hoc queries or reporting (use PostgreSQL/Elasticsearch)\u003c/li\u003e\n\u003cli\u003eComplex transactions spanning multiple entities\u003c/li\u003e\n\u003cli\u003eUnknown query patterns that will evolve (schema changes are expensive)\u003c/li\u003e\n\u003cli\u003eSmall dataset where Cassandra's operational overhead isn't justified\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe investment in Cassandra pays off at scale ‚Äî the same cluster that handles 10,000 writes/second handles 100,000 writes/second with added nodes, no schema changes, no query rewrites. That linear scalability is why teams adopt it, and why getting the data model right from the start is non-negotiable.\u003c/p\u003e\n","tableOfContents":[{"id":"the-storage-model","text":"The Storage Model","level":2},{"id":"pattern-1-query-first-modeling","text":"Pattern 1: Query-First Modeling","level":2},{"id":"pattern-2-compound-partition-keys-for-distributed-writes","text":"Pattern 2: Compound Partition Keys for Distributed Writes","level":2},{"id":"pattern-3-denormalization-duplicate-for-query-patterns","text":"Pattern 3: Denormalization ‚Äî Duplicate for Query Patterns","level":2},{"id":"pattern-4-materialized-views-vs-manual-duplication","text":"Pattern 4: Materialized Views vs. Manual Duplication","level":2},{"id":"pattern-5-secondary-indexes-when-and-when-not-to","text":"Pattern 5: Secondary Indexes ‚Äî When and When Not To","level":2},{"id":"cassandra-anti-patterns-to-avoid","text":"Cassandra Anti-Patterns to Avoid","level":2},{"id":"lightweight-transactions-lwt-and-why-to-avoid-them","text":"Lightweight Transactions (LWT) and Why to Avoid Them","level":2},{"id":"choosing-cassandra","text":"Choosing Cassandra","level":2}]},"relatedPosts":[{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶"},{"title":"PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads","description":"A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.","date":"2025-06-03","category":"Databases","tags":["postgresql","databases","performance","sql","indexing","query optimization"],"featured":false,"affiliateSection":"database-resources","slug":"postgresql-performance-tuning","readingTime":"9 min read","excerpt":"PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they're a query design problem that Post‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"cassandra-data-modeling"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>