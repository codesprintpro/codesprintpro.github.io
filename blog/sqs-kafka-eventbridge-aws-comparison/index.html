<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS<!-- --> | CodeSprintPro</title><meta name="description" content="A senior engineer&#x27;s guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/sqs-kafka-eventbridge-aws-comparison/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS" data-next-head=""/><meta property="og:description" content="A senior engineer&#x27;s guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/sqs-kafka-eventbridge-aws-comparison/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-04-02" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Messaging" data-next-head=""/><meta property="article:tag" content="aws" data-next-head=""/><meta property="article:tag" content="sqs" data-next-head=""/><meta property="article:tag" content="kafka" data-next-head=""/><meta property="article:tag" content="eventbridge" data-next-head=""/><meta property="article:tag" content="distributed systems" data-next-head=""/><meta property="article:tag" content="messaging" data-next-head=""/><meta property="article:tag" content="msk" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS" data-next-head=""/><meta name="twitter:description" content="A senior engineer&#x27;s guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS","description":"A senior engineer's guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-04-02","dateModified":"2025-04-02","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/sqs-kafka-eventbridge-aws-comparison/"},"keywords":"aws, sqs, kafka, eventbridge, distributed systems, messaging, msk","articleSection":"Messaging"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Messaging</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">A senior engineer&#x27;s guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>April 2, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>10 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->aws</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->sqs</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->kafka</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->eventbridge</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->distributed systems</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->messaging</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->msk</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Every AWS backend team eventually faces the same decision: you need asynchronous messaging. SQS is right there in the console. Your architect says you need Kafka. Someone from DevOps mentions EventBridge. Each option has a vocal fan base, and they are all wrong about different things.</p>
<p>This article cuts through the advocacy and gives you a decision framework based on throughput characteristics, cost at scale, operational burden, and failure behavior â€” the things that actually matter in production.</p>
<h2>The Three Systems in One Paragraph Each</h2>
<p><strong>Amazon SQS</strong> is a fully managed queue service. Producers enqueue messages, consumers poll and delete them. Standard queues offer at-least-once delivery with best-effort ordering. FIFO queues offer exactly-once delivery with strict ordering within a message group, capped at 300 messages/second per queue (3000 with batching). SQS has no concept of replay â€” a deleted message is gone.</p>
<p><strong>Apache Kafka on AWS (Amazon MSK)</strong> is a distributed log. Messages are appended to ordered, immutable partitions and retained for a configurable period (default 7 days). Any consumer can read from any offset at any time. Kafka decouples producer throughput from consumer lag â€” a slow consumer doesn't backpressure the producer. MSK Serverless removes cluster management at the cost of throughput limits and higher per-unit cost.</p>
<p><strong>Amazon EventBridge</strong> is a serverless event bus. Producers publish events; EventBridge routes them to targets (Lambda, SQS, Kinesis, HTTP endpoints) based on content-based rules. It is optimized for event-driven architectures where routing logic is complex and throughput is modest. Maximum throughput is 10,000 events/second per bus, with no replay (unless you enable the event archive, which adds cost and latency).</p>
<h2>Throughput Comparison</h2>
<pre><code>System              | Sustained Throughput         | Burst Behavior
--------------------|------------------------------|---------------------------
SQS Standard        | Unlimited (AWS-managed)      | Auto-scales, no config
SQS FIFO            | 300 msg/s (3000 w/ batching) | Hard limit per queue
EventBridge         | 10,000 events/s per bus      | Soft limit, raiseable
MSK (Kafka)         | 1 GB/s+ per broker           | Add brokers/partitions
MSK Serverless      | 200 MB/s ingress             | Automatically scales
</code></pre>
<p>SQS Standard is genuinely unlimited â€” AWS manages the infrastructure horizontally. In practice, the bottleneck becomes your consumer fleet, not SQS itself.</p>
<p>Kafka throughput is bounded by broker count Ã— partition count Ã— disk I/O. A 3-broker MSK cluster with <code>r5.2xlarge</code> instances can sustain 500â€“800 MB/s. Add 3 more brokers and you scale linearly. This is the key advantage: Kafka throughput is predictable and tunable.</p>
<p>EventBridge's 10K events/s feels generous until you're doing analytics ingestion or log streaming â€” at which point it's a hard architectural wall.</p>
<h2>Ordering Guarantees</h2>
<p>This is where teams make expensive mistakes.</p>
<p><strong>SQS Standard</strong> provides best-effort ordering. Across distributed consumers, messages can arrive out of order. For fire-and-forget notifications or task queues where order is irrelevant, this is fine.</p>
<p><strong>SQS FIFO</strong> guarantees order within a <code>MessageGroupId</code>. If you use a single group ID, you get FIFO across the entire queue â€” but throughput drops to 300 msg/s. The practical pattern is to partition by entity ID: use <code>customerId</code> as the group ID to get ordered processing per customer while maintaining parallelism across customers.</p>
<p><strong>Kafka</strong> partitions are strictly ordered. Within a partition, consumers see messages in write order, guaranteed. Across partitions, there is no global ordering â€” this is a fundamental property of the distributed log. Design around it: put messages that must be ordered relative to each other in the same partition using the same partition key.</p>
<p><strong>EventBridge</strong> provides no ordering guarantees. It is designed for event routing, not ordered processing.</p>
<h2>Cost Breakdown at Scale</h2>
<p>Let's be concrete. Assume 100 million messages/day at 1 KB average size.</p>
<p><strong>SQS Standard:</strong></p>
<ul>
<li>100M requests/day Ã— $0.40 per million = <strong>$40/day = $1,200/month</strong></li>
<li>Add data transfer costs if consumers are outside the same region</li>
<li>No infrastructure to manage</li>
</ul>
<p><strong>SQS FIFO:</strong></p>
<ul>
<li>Same request pricing + $0.05 per 10K deduplication checks</li>
<li>At 100M messages: $40 + $500 dedup = <strong>~$1,500/month</strong></li>
</ul>
<p><strong>EventBridge:</strong></p>
<ul>
<li>$1.00 per million custom events = <strong>$100/day = $3,000/month</strong></li>
<li>Plus $0.10 per GB for event archive if replay is needed</li>
<li>Expensive at volume â€” EventBridge is not designed for high-throughput streaming</li>
</ul>
<p><strong>MSK (Amazon Managed Kafka):</strong></p>
<ul>
<li>3Ã— <code>kafka.m5.large</code> brokers: ~$0.21/hr each = <strong>$450/month</strong> cluster cost</li>
<li>EBS storage: 100M Ã— 1KB Ã— 7-day retention = 700 GB Ã— $0.10/GB = <strong>$70/month</strong></li>
<li>MSK data transfer + data out costs</li>
<li>Total: <strong>~$600â€“900/month</strong> for this workload, but flat-rate regardless of message volume</li>
<li>Operational cost: cluster monitoring, lag alerting, schema registry, Kafka client config</li>
</ul>
<p>The crossover point is typically around 50â€“100 million messages/day where MSK becomes cheaper than SQS, assuming you have the engineering capacity to operate it.</p>
<p><strong>MSK Serverless:</strong></p>
<ul>
<li>$0.75/VCU-hour + $0.10/GB-hour storage â€” often 2â€“3Ã— the cost of provisioned MSK at sustained throughput, but zero operational overhead.</li>
</ul>
<h2>Multi-Region Support</h2>
<p><strong>SQS:</strong> Single-region by default. For multi-region, you replicate at the application layer â€” consumer reads from us-east-1 queue, writes to eu-west-1 queue. No native cross-region replication.</p>
<p><strong>EventBridge:</strong> Global buses support cross-account event routing. EventBridge Event Bus can forward events to buses in other regions via rules. This is the simplest cross-region event routing available in AWS, and it's first-class.</p>
<p><strong>Kafka/MSK:</strong> MSK Replication (MirrorMaker 2) replicates topics across clusters in different regions with configurable lag. Active-active multi-region Kafka is operationally complex â€” topic offsets diverge and merging is non-trivial. Most teams do active-passive: one region produces, MirrorMaker2 replicates to the DR region, consumers fail over to the replica cluster manually.</p>
<pre><code>Multi-Region Kafka Architecture (Active-Passive):

us-east-1                          eu-west-1
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MSK Cluster A  â”‚â”€â”€MirrorMakerâ”€â”€â”‚  MSK Cluster B  â”‚
â”‚  (Primary)      â”‚               â”‚  (Replica)       â”‚
â”‚                 â”‚               â”‚                  â”‚
â”‚  Producers â”€â”€â–º  â”‚               â”‚  â—„â”€â”€ Failover    â”‚
â”‚  Consumers â”€â”€â–º  â”‚               â”‚      Consumers   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2>Retry Behavior and Dead Letter Queues</h2>
<p><strong>SQS:</strong> Messages have a configurable <code>VisibilityTimeout</code>. When a consumer reads a message, it becomes invisible to other consumers. If the consumer doesn't delete it before the timeout, it becomes visible again and another consumer picks it up. After <code>maxReceiveCount</code> failures, SQS moves the message to a Dead Letter Queue (DLQ). This is fully managed and requires zero code.</p>
<pre><code>SQS Retry Flow:
Message â†’ Consumer â†’ (processing fails) â†’ Visibility timeout expires
â†’ Message re-visible â†’ Re-consumed â†’ ... â†’ maxReceiveCount reached
â†’ Message moved to DLQ
</code></pre>
<p><strong>EventBridge:</strong> Failed deliveries are retried with exponential backoff for up to 24 hours. If all retries fail, the event is sent to a DLQ (SQS) or dropped. The retry window is configurable but you have limited visibility into retry state.</p>
<p><strong>Kafka:</strong> Kafka has no built-in retry concept at the broker level. Retry is the consumer's responsibility. The production pattern is retry topics:</p>
<pre><code>Retry Topic Pattern:
orders-topic â†’ Consumer (fails) â†’ orders-retry-1 (wait 30s)
â†’ Consumer (fails) â†’ orders-retry-2 (wait 5min)
â†’ Consumer (fails) â†’ orders-retry-3 (wait 30min)
â†’ Consumer (fails) â†’ orders-dlq
</code></pre>
<p>This requires explicit implementation but gives you complete control over retry semantics, delay scheduling, and DLQ routing.</p>
<h2>Scaling Strategy</h2>
<p><strong>SQS:</strong> Consumer scaling is driven by queue depth. AWS SQS â†’ CloudWatch â†’ Auto Scaling Group scales consumer EC2 instances or Lambda concurrency based on <code>ApproximateNumberOfMessagesVisible</code>. This is mature and well-understood.</p>
<p><strong>EventBridge:</strong> Targets scale automatically (Lambda, Fargate). You don't manage consumers. This is the point â€” EventBridge handles fan-out and routing so you don't have to.</p>
<p><strong>Kafka:</strong> Consumer scaling is partition-bound. You cannot have more active consumers in a consumer group than partitions in a topic. Plan partition count at topic creation: <code>partitions = max_expected_consumers Ã— headroom_factor</code>. Kafka's <code>kafka.admin.client</code> lets you expand partition count after creation, but redistributing partitions causes a brief rebalance. Pre-partition aggressively.</p>
<h2>Operational Overhead</h2>
<p>This is where honest conversations get uncomfortable.</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>SQS</th>
<th>EventBridge</th>
<th>MSK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cluster provisioning</td>
<td>None</td>
<td>None</td>
<td>Broker sizing, AZ config</td>
</tr>
<tr>
<td>Schema management</td>
<td>None</td>
<td>JSON schema registry (optional)</td>
<td>Confluent Schema Registry or Glue</td>
</tr>
<tr>
<td>Monitoring</td>
<td>Basic CloudWatch</td>
<td>Basic CloudWatch</td>
<td>Custom dashboards, consumer lag</td>
</tr>
<tr>
<td>Security</td>
<td>IAM, VPC</td>
<td>IAM, resource policies</td>
<td>mTLS, SASL, ACLs</td>
</tr>
<tr>
<td>Upgrade management</td>
<td>Automatic</td>
<td>Automatic</td>
<td>MSK broker version upgrades</td>
</tr>
<tr>
<td>Consumer lag tracking</td>
<td>Queue depth metrics</td>
<td>None</td>
<td>Kafka consumer group offsets</td>
</tr>
</tbody>
</table>
<p>MSK is the Kafka product of choice on AWS, but "managed" is relative. You still provision brokers, choose instance types, manage broker storage, configure retention, set up Schema Registry, build consumer lag dashboards, and handle rebalance storms.</p>
<p>MSK Serverless offloads most of this at a cost premium. For teams without dedicated platform engineering, MSK Serverless or Confluent Cloud are worth the price.</p>
<h2>Latency Characteristics</h2>
<p><strong>SQS</strong> short-polling returns immediately (empty or not). Long-polling waits up to 20 seconds, which reduces empty receives and cost. End-to-end latency (produce â†’ consume) is typically 50â€“200ms under normal load, with occasional spikes to seconds under high retry load.</p>
<p><strong>EventBridge</strong> typically delivers in under 500ms. For Lambda targets, add cold start time. Not appropriate for sub-100ms requirements.</p>
<p><strong>Kafka</strong> end-to-end latency depends on producer acknowledgment settings:</p>
<ul>
<li><code>acks=0</code>: fire and forget, ~5ms produce latency, data loss risk</li>
<li><code>acks=1</code>: leader acknowledges, ~10â€“20ms</li>
<li><code>acks=all</code>: all ISR replicas acknowledge, 20â€“50ms typically</li>
</ul>
<p>Consumer-side, with <code>fetch.min.bytes=1</code> and <code>fetch.max.wait.ms=500</code> defaults, a new message is consumed within 1â€“500ms after it's committed. For low-latency streaming (&#x3C; 100ms end-to-end), tune <code>fetch.max.wait.ms=0</code>.</p>
<h2>When Kafka is Overkill</h2>
<p>Use SQS when:</p>
<ul>
<li>You need a simple task queue with retry and DLQ</li>
<li>Throughput is under 10K messages/second</li>
<li>You don't need message replay</li>
<li>Your team has no Kafka operational experience</li>
<li>You're a startup without a platform team</li>
</ul>
<p>Kafka's power comes from replayability, strict ordering, and high throughput. If your use case doesn't need these properties, you're paying operational overhead for nothing.</p>
<h2>When SQS Fails at Scale</h2>
<p>SQS FIFO breaks at ordering + throughput intersection. At 300 msg/s per queue (3,000 with batching), you hit the hard limit. The workaround is sharding: deploy 10 FIFO queues, partition by entity ID, route producers accordingly. This works, but you've now built a partition routing layer â€” which is exactly what Kafka does natively.</p>
<p>SQS Standard's lack of replay means you cannot re-process a stream of events. If your downstream system has a bug that corrupts two hours of data, you cannot replay from two hours ago. You need a separate audit log â€” at which point, you should have just used Kafka.</p>
<h2>Real Production Case Study</h2>
<p>At a fintech company processing 5 million payment events per day, the team started with SQS FIFO for per-customer ordered processing. After 18 months:</p>
<ul>
<li>FIFO throughput limit triggered scaling issues during month-end batch processing</li>
<li>Zero replay capability meant a buggy consumer silently dropped 30,000 events before detection â€” requiring a full re-run from an S3 audit backup</li>
<li>Adding a new downstream consumer required modifying the producer to enqueue to a second queue</li>
</ul>
<p>Migration to MSK:</p>
<ul>
<li>Topic: <code>payment-events</code> with 48 partitions (keyed by <code>customerId</code>)</li>
<li>Consumer groups per downstream system â€” each independently maintains its offset</li>
<li>7-day retention enabled replay of any incident window</li>
<li>MirrorMaker2 replicates to a DR region</li>
</ul>
<p>Operational cost increased by $800/month. Engineering productivity increased significantly â€” onboarding new consumers went from code changes to a new consumer group.</p>
<h2>Decision Framework</h2>
<pre><code>START
â”‚
â”œâ”€â”€ Do you need message replay?
â”‚   â””â”€â”€ YES â†’ Kafka (MSK)
â”‚
â”œâ”€â”€ Do you need cross-service event routing with content-based rules?
â”‚   â””â”€â”€ YES â†’ EventBridge
â”‚
â”œâ”€â”€ Do you need strict ordering + throughput > 3000 msg/s?
â”‚   â””â”€â”€ YES â†’ Kafka (MSK)
â”‚
â”œâ”€â”€ Do you have a platform team to operate Kafka?
â”‚   â””â”€â”€ NO + need Kafka features â†’ MSK Serverless or Confluent Cloud
â”‚
â””â”€â”€ Simple task queue, retry + DLQ, &#x3C; 3000 ordered msg/s?
    â””â”€â”€ YES â†’ SQS (FIFO if ordering matters, Standard otherwise)
</code></pre>
<p>The default should be SQS. Introduce Kafka when you hit the specific limitations that Kafka solves. EventBridge shines in event-driven microservice architectures where routing logic is the primary challenge.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">AWS Solutions Architect Associate â€” Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Most popular AWS certification course by Stephane Maarek.</p></div><a href="https://www.udemy.com/course/aws-certified-solutions-architect-associate-saa-c03/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">AWS in Action, 3rd Edition</span></div><p class="text-xs text-gray-600">Hands-on guide to building cloud applications on AWS.</p></div><a href="https://amzn.to/3Vmf49E" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=SQS%20vs%20Kafka%20vs%20EventBridge%3A%20Choosing%20the%20Right%20Messaging%20System%20on%20AWS&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsqs-kafka-eventbridge-aws-comparison%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsqs-kafka-eventbridge-aws-comparison%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-three-systems-in-one-paragraph-each" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Three Systems in One Paragraph Each</a></li><li class=""><a href="#throughput-comparison" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Throughput Comparison</a></li><li class=""><a href="#ordering-guarantees" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Ordering Guarantees</a></li><li class=""><a href="#cost-breakdown-at-scale" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Cost Breakdown at Scale</a></li><li class=""><a href="#multi-region-support" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Multi-Region Support</a></li><li class=""><a href="#retry-behavior-and-dead-letter-queues" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Retry Behavior and Dead Letter Queues</a></li><li class=""><a href="#scaling-strategy" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Scaling Strategy</a></li><li class=""><a href="#operational-overhead" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Operational Overhead</a></li><li class=""><a href="#latency-characteristics" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Latency Characteristics</a></li><li class=""><a href="#when-kafka-is-overkill" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">When Kafka is Overkill</a></li><li class=""><a href="#when-sqs-fails-at-scale" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">When SQS Fails at Scale</a></li><li class=""><a href="#real-production-case-study" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Real Production Case Study</a></li><li class=""><a href="#decision-framework" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Decision Framework</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/kafka-exactly-once-semantics/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-red-100 text-red-700">Messaging</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Kafka Exactly-Once Semantics: Myth vs Production Reality</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Kafka 0.11 introduced exactly-once semantics (EOS), and every architecture diagram since then has confidently placed a checkbox next to &quot;exactly once delivery.&quot; In practice, most teams deploying Kafka with EOS still see â€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Apr 20, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->kafka</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->exactly-once</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring kafka</span></div></article></a><a href="/blog/kafka-internals-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-red-100 text-red-700">Messaging</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Kafka Internals Deep Dive: Partitions, Offsets, and Consumer Groups</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Apache Kafka is the de facto standard for event streaming in distributed systems, but most developers treat it as a black box â€” a durable message queue with a fancy name. Understanding Kafka&#x27;s internals unlocks its true â€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jan 15, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>10 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->kafka</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->distributed systems</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->streaming</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQS vs Kafka vs EventBridge: Choosing the Right Messaging System on AWS","description":"A senior engineer's guide to selecting between Amazon SQS, Apache Kafka on AWS, and EventBridge. Throughput benchmarks, cost breakdowns, ordering guarantees, and real production trade-offs.","date":"2025-04-02","category":"Messaging","tags":["aws","sqs","kafka","eventbridge","distributed systems","messaging","msk"],"featured":false,"affiliateSection":"aws-resources","slug":"sqs-kafka-eventbridge-aws-comparison","readingTime":"10 min read","excerpt":"Every AWS backend team eventually faces the same decision: you need asynchronous messaging. SQS is right there in the console. Your architect says you need Kafka. Someone from DevOps mentions EventBridge. Each option hasâ€¦","contentHtml":"\u003cp\u003eEvery AWS backend team eventually faces the same decision: you need asynchronous messaging. SQS is right there in the console. Your architect says you need Kafka. Someone from DevOps mentions EventBridge. Each option has a vocal fan base, and they are all wrong about different things.\u003c/p\u003e\n\u003cp\u003eThis article cuts through the advocacy and gives you a decision framework based on throughput characteristics, cost at scale, operational burden, and failure behavior â€” the things that actually matter in production.\u003c/p\u003e\n\u003ch2\u003eThe Three Systems in One Paragraph Each\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eAmazon SQS\u003c/strong\u003e is a fully managed queue service. Producers enqueue messages, consumers poll and delete them. Standard queues offer at-least-once delivery with best-effort ordering. FIFO queues offer exactly-once delivery with strict ordering within a message group, capped at 300 messages/second per queue (3000 with batching). SQS has no concept of replay â€” a deleted message is gone.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eApache Kafka on AWS (Amazon MSK)\u003c/strong\u003e is a distributed log. Messages are appended to ordered, immutable partitions and retained for a configurable period (default 7 days). Any consumer can read from any offset at any time. Kafka decouples producer throughput from consumer lag â€” a slow consumer doesn't backpressure the producer. MSK Serverless removes cluster management at the cost of throughput limits and higher per-unit cost.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAmazon EventBridge\u003c/strong\u003e is a serverless event bus. Producers publish events; EventBridge routes them to targets (Lambda, SQS, Kinesis, HTTP endpoints) based on content-based rules. It is optimized for event-driven architectures where routing logic is complex and throughput is modest. Maximum throughput is 10,000 events/second per bus, with no replay (unless you enable the event archive, which adds cost and latency).\u003c/p\u003e\n\u003ch2\u003eThroughput Comparison\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eSystem              | Sustained Throughput         | Burst Behavior\n--------------------|------------------------------|---------------------------\nSQS Standard        | Unlimited (AWS-managed)      | Auto-scales, no config\nSQS FIFO            | 300 msg/s (3000 w/ batching) | Hard limit per queue\nEventBridge         | 10,000 events/s per bus      | Soft limit, raiseable\nMSK (Kafka)         | 1 GB/s+ per broker           | Add brokers/partitions\nMSK Serverless      | 200 MB/s ingress             | Automatically scales\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSQS Standard is genuinely unlimited â€” AWS manages the infrastructure horizontally. In practice, the bottleneck becomes your consumer fleet, not SQS itself.\u003c/p\u003e\n\u003cp\u003eKafka throughput is bounded by broker count Ã— partition count Ã— disk I/O. A 3-broker MSK cluster with \u003ccode\u003er5.2xlarge\u003c/code\u003e instances can sustain 500â€“800 MB/s. Add 3 more brokers and you scale linearly. This is the key advantage: Kafka throughput is predictable and tunable.\u003c/p\u003e\n\u003cp\u003eEventBridge's 10K events/s feels generous until you're doing analytics ingestion or log streaming â€” at which point it's a hard architectural wall.\u003c/p\u003e\n\u003ch2\u003eOrdering Guarantees\u003c/h2\u003e\n\u003cp\u003eThis is where teams make expensive mistakes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSQS Standard\u003c/strong\u003e provides best-effort ordering. Across distributed consumers, messages can arrive out of order. For fire-and-forget notifications or task queues where order is irrelevant, this is fine.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSQS FIFO\u003c/strong\u003e guarantees order within a \u003ccode\u003eMessageGroupId\u003c/code\u003e. If you use a single group ID, you get FIFO across the entire queue â€” but throughput drops to 300 msg/s. The practical pattern is to partition by entity ID: use \u003ccode\u003ecustomerId\u003c/code\u003e as the group ID to get ordered processing per customer while maintaining parallelism across customers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKafka\u003c/strong\u003e partitions are strictly ordered. Within a partition, consumers see messages in write order, guaranteed. Across partitions, there is no global ordering â€” this is a fundamental property of the distributed log. Design around it: put messages that must be ordered relative to each other in the same partition using the same partition key.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge\u003c/strong\u003e provides no ordering guarantees. It is designed for event routing, not ordered processing.\u003c/p\u003e\n\u003ch2\u003eCost Breakdown at Scale\u003c/h2\u003e\n\u003cp\u003eLet's be concrete. Assume 100 million messages/day at 1 KB average size.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSQS Standard:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e100M requests/day Ã— $0.40 per million = \u003cstrong\u003e$40/day = $1,200/month\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eAdd data transfer costs if consumers are outside the same region\u003c/li\u003e\n\u003cli\u003eNo infrastructure to manage\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSQS FIFO:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSame request pricing + $0.05 per 10K deduplication checks\u003c/li\u003e\n\u003cli\u003eAt 100M messages: $40 + $500 dedup = \u003cstrong\u003e~$1,500/month\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$1.00 per million custom events = \u003cstrong\u003e$100/day = $3,000/month\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003ePlus $0.10 per GB for event archive if replay is needed\u003c/li\u003e\n\u003cli\u003eExpensive at volume â€” EventBridge is not designed for high-throughput streaming\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMSK (Amazon Managed Kafka):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e3Ã— \u003ccode\u003ekafka.m5.large\u003c/code\u003e brokers: ~$0.21/hr each = \u003cstrong\u003e$450/month\u003c/strong\u003e cluster cost\u003c/li\u003e\n\u003cli\u003eEBS storage: 100M Ã— 1KB Ã— 7-day retention = 700 GB Ã— $0.10/GB = \u003cstrong\u003e$70/month\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eMSK data transfer + data out costs\u003c/li\u003e\n\u003cli\u003eTotal: \u003cstrong\u003e~$600â€“900/month\u003c/strong\u003e for this workload, but flat-rate regardless of message volume\u003c/li\u003e\n\u003cli\u003eOperational cost: cluster monitoring, lag alerting, schema registry, Kafka client config\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe crossover point is typically around 50â€“100 million messages/day where MSK becomes cheaper than SQS, assuming you have the engineering capacity to operate it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMSK Serverless:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$0.75/VCU-hour + $0.10/GB-hour storage â€” often 2â€“3Ã— the cost of provisioned MSK at sustained throughput, but zero operational overhead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMulti-Region Support\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eSQS:\u003c/strong\u003e Single-region by default. For multi-region, you replicate at the application layer â€” consumer reads from us-east-1 queue, writes to eu-west-1 queue. No native cross-region replication.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge:\u003c/strong\u003e Global buses support cross-account event routing. EventBridge Event Bus can forward events to buses in other regions via rules. This is the simplest cross-region event routing available in AWS, and it's first-class.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKafka/MSK:\u003c/strong\u003e MSK Replication (MirrorMaker 2) replicates topics across clusters in different regions with configurable lag. Active-active multi-region Kafka is operationally complex â€” topic offsets diverge and merging is non-trivial. Most teams do active-passive: one region produces, MirrorMaker2 replicates to the DR region, consumers fail over to the replica cluster manually.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMulti-Region Kafka Architecture (Active-Passive):\n\nus-east-1                          eu-west-1\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  MSK Cluster A  â”‚â”€â”€MirrorMakerâ”€â”€â”‚  MSK Cluster B  â”‚\nâ”‚  (Primary)      â”‚               â”‚  (Replica)       â”‚\nâ”‚                 â”‚               â”‚                  â”‚\nâ”‚  Producers â”€â”€â–º  â”‚               â”‚  â—„â”€â”€ Failover    â”‚\nâ”‚  Consumers â”€â”€â–º  â”‚               â”‚      Consumers   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRetry Behavior and Dead Letter Queues\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eSQS:\u003c/strong\u003e Messages have a configurable \u003ccode\u003eVisibilityTimeout\u003c/code\u003e. When a consumer reads a message, it becomes invisible to other consumers. If the consumer doesn't delete it before the timeout, it becomes visible again and another consumer picks it up. After \u003ccode\u003emaxReceiveCount\u003c/code\u003e failures, SQS moves the message to a Dead Letter Queue (DLQ). This is fully managed and requires zero code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSQS Retry Flow:\nMessage â†’ Consumer â†’ (processing fails) â†’ Visibility timeout expires\nâ†’ Message re-visible â†’ Re-consumed â†’ ... â†’ maxReceiveCount reached\nâ†’ Message moved to DLQ\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge:\u003c/strong\u003e Failed deliveries are retried with exponential backoff for up to 24 hours. If all retries fail, the event is sent to a DLQ (SQS) or dropped. The retry window is configurable but you have limited visibility into retry state.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKafka:\u003c/strong\u003e Kafka has no built-in retry concept at the broker level. Retry is the consumer's responsibility. The production pattern is retry topics:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRetry Topic Pattern:\norders-topic â†’ Consumer (fails) â†’ orders-retry-1 (wait 30s)\nâ†’ Consumer (fails) â†’ orders-retry-2 (wait 5min)\nâ†’ Consumer (fails) â†’ orders-retry-3 (wait 30min)\nâ†’ Consumer (fails) â†’ orders-dlq\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis requires explicit implementation but gives you complete control over retry semantics, delay scheduling, and DLQ routing.\u003c/p\u003e\n\u003ch2\u003eScaling Strategy\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eSQS:\u003c/strong\u003e Consumer scaling is driven by queue depth. AWS SQS â†’ CloudWatch â†’ Auto Scaling Group scales consumer EC2 instances or Lambda concurrency based on \u003ccode\u003eApproximateNumberOfMessagesVisible\u003c/code\u003e. This is mature and well-understood.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge:\u003c/strong\u003e Targets scale automatically (Lambda, Fargate). You don't manage consumers. This is the point â€” EventBridge handles fan-out and routing so you don't have to.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKafka:\u003c/strong\u003e Consumer scaling is partition-bound. You cannot have more active consumers in a consumer group than partitions in a topic. Plan partition count at topic creation: \u003ccode\u003epartitions = max_expected_consumers Ã— headroom_factor\u003c/code\u003e. Kafka's \u003ccode\u003ekafka.admin.client\u003c/code\u003e lets you expand partition count after creation, but redistributing partitions causes a brief rebalance. Pre-partition aggressively.\u003c/p\u003e\n\u003ch2\u003eOperational Overhead\u003c/h2\u003e\n\u003cp\u003eThis is where honest conversations get uncomfortable.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eTask\u003c/th\u003e\n\u003cth\u003eSQS\u003c/th\u003e\n\u003cth\u003eEventBridge\u003c/th\u003e\n\u003cth\u003eMSK\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eCluster provisioning\u003c/td\u003e\n\u003ctd\u003eNone\u003c/td\u003e\n\u003ctd\u003eNone\u003c/td\u003e\n\u003ctd\u003eBroker sizing, AZ config\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSchema management\u003c/td\u003e\n\u003ctd\u003eNone\u003c/td\u003e\n\u003ctd\u003eJSON schema registry (optional)\u003c/td\u003e\n\u003ctd\u003eConfluent Schema Registry or Glue\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMonitoring\u003c/td\u003e\n\u003ctd\u003eBasic CloudWatch\u003c/td\u003e\n\u003ctd\u003eBasic CloudWatch\u003c/td\u003e\n\u003ctd\u003eCustom dashboards, consumer lag\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSecurity\u003c/td\u003e\n\u003ctd\u003eIAM, VPC\u003c/td\u003e\n\u003ctd\u003eIAM, resource policies\u003c/td\u003e\n\u003ctd\u003emTLS, SASL, ACLs\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eUpgrade management\u003c/td\u003e\n\u003ctd\u003eAutomatic\u003c/td\u003e\n\u003ctd\u003eAutomatic\u003c/td\u003e\n\u003ctd\u003eMSK broker version upgrades\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eConsumer lag tracking\u003c/td\u003e\n\u003ctd\u003eQueue depth metrics\u003c/td\u003e\n\u003ctd\u003eNone\u003c/td\u003e\n\u003ctd\u003eKafka consumer group offsets\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eMSK is the Kafka product of choice on AWS, but \"managed\" is relative. You still provision brokers, choose instance types, manage broker storage, configure retention, set up Schema Registry, build consumer lag dashboards, and handle rebalance storms.\u003c/p\u003e\n\u003cp\u003eMSK Serverless offloads most of this at a cost premium. For teams without dedicated platform engineering, MSK Serverless or Confluent Cloud are worth the price.\u003c/p\u003e\n\u003ch2\u003eLatency Characteristics\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eSQS\u003c/strong\u003e short-polling returns immediately (empty or not). Long-polling waits up to 20 seconds, which reduces empty receives and cost. End-to-end latency (produce â†’ consume) is typically 50â€“200ms under normal load, with occasional spikes to seconds under high retry load.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEventBridge\u003c/strong\u003e typically delivers in under 500ms. For Lambda targets, add cold start time. Not appropriate for sub-100ms requirements.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKafka\u003c/strong\u003e end-to-end latency depends on producer acknowledgment settings:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eacks=0\u003c/code\u003e: fire and forget, ~5ms produce latency, data loss risk\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eacks=1\u003c/code\u003e: leader acknowledges, ~10â€“20ms\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eacks=all\u003c/code\u003e: all ISR replicas acknowledge, 20â€“50ms typically\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConsumer-side, with \u003ccode\u003efetch.min.bytes=1\u003c/code\u003e and \u003ccode\u003efetch.max.wait.ms=500\u003c/code\u003e defaults, a new message is consumed within 1â€“500ms after it's committed. For low-latency streaming (\u0026#x3C; 100ms end-to-end), tune \u003ccode\u003efetch.max.wait.ms=0\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eWhen Kafka is Overkill\u003c/h2\u003e\n\u003cp\u003eUse SQS when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need a simple task queue with retry and DLQ\u003c/li\u003e\n\u003cli\u003eThroughput is under 10K messages/second\u003c/li\u003e\n\u003cli\u003eYou don't need message replay\u003c/li\u003e\n\u003cli\u003eYour team has no Kafka operational experience\u003c/li\u003e\n\u003cli\u003eYou're a startup without a platform team\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKafka's power comes from replayability, strict ordering, and high throughput. If your use case doesn't need these properties, you're paying operational overhead for nothing.\u003c/p\u003e\n\u003ch2\u003eWhen SQS Fails at Scale\u003c/h2\u003e\n\u003cp\u003eSQS FIFO breaks at ordering + throughput intersection. At 300 msg/s per queue (3,000 with batching), you hit the hard limit. The workaround is sharding: deploy 10 FIFO queues, partition by entity ID, route producers accordingly. This works, but you've now built a partition routing layer â€” which is exactly what Kafka does natively.\u003c/p\u003e\n\u003cp\u003eSQS Standard's lack of replay means you cannot re-process a stream of events. If your downstream system has a bug that corrupts two hours of data, you cannot replay from two hours ago. You need a separate audit log â€” at which point, you should have just used Kafka.\u003c/p\u003e\n\u003ch2\u003eReal Production Case Study\u003c/h2\u003e\n\u003cp\u003eAt a fintech company processing 5 million payment events per day, the team started with SQS FIFO for per-customer ordered processing. After 18 months:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFIFO throughput limit triggered scaling issues during month-end batch processing\u003c/li\u003e\n\u003cli\u003eZero replay capability meant a buggy consumer silently dropped 30,000 events before detection â€” requiring a full re-run from an S3 audit backup\u003c/li\u003e\n\u003cli\u003eAdding a new downstream consumer required modifying the producer to enqueue to a second queue\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMigration to MSK:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTopic: \u003ccode\u003epayment-events\u003c/code\u003e with 48 partitions (keyed by \u003ccode\u003ecustomerId\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eConsumer groups per downstream system â€” each independently maintains its offset\u003c/li\u003e\n\u003cli\u003e7-day retention enabled replay of any incident window\u003c/li\u003e\n\u003cli\u003eMirrorMaker2 replicates to a DR region\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOperational cost increased by $800/month. Engineering productivity increased significantly â€” onboarding new consumers went from code changes to a new consumer group.\u003c/p\u003e\n\u003ch2\u003eDecision Framework\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eSTART\nâ”‚\nâ”œâ”€â”€ Do you need message replay?\nâ”‚   â””â”€â”€ YES â†’ Kafka (MSK)\nâ”‚\nâ”œâ”€â”€ Do you need cross-service event routing with content-based rules?\nâ”‚   â””â”€â”€ YES â†’ EventBridge\nâ”‚\nâ”œâ”€â”€ Do you need strict ordering + throughput \u003e 3000 msg/s?\nâ”‚   â””â”€â”€ YES â†’ Kafka (MSK)\nâ”‚\nâ”œâ”€â”€ Do you have a platform team to operate Kafka?\nâ”‚   â””â”€â”€ NO + need Kafka features â†’ MSK Serverless or Confluent Cloud\nâ”‚\nâ””â”€â”€ Simple task queue, retry + DLQ, \u0026#x3C; 3000 ordered msg/s?\n    â””â”€â”€ YES â†’ SQS (FIFO if ordering matters, Standard otherwise)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe default should be SQS. Introduce Kafka when you hit the specific limitations that Kafka solves. EventBridge shines in event-driven microservice architectures where routing logic is the primary challenge.\u003c/p\u003e\n","tableOfContents":[{"id":"the-three-systems-in-one-paragraph-each","text":"The Three Systems in One Paragraph Each","level":2},{"id":"throughput-comparison","text":"Throughput Comparison","level":2},{"id":"ordering-guarantees","text":"Ordering Guarantees","level":2},{"id":"cost-breakdown-at-scale","text":"Cost Breakdown at Scale","level":2},{"id":"multi-region-support","text":"Multi-Region Support","level":2},{"id":"retry-behavior-and-dead-letter-queues","text":"Retry Behavior and Dead Letter Queues","level":2},{"id":"scaling-strategy","text":"Scaling Strategy","level":2},{"id":"operational-overhead","text":"Operational Overhead","level":2},{"id":"latency-characteristics","text":"Latency Characteristics","level":2},{"id":"when-kafka-is-overkill","text":"When Kafka is Overkill","level":2},{"id":"when-sqs-fails-at-scale","text":"When SQS Fails at Scale","level":2},{"id":"real-production-case-study","text":"Real Production Case Study","level":2},{"id":"decision-framework","text":"Decision Framework","level":2}]},"relatedPosts":[{"title":"Kafka Exactly-Once Semantics: Myth vs Production Reality","description":"What Kafka's exactly-once guarantee actually covers, where duplicates still happen in practice, and how to design genuinely idempotent consumers with Spring Kafka. Real production mistakes and their fixes.","date":"2025-04-20","category":"Messaging","tags":["kafka","exactly-once","spring kafka","distributed systems","transactions","java"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"kafka-exactly-once-semantics","readingTime":"9 min read","excerpt":"Kafka 0.11 introduced exactly-once semantics (EOS), and every architecture diagram since then has confidently placed a checkbox next to \"exactly once delivery.\" In practice, most teams deploying Kafka with EOS still see â€¦"},{"title":"Kafka Internals Deep Dive: Partitions, Offsets, and Consumer Groups","description":"Understand how Apache Kafka achieves high throughput through log-based storage, how offsets enable reliable consumption, and how consumer groups scale processing horizontally.","date":"2025-01-15","category":"Messaging","tags":["kafka","distributed systems","streaming","java"],"featured":true,"affiliateSection":"distributed-systems-books","slug":"kafka-internals-deep-dive","readingTime":"10 min read","excerpt":"Apache Kafka is the de facto standard for event streaming in distributed systems, but most developers treat it as a black box â€” a durable message queue with a fancy name. Understanding Kafka's internals unlocks its true â€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"sqs-kafka-eventbridge-aws-comparison"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>