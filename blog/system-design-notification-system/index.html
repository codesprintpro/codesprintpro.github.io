<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">System Design: Building a Notification System for 100 Million Users<!-- --> | CodeSprintPro</title><meta name="description" content="Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/system-design-notification-system/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="System Design: Building a Notification System for 100 Million Users" data-next-head=""/><meta property="og:description" content="Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/system-design-notification-system/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-02-18" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="System Design" data-next-head=""/><meta property="article:tag" content="system design" data-next-head=""/><meta property="article:tag" content="notifications" data-next-head=""/><meta property="article:tag" content="kafka" data-next-head=""/><meta property="article:tag" content="push notifications" data-next-head=""/><meta property="article:tag" content="distributed systems" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="System Design: Building a Notification System for 100 Million Users" data-next-head=""/><meta name="twitter:description" content="Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"System Design: Building a Notification System for 100 Million Users","description":"Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-02-18","dateModified":"2025-02-18","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/system-design-notification-system/"},"keywords":"system design, notifications, kafka, push notifications, distributed systems","articleSection":"System Design"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">System Design: Building a Notification System for 100 Million Users</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">System Design</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">System Design: Building a Notification System for 100 Million Users</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>February 18, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>11 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->system design</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->notifications</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->kafka</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->push notifications</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->distributed systems</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Notification systems are deceptively complex. Sending one notification is trivial. Sending 100 million notifications daily â€” with channel routing, user preferences, delivery tracking, retry logic, and rate limiting â€” requires careful architectural thinking.</p>
<p>This article designs a notification system like the ones at LinkedIn, Twitter, or Uber.</p>
<h2>Requirements</h2>
<p><strong>Functional:</strong></p>
<ul>
<li>Send notifications via: push (iOS/Android), email, SMS, in-app</li>
<li>User preferences per channel and notification type (opt-in/opt-out)</li>
<li>Templated notifications with variable substitution</li>
<li>Scheduled notifications (send at specific time)</li>
<li>Delivery tracking (sent, delivered, read)</li>
<li>Rate limiting per user (max N notifications per hour)</li>
</ul>
<p><strong>Non-Functional:</strong></p>
<ul>
<li>100M users, 50M daily active</li>
<li>1B notifications/day = ~11,600 sends/sec</li>
<li>Priority tiers: critical (OTP, alerts) &#x3C; 100ms delivery, standard &#x3C; 5 minutes</li>
<li>At-least-once delivery guarantee</li>
<li>Idempotent (no duplicates on retry)</li>
</ul>
<h2>Back-of-Envelope</h2>
<p>Before designing the system, it is worth establishing the numbers that drive your architectural decisions. The peak volume of 115,000 notifications per second â€” ten times the average, during events like flash sales or breaking news â€” is the figure that determines how many Kafka partitions and worker instances you need.</p>
<pre><code>Notification volume:
  1B/day Ã· 86,400s = 11,574 notifications/sec average
  Peak (10x): ~115,000/sec (e.g., breaking news, flash sale)

Storage:
  Per notification log: ~500 bytes
  1B/day Ã— 365 days Ã— 3 years Ã— 500 bytes = ~548 TB total
  Use tiered storage: hot (recent 30 days) in Cassandra, archive in S3

User preferences:
  100M users Ã— 1 KB preference data = 100 GB â†’ fits in Redis + DB

Templates:
  ~1,000 notification templates, cached in memory
</code></pre>
<p>Notice that user preference data â€” at 100 GB â€” is small enough to fit entirely in Redis. This means every preference lookup can be served from memory without ever touching the database, which is critical when you are processing 11,000 notifications per second.</p>
<h2>System Architecture</h2>
<p>The architecture separates the system into three logical zones: ingestion (the API that receives requests), routing (Kafka topics that buffer and prioritize), and delivery (channel workers that call third-party providers). This separation means a slow email provider cannot block push notifications, and a surge in marketing messages cannot delay OTP codes.</p>
<pre><code>Producers (API servers, event processors)
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Notification Service API            â”‚
â”‚  POST /api/v1/notify (single or batch)      â”‚
â”‚  POST /api/v1/notify/schedule               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Validation &#x26; Enrichment â”‚
    â”‚  - User preference check â”‚
    â”‚  - Template resolution   â”‚
    â”‚  - Rate limit check      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚     Priority Kafka Topics                â”‚
    â”‚  notifications.critical  (P0 - OTP)      â”‚
    â”‚  notifications.high      (P1 - alerts)   â”‚
    â”‚  notifications.standard  (P2 - marketing)â”‚
    â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚          â”‚              â”‚
  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Push  â”‚  â”‚ Email â”‚     â”‚  SMS        â”‚
  â”‚Worker â”‚  â”‚Worker â”‚     â”‚  Worker     â”‚
  â””â”€â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚          â”‚              â”‚
  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ FCM/  â”‚  â”‚SendGridâ”‚    â”‚  Twilio     â”‚
  â”‚ APNs  â”‚  â”‚ SES   â”‚     â”‚  SNS        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Delivery Tracker       â”‚
    â”‚   Cassandra (logs)       â”‚
    â”‚   Redis (real-time state)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Using separate Kafka topics for each priority level is what guarantees low latency for critical notifications. Kafka consumers for <code>notifications.critical</code> can be scaled independently and given more CPU resources than the marketing topic, so a backlog of promotional emails never delays an OTP message.</p>
<h2>Core Service: Notification API</h2>
<p>The API itself is intentionally thin â€” it validates the request, checks preferences, resolves the template, and publishes to Kafka. All actual sending happens asynchronously downstream. This design means your API can respond to the caller in milliseconds regardless of how long it takes to deliver the notification, and it decouples the caller from any third-party provider failures.</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/v1/notify")
public class NotificationController {

    @Autowired
    private NotificationOrchestrator orchestrator;

    @PostMapping
    public ResponseEntity&#x3C;NotificationResponse> sendNotification(
            @RequestBody @Valid NotificationRequest request) {

        // Enqueue â€” return immediately, process async
        String notificationId = orchestrator.enqueue(request);

        return ResponseEntity.accepted()
            .body(new NotificationResponse(notificationId, "QUEUED"));
    }

    @PostMapping("/batch")
    public ResponseEntity&#x3C;BatchNotificationResponse> sendBatch(
            @RequestBody @Valid BatchNotificationRequest request) {
        // Max 1000 per batch
        if (request.getRecipients().size() > 1000) {
            return ResponseEntity.badRequest().build();
        }
        List&#x3C;String> ids = orchestrator.enqueueBatch(request);
        return ResponseEntity.accepted().body(new BatchNotificationResponse(ids));
    }
}

@Service
public class NotificationOrchestrator {

    @Autowired
    private UserPreferenceService preferenceService;

    @Autowired
    private TemplateService templateService;

    @Autowired
    private RateLimiter rateLimiter;

    @Autowired
    private KafkaTemplate&#x3C;String, NotificationEvent> kafka;

    public String enqueue(NotificationRequest request) {
        String notificationId = UUID.randomUUID().toString();

        for (String userId : request.getRecipientIds()) {
            // 1. Check user preferences
            UserPreferences prefs = preferenceService.get(userId);
            List&#x3C;Channel> enabledChannels = prefs.getEnabledChannels(request.getType());

            if (enabledChannels.isEmpty()) continue; // User opted out

            // 2. Rate limit check
            if (!rateLimiter.isAllowed(userId, request.getPriority())) {
                log.info("Rate limited notification to user {}", userId);
                continue;
            }

            // 3. Resolve template
            String content = templateService.render(request.getTemplateId(), request.getVariables());

            // 4. Publish to priority-appropriate topic
            String topic = "notifications." + request.getPriority().name().toLowerCase();
            NotificationEvent event = NotificationEvent.builder()
                .id(notificationId)
                .userId(userId)
                .channels(enabledChannels)
                .content(content)
                .subject(request.getSubject())
                .createdAt(Instant.now())
                .build();

            kafka.send(topic, userId, event); // Key = userId â†’ consistent partition
        }

        return notificationId;
    }
}
</code></pre>
<p>The Kafka partition key <code>userId</code> is a subtle but important detail: it ensures that all notifications for the same user land on the same partition, which preserves ordering. A user will always see their notifications arrive in the order they were sent, rather than in the order workers happened to process them.</p>
<h2>Fan-Out Strategy: Push vs Pull</h2>
<p>With the API and routing in place, the next challenge is how to expand a single event (like a breaking news alert) into millions of per-user notifications efficiently. This is called fan-out, and the right strategy depends on how many recipients an event has.</p>
<p>For large events (breaking news sent to 50M users), push-to-all is too slow. Use <strong>fan-out on write</strong> for small follower counts, <strong>fan-out on read</strong> for celebrities/broadcasts.</p>
<pre><code>Fan-out on write (for most notifications):
  Event occurs â†’ expand recipient list immediately â†’ queue per-user notifications
  Pro: Fast delivery, simple consumers
  Con: Hot users/events cause write amplification (celebrity with 10M followers)

Fan-out on read (for broadcast/marketing):
  Store one notification record â†’ users fetch on next app open
  Pro: No write amplification
  Con: Delivery delay, users must poll

Hybrid (recommended for large scale):
  - Personal notifications (friend request, order update): fan-out on write
  - Marketing/broadcast: fan-out on read with batch job
  - System alerts: fan-out on write with priority queue
</code></pre>
<p>Think of the hybrid approach like postal mail versus a newspaper: personal letters are addressed and delivered to each recipient individually (fan-out on write), while newspapers are printed once and picked up at the newsstand by whoever wants one (fan-out on read). The right model depends entirely on the nature of the message.</p>
<h2>Channel Workers</h2>
<p>Channel workers are the component that bridges your internal system to third-party providers. Each worker subscribes to all priority topics, handles the platform-specific API calls, and manages failure modes like expired tokens. The most important design principle here is that channel workers must be idempotent â€” if a worker crashes after successfully sending but before acknowledging the Kafka message, the message will be reprocessed. Tracking the provider's <code>messageId</code> in the delivery tracker is what prevents the user from receiving a duplicate notification.</p>
<pre><code class="language-java">@Component
public class PushNotificationWorker {

    @Autowired
    private FcmService fcm;

    @Autowired
    private ApnsService apns;

    @Autowired
    private DeviceTokenRepository deviceTokens;

    @Autowired
    private DeliveryTracker tracker;

    @KafkaListener(topics = {"notifications.critical", "notifications.high", "notifications.standard"},
                   groupId = "push-worker",
                   containerFactory = "priorityKafkaListenerFactory")
    public void process(NotificationEvent event) {
        List&#x3C;DeviceToken> tokens = deviceTokens.findByUserId(event.getUserId());

        for (DeviceToken token : tokens) {
            try {
                String messageId = switch (token.getPlatform()) {
                    case ANDROID -> fcm.send(token.getToken(), event.getContent(), event.getTitle());
                    case IOS -> apns.send(token.getToken(), event.getContent(), event.getTitle());
                };

                tracker.markDelivered(event.getId(), token.getDeviceId(), messageId);

            } catch (TokenExpiredException e) {
                deviceTokens.deactivate(token.getId());
            } catch (RateLimitException e) {
                // Requeue with delay
                throw new RetryableException("FCM rate limited", e);
            }
        }
    }
}
</code></pre>
<p>Deactivating expired tokens immediately on <code>TokenExpiredException</code> is both a correctness fix and a performance optimization: it prevents future notifications from attempting delivery to a device that has been wiped or uninstalled the app, saving FCM/APNs quota.</p>
<h2>Delivery Tracking with Cassandra</h2>
<p>Now that notifications are being sent, you need to track their state. Cassandra is ideal for notification logs: write-heavy, time-series, high cardinality. The choice of Cassandra over PostgreSQL here comes down to the write pattern: at 11,000 notifications per second, every send triggers a status update. PostgreSQL's row-level locking and B-tree indexes do not scale to this write rate without expensive sharding, while Cassandra was designed from the ground up for exactly this kind of append-heavy, partition-key-based access.</p>
<pre><code class="language-sql">-- Cassandra schema
CREATE TABLE notification_events (
    notification_id  UUID,
    user_id          TEXT,
    channel          TEXT,    -- push, email, sms, in_app
    status           TEXT,    -- queued, sent, delivered, read, failed
    created_at       TIMESTAMP,
    updated_at       TIMESTAMP,
    error_message    TEXT,
    PRIMARY KEY ((user_id), created_at, notification_id)
) WITH CLUSTERING ORDER BY (created_at DESC)
  AND default_time_to_live = 7776000;  -- 90 days TTL

-- Query: Get user's recent notifications
SELECT * FROM notification_events
WHERE user_id = 'user123'
  AND created_at > '2025-01-01'
LIMIT 50;
</code></pre>
<p>The <code>CLUSTERING ORDER BY (created_at DESC)</code> means the most recent notifications are physically stored first on disk, so the common "show me recent activity" query reads the minimum amount of data without any sorting step.</p>
<h2>User Preference Management</h2>
<p>User preferences are the gateway that determines whether a notification is ever sent at all. The Redis-first approach here is critical: checking preferences is on the hot path for every notification, and a database call for each of 11,000 notifications per second would saturate your PostgreSQL cluster immediately.</p>
<pre><code class="language-java">// Preferences stored in Redis (hot path) + PostgreSQL (source of truth)
@Service
public class UserPreferenceService {

    @Autowired
    private StringRedisTemplate redis;

    @Autowired
    private PreferenceRepository repo;

    public UserPreferences get(String userId) {
        String cacheKey = "prefs:" + userId;
        String cached = redis.opsForValue().get(cacheKey);

        if (cached != null) {
            return objectMapper.readValue(cached, UserPreferences.class);
        }

        UserPreferences prefs = repo.findByUserId(userId)
            .orElse(UserPreferences.defaults());

        redis.opsForValue().set(cacheKey, objectMapper.writeValueAsString(prefs), Duration.ofHours(1));
        return prefs;
    }

    public void update(String userId, UpdatePreferenceRequest request) {
        repo.upsert(userId, request);
        redis.delete("prefs:" + userId); // Invalidate cache
    }
}
</code></pre>
<p>Notice that the <code>update</code> method invalidates the Redis key rather than writing the new value directly. This cache-aside pattern avoids a race condition where two simultaneous updates could leave stale data in Redis â€” by deleting the key, the next read is guaranteed to fetch the freshest value from the database.</p>
<h2>Handling Third-Party Rate Limits</h2>
<p>FCM, APNs, SendGrid, and Twilio all have rate limits. Handle them gracefully. Without this throttle, a burst of outgoing notifications could exhaust your provider's quota within seconds, causing your entire notification system to fail for the rest of the billing period. Think of it like a water tap with a flow restrictor: you control the output rate to stay within the pipe's capacity, even when the demand upstream is higher.</p>
<pre><code class="language-java">@Component
public class AdaptiveRateLimiter {

    private final Map&#x3C;String, TokenBucket> providerBuckets = Map.of(
        "FCM",      new TokenBucket(600_000, 600_000), // 600K/min
        "APNs",     new TokenBucket(300_000, 300_000),
        "SendGrid", new TokenBucket(100,  100),         // 100/sec
        "Twilio",   new TokenBucket(1,    1)            // 1/sec (varies by plan)
    );

    public void throttle(String provider) {
        TokenBucket bucket = providerBuckets.get(provider);
        if (!bucket.tryConsume()) {
            long waitMs = bucket.getMillisToNextToken();
            try { Thread.sleep(waitMs); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        }
    }
}
</code></pre>
<h2>Scheduled Notifications</h2>
<p>The final capability to add is scheduling, where a notification should be delivered at a specific future time rather than immediately. Redis sorted sets are the perfect data structure for this: the score is the delivery timestamp in milliseconds, so a range query from 0 to "now" always returns exactly the notifications that are due, in order.</p>
<pre><code class="language-java">// Store scheduled notifications in a sorted set (score = delivery timestamp)
public void schedule(NotificationRequest request, Instant deliveryTime) {
    String key = "scheduled:notifications";
    String payload = objectMapper.writeValueAsString(request);
    redis.opsForZSet().add(key, payload, deliveryTime.toEpochMilli());
}

// Scheduler: poll every second, process due notifications
@Scheduled(fixedDelay = 1000)
public void processScheduled() {
    long now = Instant.now().toEpochMilli();
    Set&#x3C;String> due = redis.opsForZSet().rangeByScore("scheduled:notifications", 0, now);

    for (String payload : due) {
        NotificationRequest request = objectMapper.readValue(payload, NotificationRequest.class);
        enqueue(request);
        redis.opsForZSet().remove("scheduled:notifications", payload);
    }
}
</code></pre>
<p>The one-second polling interval gives you a delivery accuracy of Â±1 second, which is sufficient for virtually all scheduling use cases. If you needed sub-second precision, you would replace the scheduler with a dedicated delay queue backed by a time-wheel data structure.</p>
<p>The notification system's core challenge is not the happy path â€” it's the edge cases: user preferences changing mid-delivery, third-party provider outages, duplicate suppression on retry, and fan-out storms during viral events. Design each component to handle failure gracefully, and your notification system will be invisible to users (which is exactly what you want).</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">System Design Interview â€” Alex Xu</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Step-by-step guide to ace system design interviews with real-world examples.</p></div><a href="https://amzn.to/3TqsPRp" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Grokking System Design on Educative</span></div><p class="text-xs text-gray-600">Interactive course teaching system design with visual diagrams and practice problems.</p></div><a href="https://www.educative.io/courses/grokking-the-system-design-interview" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span></div><p class="text-xs text-gray-600">Martin Kleppmann&#x27;s book is essential reading for any system design role.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=System%20Design%3A%20Building%20a%20Notification%20System%20for%20100%20Million%20Users&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsystem-design-notification-system%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsystem-design-notification-system%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#requirements" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Requirements</a></li><li class=""><a href="#back-of-envelope" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Back-of-Envelope</a></li><li class=""><a href="#system-architecture" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">System Architecture</a></li><li class=""><a href="#core-service-notification-api" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Core Service: Notification API</a></li><li class=""><a href="#fan-out-strategy-push-vs-pull" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Fan-Out Strategy: Push vs Pull</a></li><li class=""><a href="#channel-workers" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Channel Workers</a></li><li class=""><a href="#delivery-tracking-with-cassandra" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Delivery Tracking with Cassandra</a></li><li class=""><a href="#user-preference-management" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">User Preference Management</a></li><li class=""><a href="#handling-third-party-rate-limits" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Handling Third-Party Rate Limits</a></li><li class=""><a href="#scheduled-notifications" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Scheduled Notifications</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/observability-opentelemetry-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Building Production Observability with OpenTelemetry and Grafana Stack</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>6 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->observability</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->opentelemetry</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->prometheus</span></div></article></a><a href="/blog/event-sourcing-cqrs-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Event Sourcing and CQRS in Production: Beyond the Theory</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 23, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->event sourcing</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cqrs</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->system design</span></div></article></a><a href="/blog/grpc-vs-rest-vs-graphql/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">gRPC vs REST vs GraphQL: Choosing the Right API Protocol</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->grpc</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->rest</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->graphql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"System Design: Building a Notification System for 100 Million Users","description":"Design a scalable notification system that delivers push, email, SMS, and in-app notifications reliably. Covers fan-out strategies, priority queues, delivery guarantees, and user preference management.","date":"2025-02-18","category":"System Design","tags":["system design","notifications","kafka","push notifications","distributed systems"],"featured":false,"affiliateSection":"system-design-courses","slug":"system-design-notification-system","readingTime":"11 min read","excerpt":"Notification systems are deceptively complex. Sending one notification is trivial. Sending 100 million notifications daily â€” with channel routing, user preferences, delivery tracking, retry logic, and rate limiting â€” reqâ€¦","contentHtml":"\u003cp\u003eNotification systems are deceptively complex. Sending one notification is trivial. Sending 100 million notifications daily â€” with channel routing, user preferences, delivery tracking, retry logic, and rate limiting â€” requires careful architectural thinking.\u003c/p\u003e\n\u003cp\u003eThis article designs a notification system like the ones at LinkedIn, Twitter, or Uber.\u003c/p\u003e\n\u003ch2\u003eRequirements\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eFunctional:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSend notifications via: push (iOS/Android), email, SMS, in-app\u003c/li\u003e\n\u003cli\u003eUser preferences per channel and notification type (opt-in/opt-out)\u003c/li\u003e\n\u003cli\u003eTemplated notifications with variable substitution\u003c/li\u003e\n\u003cli\u003eScheduled notifications (send at specific time)\u003c/li\u003e\n\u003cli\u003eDelivery tracking (sent, delivered, read)\u003c/li\u003e\n\u003cli\u003eRate limiting per user (max N notifications per hour)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNon-Functional:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e100M users, 50M daily active\u003c/li\u003e\n\u003cli\u003e1B notifications/day = ~11,600 sends/sec\u003c/li\u003e\n\u003cli\u003ePriority tiers: critical (OTP, alerts) \u0026#x3C; 100ms delivery, standard \u0026#x3C; 5 minutes\u003c/li\u003e\n\u003cli\u003eAt-least-once delivery guarantee\u003c/li\u003e\n\u003cli\u003eIdempotent (no duplicates on retry)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eBack-of-Envelope\u003c/h2\u003e\n\u003cp\u003eBefore designing the system, it is worth establishing the numbers that drive your architectural decisions. The peak volume of 115,000 notifications per second â€” ten times the average, during events like flash sales or breaking news â€” is the figure that determines how many Kafka partitions and worker instances you need.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNotification volume:\n  1B/day Ã· 86,400s = 11,574 notifications/sec average\n  Peak (10x): ~115,000/sec (e.g., breaking news, flash sale)\n\nStorage:\n  Per notification log: ~500 bytes\n  1B/day Ã— 365 days Ã— 3 years Ã— 500 bytes = ~548 TB total\n  Use tiered storage: hot (recent 30 days) in Cassandra, archive in S3\n\nUser preferences:\n  100M users Ã— 1 KB preference data = 100 GB â†’ fits in Redis + DB\n\nTemplates:\n  ~1,000 notification templates, cached in memory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that user preference data â€” at 100 GB â€” is small enough to fit entirely in Redis. This means every preference lookup can be served from memory without ever touching the database, which is critical when you are processing 11,000 notifications per second.\u003c/p\u003e\n\u003ch2\u003eSystem Architecture\u003c/h2\u003e\n\u003cp\u003eThe architecture separates the system into three logical zones: ingestion (the API that receives requests), routing (Kafka topics that buffer and prioritize), and delivery (channel workers that call third-party providers). This separation means a slow email provider cannot block push notifications, and a surge in marketing messages cannot delay OTP codes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eProducers (API servers, event processors)\n    â”‚\n    â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         Notification Service API            â”‚\nâ”‚  POST /api/v1/notify (single or batch)      â”‚\nâ”‚  POST /api/v1/notify/schedule               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                 â”‚\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚  Validation \u0026#x26; Enrichment â”‚\n    â”‚  - User preference check â”‚\n    â”‚  - Template resolution   â”‚\n    â”‚  - Rate limit check      â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                 â”‚\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚     Priority Kafka Topics                â”‚\n    â”‚  notifications.critical  (P0 - OTP)      â”‚\n    â”‚  notifications.high      (P1 - alerts)   â”‚\n    â”‚  notifications.standard  (P2 - marketing)â”‚\n    â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â”‚          â”‚              â”‚\n  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ Push  â”‚  â”‚ Email â”‚     â”‚  SMS        â”‚\n  â”‚Worker â”‚  â”‚Worker â”‚     â”‚  Worker     â”‚\n  â””â”€â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â”‚          â”‚              â”‚\n  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ FCM/  â”‚  â”‚SendGridâ”‚    â”‚  Twilio     â”‚\n  â”‚ APNs  â”‚  â”‚ SES   â”‚     â”‚  SNS        â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                 â”‚\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚   Delivery Tracker       â”‚\n    â”‚   Cassandra (logs)       â”‚\n    â”‚   Redis (real-time state)â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing separate Kafka topics for each priority level is what guarantees low latency for critical notifications. Kafka consumers for \u003ccode\u003enotifications.critical\u003c/code\u003e can be scaled independently and given more CPU resources than the marketing topic, so a backlog of promotional emails never delays an OTP message.\u003c/p\u003e\n\u003ch2\u003eCore Service: Notification API\u003c/h2\u003e\n\u003cp\u003eThe API itself is intentionally thin â€” it validates the request, checks preferences, resolves the template, and publishes to Kafka. All actual sending happens asynchronously downstream. This design means your API can respond to the caller in milliseconds regardless of how long it takes to deliver the notification, and it decouples the caller from any third-party provider failures.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RestController\n@RequestMapping(\"/api/v1/notify\")\npublic class NotificationController {\n\n    @Autowired\n    private NotificationOrchestrator orchestrator;\n\n    @PostMapping\n    public ResponseEntity\u0026#x3C;NotificationResponse\u003e sendNotification(\n            @RequestBody @Valid NotificationRequest request) {\n\n        // Enqueue â€” return immediately, process async\n        String notificationId = orchestrator.enqueue(request);\n\n        return ResponseEntity.accepted()\n            .body(new NotificationResponse(notificationId, \"QUEUED\"));\n    }\n\n    @PostMapping(\"/batch\")\n    public ResponseEntity\u0026#x3C;BatchNotificationResponse\u003e sendBatch(\n            @RequestBody @Valid BatchNotificationRequest request) {\n        // Max 1000 per batch\n        if (request.getRecipients().size() \u003e 1000) {\n            return ResponseEntity.badRequest().build();\n        }\n        List\u0026#x3C;String\u003e ids = orchestrator.enqueueBatch(request);\n        return ResponseEntity.accepted().body(new BatchNotificationResponse(ids));\n    }\n}\n\n@Service\npublic class NotificationOrchestrator {\n\n    @Autowired\n    private UserPreferenceService preferenceService;\n\n    @Autowired\n    private TemplateService templateService;\n\n    @Autowired\n    private RateLimiter rateLimiter;\n\n    @Autowired\n    private KafkaTemplate\u0026#x3C;String, NotificationEvent\u003e kafka;\n\n    public String enqueue(NotificationRequest request) {\n        String notificationId = UUID.randomUUID().toString();\n\n        for (String userId : request.getRecipientIds()) {\n            // 1. Check user preferences\n            UserPreferences prefs = preferenceService.get(userId);\n            List\u0026#x3C;Channel\u003e enabledChannels = prefs.getEnabledChannels(request.getType());\n\n            if (enabledChannels.isEmpty()) continue; // User opted out\n\n            // 2. Rate limit check\n            if (!rateLimiter.isAllowed(userId, request.getPriority())) {\n                log.info(\"Rate limited notification to user {}\", userId);\n                continue;\n            }\n\n            // 3. Resolve template\n            String content = templateService.render(request.getTemplateId(), request.getVariables());\n\n            // 4. Publish to priority-appropriate topic\n            String topic = \"notifications.\" + request.getPriority().name().toLowerCase();\n            NotificationEvent event = NotificationEvent.builder()\n                .id(notificationId)\n                .userId(userId)\n                .channels(enabledChannels)\n                .content(content)\n                .subject(request.getSubject())\n                .createdAt(Instant.now())\n                .build();\n\n            kafka.send(topic, userId, event); // Key = userId â†’ consistent partition\n        }\n\n        return notificationId;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Kafka partition key \u003ccode\u003euserId\u003c/code\u003e is a subtle but important detail: it ensures that all notifications for the same user land on the same partition, which preserves ordering. A user will always see their notifications arrive in the order they were sent, rather than in the order workers happened to process them.\u003c/p\u003e\n\u003ch2\u003eFan-Out Strategy: Push vs Pull\u003c/h2\u003e\n\u003cp\u003eWith the API and routing in place, the next challenge is how to expand a single event (like a breaking news alert) into millions of per-user notifications efficiently. This is called fan-out, and the right strategy depends on how many recipients an event has.\u003c/p\u003e\n\u003cp\u003eFor large events (breaking news sent to 50M users), push-to-all is too slow. Use \u003cstrong\u003efan-out on write\u003c/strong\u003e for small follower counts, \u003cstrong\u003efan-out on read\u003c/strong\u003e for celebrities/broadcasts.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFan-out on write (for most notifications):\n  Event occurs â†’ expand recipient list immediately â†’ queue per-user notifications\n  Pro: Fast delivery, simple consumers\n  Con: Hot users/events cause write amplification (celebrity with 10M followers)\n\nFan-out on read (for broadcast/marketing):\n  Store one notification record â†’ users fetch on next app open\n  Pro: No write amplification\n  Con: Delivery delay, users must poll\n\nHybrid (recommended for large scale):\n  - Personal notifications (friend request, order update): fan-out on write\n  - Marketing/broadcast: fan-out on read with batch job\n  - System alerts: fan-out on write with priority queue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThink of the hybrid approach like postal mail versus a newspaper: personal letters are addressed and delivered to each recipient individually (fan-out on write), while newspapers are printed once and picked up at the newsstand by whoever wants one (fan-out on read). The right model depends entirely on the nature of the message.\u003c/p\u003e\n\u003ch2\u003eChannel Workers\u003c/h2\u003e\n\u003cp\u003eChannel workers are the component that bridges your internal system to third-party providers. Each worker subscribes to all priority topics, handles the platform-specific API calls, and manages failure modes like expired tokens. The most important design principle here is that channel workers must be idempotent â€” if a worker crashes after successfully sending but before acknowledging the Kafka message, the message will be reprocessed. Tracking the provider's \u003ccode\u003emessageId\u003c/code\u003e in the delivery tracker is what prevents the user from receiving a duplicate notification.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class PushNotificationWorker {\n\n    @Autowired\n    private FcmService fcm;\n\n    @Autowired\n    private ApnsService apns;\n\n    @Autowired\n    private DeviceTokenRepository deviceTokens;\n\n    @Autowired\n    private DeliveryTracker tracker;\n\n    @KafkaListener(topics = {\"notifications.critical\", \"notifications.high\", \"notifications.standard\"},\n                   groupId = \"push-worker\",\n                   containerFactory = \"priorityKafkaListenerFactory\")\n    public void process(NotificationEvent event) {\n        List\u0026#x3C;DeviceToken\u003e tokens = deviceTokens.findByUserId(event.getUserId());\n\n        for (DeviceToken token : tokens) {\n            try {\n                String messageId = switch (token.getPlatform()) {\n                    case ANDROID -\u003e fcm.send(token.getToken(), event.getContent(), event.getTitle());\n                    case IOS -\u003e apns.send(token.getToken(), event.getContent(), event.getTitle());\n                };\n\n                tracker.markDelivered(event.getId(), token.getDeviceId(), messageId);\n\n            } catch (TokenExpiredException e) {\n                deviceTokens.deactivate(token.getId());\n            } catch (RateLimitException e) {\n                // Requeue with delay\n                throw new RetryableException(\"FCM rate limited\", e);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDeactivating expired tokens immediately on \u003ccode\u003eTokenExpiredException\u003c/code\u003e is both a correctness fix and a performance optimization: it prevents future notifications from attempting delivery to a device that has been wiped or uninstalled the app, saving FCM/APNs quota.\u003c/p\u003e\n\u003ch2\u003eDelivery Tracking with Cassandra\u003c/h2\u003e\n\u003cp\u003eNow that notifications are being sent, you need to track their state. Cassandra is ideal for notification logs: write-heavy, time-series, high cardinality. The choice of Cassandra over PostgreSQL here comes down to the write pattern: at 11,000 notifications per second, every send triggers a status update. PostgreSQL's row-level locking and B-tree indexes do not scale to this write rate without expensive sharding, while Cassandra was designed from the ground up for exactly this kind of append-heavy, partition-key-based access.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Cassandra schema\nCREATE TABLE notification_events (\n    notification_id  UUID,\n    user_id          TEXT,\n    channel          TEXT,    -- push, email, sms, in_app\n    status           TEXT,    -- queued, sent, delivered, read, failed\n    created_at       TIMESTAMP,\n    updated_at       TIMESTAMP,\n    error_message    TEXT,\n    PRIMARY KEY ((user_id), created_at, notification_id)\n) WITH CLUSTERING ORDER BY (created_at DESC)\n  AND default_time_to_live = 7776000;  -- 90 days TTL\n\n-- Query: Get user's recent notifications\nSELECT * FROM notification_events\nWHERE user_id = 'user123'\n  AND created_at \u003e '2025-01-01'\nLIMIT 50;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eCLUSTERING ORDER BY (created_at DESC)\u003c/code\u003e means the most recent notifications are physically stored first on disk, so the common \"show me recent activity\" query reads the minimum amount of data without any sorting step.\u003c/p\u003e\n\u003ch2\u003eUser Preference Management\u003c/h2\u003e\n\u003cp\u003eUser preferences are the gateway that determines whether a notification is ever sent at all. The Redis-first approach here is critical: checking preferences is on the hot path for every notification, and a database call for each of 11,000 notifications per second would saturate your PostgreSQL cluster immediately.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Preferences stored in Redis (hot path) + PostgreSQL (source of truth)\n@Service\npublic class UserPreferenceService {\n\n    @Autowired\n    private StringRedisTemplate redis;\n\n    @Autowired\n    private PreferenceRepository repo;\n\n    public UserPreferences get(String userId) {\n        String cacheKey = \"prefs:\" + userId;\n        String cached = redis.opsForValue().get(cacheKey);\n\n        if (cached != null) {\n            return objectMapper.readValue(cached, UserPreferences.class);\n        }\n\n        UserPreferences prefs = repo.findByUserId(userId)\n            .orElse(UserPreferences.defaults());\n\n        redis.opsForValue().set(cacheKey, objectMapper.writeValueAsString(prefs), Duration.ofHours(1));\n        return prefs;\n    }\n\n    public void update(String userId, UpdatePreferenceRequest request) {\n        repo.upsert(userId, request);\n        redis.delete(\"prefs:\" + userId); // Invalidate cache\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the \u003ccode\u003eupdate\u003c/code\u003e method invalidates the Redis key rather than writing the new value directly. This cache-aside pattern avoids a race condition where two simultaneous updates could leave stale data in Redis â€” by deleting the key, the next read is guaranteed to fetch the freshest value from the database.\u003c/p\u003e\n\u003ch2\u003eHandling Third-Party Rate Limits\u003c/h2\u003e\n\u003cp\u003eFCM, APNs, SendGrid, and Twilio all have rate limits. Handle them gracefully. Without this throttle, a burst of outgoing notifications could exhaust your provider's quota within seconds, causing your entire notification system to fail for the rest of the billing period. Think of it like a water tap with a flow restrictor: you control the output rate to stay within the pipe's capacity, even when the demand upstream is higher.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class AdaptiveRateLimiter {\n\n    private final Map\u0026#x3C;String, TokenBucket\u003e providerBuckets = Map.of(\n        \"FCM\",      new TokenBucket(600_000, 600_000), // 600K/min\n        \"APNs\",     new TokenBucket(300_000, 300_000),\n        \"SendGrid\", new TokenBucket(100,  100),         // 100/sec\n        \"Twilio\",   new TokenBucket(1,    1)            // 1/sec (varies by plan)\n    );\n\n    public void throttle(String provider) {\n        TokenBucket bucket = providerBuckets.get(provider);\n        if (!bucket.tryConsume()) {\n            long waitMs = bucket.getMillisToNextToken();\n            try { Thread.sleep(waitMs); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eScheduled Notifications\u003c/h2\u003e\n\u003cp\u003eThe final capability to add is scheduling, where a notification should be delivered at a specific future time rather than immediately. Redis sorted sets are the perfect data structure for this: the score is the delivery timestamp in milliseconds, so a range query from 0 to \"now\" always returns exactly the notifications that are due, in order.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Store scheduled notifications in a sorted set (score = delivery timestamp)\npublic void schedule(NotificationRequest request, Instant deliveryTime) {\n    String key = \"scheduled:notifications\";\n    String payload = objectMapper.writeValueAsString(request);\n    redis.opsForZSet().add(key, payload, deliveryTime.toEpochMilli());\n}\n\n// Scheduler: poll every second, process due notifications\n@Scheduled(fixedDelay = 1000)\npublic void processScheduled() {\n    long now = Instant.now().toEpochMilli();\n    Set\u0026#x3C;String\u003e due = redis.opsForZSet().rangeByScore(\"scheduled:notifications\", 0, now);\n\n    for (String payload : due) {\n        NotificationRequest request = objectMapper.readValue(payload, NotificationRequest.class);\n        enqueue(request);\n        redis.opsForZSet().remove(\"scheduled:notifications\", payload);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe one-second polling interval gives you a delivery accuracy of Â±1 second, which is sufficient for virtually all scheduling use cases. If you needed sub-second precision, you would replace the scheduler with a dedicated delay queue backed by a time-wheel data structure.\u003c/p\u003e\n\u003cp\u003eThe notification system's core challenge is not the happy path â€” it's the edge cases: user preferences changing mid-delivery, third-party provider outages, duplicate suppression on retry, and fan-out storms during viral events. Design each component to handle failure gracefully, and your notification system will be invisible to users (which is exactly what you want).\u003c/p\u003e\n","tableOfContents":[{"id":"requirements","text":"Requirements","level":2},{"id":"back-of-envelope","text":"Back-of-Envelope","level":2},{"id":"system-architecture","text":"System Architecture","level":2},{"id":"core-service-notification-api","text":"Core Service: Notification API","level":2},{"id":"fan-out-strategy-push-vs-pull","text":"Fan-Out Strategy: Push vs Pull","level":2},{"id":"channel-workers","text":"Channel Workers","level":2},{"id":"delivery-tracking-with-cassandra","text":"Delivery Tracking with Cassandra","level":2},{"id":"user-preference-management","text":"User Preference Management","level":2},{"id":"handling-third-party-rate-limits","text":"Handling Third-Party Rate Limits","level":2},{"id":"scheduled-notifications","text":"Scheduled Notifications","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"system-design-notification-system"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>