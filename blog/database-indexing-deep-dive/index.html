<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning<!-- --> | CodeSprintPro</title><meta name="description" content="Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/database-indexing-deep-dive/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning" data-next-head=""/><meta property="og:description" content="Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/database-indexing-deep-dive/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-03-09" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="postgresql" data-next-head=""/><meta property="article:tag" content="indexing" data-next-head=""/><meta property="article:tag" content="b-tree" data-next-head=""/><meta property="article:tag" content="query optimization" data-next-head=""/><meta property="article:tag" content="databases" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning" data-next-head=""/><meta name="twitter:description" content="Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning","description":"Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-03-09","dateModified":"2025-03-09","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/database-indexing-deep-dive/"},"keywords":"postgresql, indexing, b-tree, query optimization, databases, performance","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>March 9, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>12 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->postgresql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->indexing</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->b-tree</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->query optimization</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->databases</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Indexes are the single most impactful optimization in database performance. A 10-second query becomes 20ms with the right index. A wrong index slows writes and misleads the query planner. Understanding the internals ‚Äî not just "add an index on the WHERE column" ‚Äî is what separates engineers who tune databases from those who keep adding hardware.</p>
<h2>How B-Tree Indexes Work</h2>
<p>PostgreSQL's default index type is B-Tree (Balanced Tree). Every index lookup starts here.</p>
<p>Think of a B-Tree like a filing cabinet with a hierarchical sorting system. If you want to find a customer with ID <code>cust-123</code> in a 10-million-row table without an index, you have to flip through every single record. With a B-Tree, you start at the root, follow a branch left or right at each node based on the key value, and arrive at the exact record in roughly 24 steps ‚Äî no matter how large the table grows. This is the difference between O(n) and O(log n).</p>
<pre><code>Table: orders (10 million rows)
Column: customer_id (VARCHAR, not indexed)

Full table scan:
  SELECT * FROM orders WHERE customer_id = 'cust-123'
  ‚Üí Read all 10M rows, discard 9,999,990
  ‚Üí Cost: O(n) ‚Äî terrible

With B-Tree index on customer_id:

B-Tree structure:
                    [cust-500]
                   /          \
          [cust-200]            [cust-800]
         /         \            /        \
  [cust-100]  [cust-300] [cust-600] [cust-900]
   /      \    /      \    ...
[cust-123] ...

Lookup: cust-123
  1. Root: cust-123 &#x3C; cust-500 ‚Üí go left
  2. Node: cust-123 &#x3C; cust-200 ‚Üí go left
  3. Node: cust-123 > cust-100 ‚Üí go right
  4. Found: cust-123 ‚Üí pointer to row location

Cost: O(log n) = ~24 comparisons for 10M rows
Result: 0.02ms vs 10 seconds
</code></pre>
<p>Each B-Tree leaf node stores:</p>
<ul>
<li>Index key value (customer_id)</li>
<li>Pointer to heap page (the actual table row)</li>
<li>Pointer to next/previous leaf node (for range scans)</li>
</ul>
<p>The leaf-node linking is what makes range queries (<code>WHERE created_at BETWEEN x AND y</code>) efficient on B-Trees. Once you find the starting key, you just follow the linked list of leaf nodes forward ‚Äî no need to traverse the tree again for each value.</p>
<h2>Index Scans vs Heap Fetches</h2>
<p>Creating an index is only half the work. You also need to understand what happens after the index is used ‚Äî specifically, the extra step of fetching the actual row data from the table heap. The <code>EXPLAIN ANALYZE</code> output below shows what this looks like in practice and hints at the opportunity for covering indexes.</p>
<pre><code class="language-sql">-- Create table and index
CREATE TABLE orders (
    id          BIGSERIAL PRIMARY KEY,
    customer_id VARCHAR(36),
    status      VARCHAR(20),
    total_cents INTEGER,
    created_at  TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_orders_customer ON orders (customer_id);

-- Query 1: Point lookup ‚Äî extremely efficient
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 'cust-123';

-- Output:
-- Index Scan using idx_orders_customer on orders
--   (cost=0.56..8.58 rows=5 width=80) (actual time=0.030..0.045 rows=5 loops=1)
--   Index Cond: (customer_id = 'cust-123')

-- Query 2: Range scan ‚Äî also efficient
EXPLAIN ANALYZE SELECT * FROM orders
WHERE customer_id = 'cust-123' AND created_at > NOW() - INTERVAL '30 days';

-- The planner uses the index on customer_id, then filters by created_at
-- Better: composite index (customer_id, created_at)
</code></pre>
<h2>Composite Indexes: Order Matters</h2>
<p>The column order in a composite index determines which queries benefit.</p>
<p>A composite index is like a phone book sorted by last name, then first name. You can efficiently look up everyone named "Smith" (leftmost column), or find "John Smith" specifically (both columns). But you cannot efficiently find everyone named "John" across all last names ‚Äî there is no way to skip the first sort key. This is the leftmost prefix rule, and it governs every composite index you create.</p>
<pre><code class="language-sql">-- Index: (customer_id, created_at)
CREATE INDEX idx_orders_customer_date ON orders (customer_id, created_at DESC);

-- This index CAN satisfy these queries (leftmost prefix rule):
-- 1. WHERE customer_id = ?                          ‚Üê uses full index
-- 2. WHERE customer_id = ? AND created_at > ?       ‚Üê uses full index
-- 3. WHERE customer_id = ? ORDER BY created_at DESC ‚Üê uses index order (no sort)

-- This index CANNOT satisfy:
-- 4. WHERE created_at > ?                           ‚Üê can't skip first column
-- 5. WHERE status = ?                               ‚Üê not in index

-- For query 4, you need a separate index: CREATE INDEX ON orders (created_at);

-- Rule: put equality conditions first, range conditions last
-- (a = ?, b = ?, c > ?)  ‚Üí  INDEX(a, b, c)  ‚Üê correct
-- (c > ?, a = ?, b = ?)  ‚Üí  INDEX(a, b, c)  ‚Üê correct index, wrong column order
</code></pre>
<p>Always place equality conditions before range conditions in a composite index. PostgreSQL can use equality conditions to narrow down a specific sub-tree of the B-Tree, then scan forward for the range ‚Äî but only if the range column comes after the equality columns.</p>
<h2>Covering Indexes: Eliminate Heap Fetches</h2>
<p>A covering index contains all columns the query needs ‚Äî the index itself answers the query without touching the table.</p>
<p>Every time your query returns a column that is not in the index, PostgreSQL must jump from the index to the actual table heap to fetch that column. For a query returning 50,000 rows, that is 50,000 random disk reads. A covering index eliminates all of them by embedding the needed column values directly in the index leaf nodes using <code>INCLUDE</code>.</p>
<pre><code class="language-sql">-- Query: get order IDs and totals for a customer (no need to fetch full row)
SELECT id, total_cents FROM orders WHERE customer_id = 'cust-123';

-- Without covering index:
--   1. Scan index ‚Üí find matching row pointers
--   2. Fetch each row from heap (random I/O ‚Äî expensive for many rows)

-- Covering index (INCLUDE adds columns to leaf nodes without affecting tree structure):
CREATE INDEX idx_orders_customer_covering
  ON orders (customer_id)
  INCLUDE (id, total_cents);

-- Now query can be answered from index only ‚Äî "Index Only Scan"
EXPLAIN ANALYZE SELECT id, total_cents FROM orders WHERE customer_id = 'cust-123';
-- Index Only Scan using idx_orders_customer_covering on orders
--   Heap Fetches: 0  ‚Üê zero table reads!
</code></pre>
<p><code>Heap Fetches: 0</code> is what you are aiming for with a covering index. The <code>INCLUDE</code> columns live only in the leaf nodes and are not part of the B-Tree sort key, so they do not increase index maintenance cost as much as adding them as regular index columns would.</p>
<h2>Partial Indexes: Index Only What You Query</h2>
<pre><code class="language-sql">-- Problem: 10M orders, but 99% are DELIVERED (rarely queried)
-- Full index on status wastes space and slows writes

-- Partial index: only index PENDING and PROCESSING orders
CREATE INDEX idx_orders_active_status
  ON orders (status, created_at)
  WHERE status IN ('PENDING', 'PROCESSING');

-- This index is tiny (~50K rows instead of 10M) and fast
-- Query:
SELECT * FROM orders WHERE status = 'PENDING' ORDER BY created_at;
-- Uses partial index ‚Äî only scans the 50K active rows

-- Useful patterns:
-- WHERE deleted_at IS NULL    (soft-deleted records)
-- WHERE processed = false     (queue-like patterns)
-- WHERE status != 'COMPLETED' (active/pending states)
</code></pre>
<p>Partial indexes are one of the most underused PostgreSQL features. If you have a queue-like table where 99% of rows are in a terminal state (COMPLETED, DELIVERED, ARCHIVED) but your application only queries active rows, a full index on the status column is 99% waste. A partial index covering only the active states is smaller, faster to update, and more likely to fit in the OS page cache.</p>
<h2>Hash Indexes</h2>
<p>Hash indexes are faster for equality lookups than B-Trees but support only <code>=</code> (no ranges, no ordering).</p>
<p>Think of a hash index as a lookup dictionary with direct addressing: given a key, compute a hash, jump directly to the bucket. This is O(1) rather than B-Tree's O(log n), making hash lookups faster for pure equality queries. The trade-off is that hash functions produce no ordering ‚Äî so range queries, sorting, and prefix searches are impossible.</p>
<pre><code class="language-sql">-- Create hash index
CREATE INDEX idx_orders_id_hash ON orders USING HASH (id);

-- Hash index uses: O(1) lookup for equality
-- B-Tree: O(log n)
-- Hash advantage: 20-40% faster for equality-only lookups

-- BUT: hash indexes don't support:
-- ORDER BY, BETWEEN, >, &#x3C;, >=, &#x3C;=
-- LIKE 'prefix%'
-- Multiple columns

-- Use hash indexes for: lookup tables, user ID lookups, session tokens
-- Use B-Tree indexes for: everything else
</code></pre>
<h2>Index Bloat and Maintenance</h2>
<p>Over time, indexes accumulate dead weight. Every <code>UPDATE</code> or <code>DELETE</code> marks old index entries as dead rather than immediately removing them ‚Äî PostgreSQL's MVCC model requires this so that older transactions can still use the stale entries. <code>VACUUM</code> reclaims this space automatically, but on very high-churn tables, bloat can accumulate faster than <code>autovacuum</code> clears it.</p>
<pre><code class="language-sql">-- Check index size and bloat
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE relname = 'orders'
ORDER BY pg_relation_size(indexrelid) DESC;

-- Find unused indexes (never scanned ‚Äî wasting write overhead)
SELECT indexname, idx_scan
FROM pg_stat_user_indexes
WHERE relname = 'orders' AND idx_scan = 0;
-- These indexes are candidates for removal

-- Index bloat: happens after many updates/deletes
-- PostgreSQL marks old versions dead but doesn't immediately reclaim space
-- Fix: VACUUM ANALYZE (automatic) or REINDEX CONCURRENTLY (manual, online)

-- Reindex without locking (PostgreSQL 12+):
REINDEX INDEX CONCURRENTLY idx_orders_customer;
</code></pre>
<p>Any index with <code>idx_scan = 0</code> is a write tax with no corresponding read benefit. Drop it. Unused indexes are surprisingly common ‚Äî they often accumulate from exploratory optimization attempts that were later superseded by a different index.</p>
<h2>Reading EXPLAIN ANALYZE Output</h2>
<p><code>EXPLAIN ANALYZE</code> is your most powerful tool for understanding what PostgreSQL actually does when it runs a query. The query below joins orders with customers and filters by status and date ‚Äî a common pattern that exercises index selection, join strategy, and sort behavior all at once.</p>
<pre><code class="language-sql">EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT o.id, o.total_cents, c.name
FROM orders o
JOIN customers c ON c.id = o.customer_id
WHERE o.status = 'PENDING'
  AND o.created_at > NOW() - INTERVAL '7 days'
ORDER BY o.total_cents DESC
LIMIT 10;
</code></pre>
<pre><code>Hash Join  (cost=1234.56..2345.67 rows=10 width=80)
           (actual time=45.234..89.123 rows=10 loops=1)
   Buffers: shared hit=1234 read=567  ‚Üê hit=cache, read=disk I/O
   ->  Limit  (cost=1000.00..1100.00 rows=10 width=60)
         (actual time=40.123..40.456 rows=10 loops=1)
       ->  Sort  (cost=1000.00..1050.00 rows=50 width=60)
                 (actual time=40.100..40.200 rows=10 loops=1)
             Sort Key: o.total_cents DESC
             Sort Method: top-N heapsort  Memory: 25kB
             ->  Index Scan using idx_orders_status_date on orders o
                           (cost=0.56..900.34 rows=50 width=60)
                           (actual time=0.100..35.234 rows=2847 loops=1)
                   Index Cond: (status = 'PENDING' AND created_at > ...)
   ->  Hash  (cost=100.00..100.00 rows=10000 width=40)
             (actual time=4.567..4.567 rows=10000 loops=1)
         ->  Seq Scan on customers c  ‚Üê WARNING: full table scan on customers
               (cost=0.00..100.00 rows=10000 width=40)
               (actual time=0.100..2.345 rows=10000 loops=1)

Planning Time: 2.345 ms
Execution Time: 89.456 ms
</code></pre>
<p><strong>Reading the output:</strong></p>
<ul>
<li><code>cost=X..Y</code>: Estimated cost (X=first row, Y=all rows)</li>
<li><code>actual time=X..Y</code>: Real measured time in ms</li>
<li><code>rows=N</code>: Estimated vs actual rows (large difference = stale statistics)</li>
<li><code>Seq Scan</code>: Full table scan ‚Äî usually needs an index</li>
<li><code>Buffers: read=567</code>: Disk reads ‚Äî high count = slow query, consider caching</li>
<li><code>Sort Method: external merge</code>: Sorting spilled to disk ‚Äî increase work_mem</li>
</ul>
<p>In the output above, the <code>Seq Scan on customers</code> is the red flag ‚Äî every query hitting this join is doing a full scan of the customers table. Adding an index on <code>customers.id</code> would likely eliminate it. Always look for <code>Seq Scan</code> on large tables as your first optimization target.</p>
<h2>Index Strategy for Common Patterns</h2>
<p>Now that you understand the tools, here is how they combine for the most common query patterns you will encounter in production applications. Each pattern below pairs a real-world query type with the optimal index structure.</p>
<pre><code class="language-sql">-- Pattern 1: User's recent orders (most common)
CREATE INDEX idx_orders_user_recent ON orders (customer_id, created_at DESC)
  WHERE status != 'CANCELLED';

-- Pattern 2: Admin dashboard ‚Äî orders by status with pagination
CREATE INDEX idx_orders_status_created ON orders (status, created_at DESC);

-- Pattern 3: Slow full-text search on description
CREATE INDEX idx_products_search ON products USING GIN (
  to_tsvector('english', name || ' ' || description)
);

-- Query:
SELECT * FROM products
WHERE to_tsvector('english', name || ' ' || description) @@ plainto_tsquery('wireless headphones');

-- Pattern 4: JSON column queries
CREATE INDEX idx_events_metadata ON events USING GIN (metadata jsonb_path_ops);
-- Query: WHERE metadata @> '{"type": "PAYMENT_FAILED"}'

-- Pattern 5: UUID primary key ‚Äî use BRIN for sequential UUIDs (v7)
-- UUIDv7 is monotonically increasing ‚Äî use BRIN for 99% smaller index
CREATE INDEX idx_orders_id_brin ON orders USING BRIN (id)
  WHERE id::text ~ '^[0-9a-f]{8}-7';  -- Only UUIDv7 style
</code></pre>
<h2>The Index Decision Framework</h2>
<pre><code>Should I add this index?

1. Is this query in a hot path? (runs frequently or is user-facing)
   NO ‚Üí probably not worth it

2. Does EXPLAIN show Seq Scan on a large table (>100K rows)?
   YES ‚Üí strong signal for an index

3. What's the selectivity?
   HIGH selectivity (WHERE user_id = ?) ‚Üí B-Tree index
   LOW selectivity (WHERE status = 'active', 90% rows) ‚Üí partial index or no index

4. Is this a write-heavy table?
   YES ‚Üí every index adds overhead to INSERT/UPDATE/DELETE
   Rule: never add an index without measuring write performance impact

5. Can a covering index eliminate heap fetches?
   YES, if query reads few columns ‚Üí INCLUDE those columns

The right number of indexes for most tables: 2-5.
Every additional index costs write throughput. Choose carefully.
</code></pre>
<p>The discipline of database optimization is 90% indexing and 10% everything else. Before touching application code, schema, or hardware, run EXPLAIN ANALYZE on your slowest queries and check: Is the query planner using the right index? If not, why not? Missing index? Wrong column order? Stale statistics? Answer those questions first.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Database%20Indexing%20Deep%20Dive%3A%20B-Trees%2C%20Hash%20Indexes%2C%20and%20Query%20Planning&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fdatabase-indexing-deep-dive%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fdatabase-indexing-deep-dive%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#how-b-tree-indexes-work" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">How B-Tree Indexes Work</a></li><li class=""><a href="#index-scans-vs-heap-fetches" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Scans vs Heap Fetches</a></li><li class=""><a href="#composite-indexes-order-matters" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Composite Indexes: Order Matters</a></li><li class=""><a href="#covering-indexes-eliminate-heap-fetches" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Covering Indexes: Eliminate Heap Fetches</a></li><li class=""><a href="#partial-indexes-index-only-what-you-query" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Partial Indexes: Index Only What You Query</a></li><li class=""><a href="#hash-indexes" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Hash Indexes</a></li><li class=""><a href="#index-bloat-and-maintenance" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Bloat and Maintenance</a></li><li class=""><a href="#reading-explain-analyze-output" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Reading EXPLAIN ANALYZE Output</a></li><li class=""><a href="#index-strategy-for-common-patterns" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Strategy for Common Patterns</a></li><li class=""><a href="#the-index-decision-framework" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Index Decision Framework</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there&#x27;s no primary, and data placement is determined by partit‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Database Indexing Deep Dive: B-Trees, Hash Indexes, and Query Planning","description":"Master database indexing internals. Understand B-tree structure, hash indexes, composite indexes, covering indexes, and how query planners use them. Includes PostgreSQL EXPLAIN analysis.","date":"2025-03-09","category":"Databases","tags":["postgresql","indexing","b-tree","query optimization","databases","performance"],"featured":false,"affiliateSection":"database-resources","slug":"database-indexing-deep-dive","readingTime":"12 min read","excerpt":"Indexes are the single most impactful optimization in database performance. A 10-second query becomes 20ms with the right index. A wrong index slows writes and misleads the query planner. Understanding the internals ‚Äî no‚Ä¶","contentHtml":"\u003cp\u003eIndexes are the single most impactful optimization in database performance. A 10-second query becomes 20ms with the right index. A wrong index slows writes and misleads the query planner. Understanding the internals ‚Äî not just \"add an index on the WHERE column\" ‚Äî is what separates engineers who tune databases from those who keep adding hardware.\u003c/p\u003e\n\u003ch2\u003eHow B-Tree Indexes Work\u003c/h2\u003e\n\u003cp\u003ePostgreSQL's default index type is B-Tree (Balanced Tree). Every index lookup starts here.\u003c/p\u003e\n\u003cp\u003eThink of a B-Tree like a filing cabinet with a hierarchical sorting system. If you want to find a customer with ID \u003ccode\u003ecust-123\u003c/code\u003e in a 10-million-row table without an index, you have to flip through every single record. With a B-Tree, you start at the root, follow a branch left or right at each node based on the key value, and arrive at the exact record in roughly 24 steps ‚Äî no matter how large the table grows. This is the difference between O(n) and O(log n).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTable: orders (10 million rows)\nColumn: customer_id (VARCHAR, not indexed)\n\nFull table scan:\n  SELECT * FROM orders WHERE customer_id = 'cust-123'\n  ‚Üí Read all 10M rows, discard 9,999,990\n  ‚Üí Cost: O(n) ‚Äî terrible\n\nWith B-Tree index on customer_id:\n\nB-Tree structure:\n                    [cust-500]\n                   /          \\\n          [cust-200]            [cust-800]\n         /         \\            /        \\\n  [cust-100]  [cust-300] [cust-600] [cust-900]\n   /      \\    /      \\    ...\n[cust-123] ...\n\nLookup: cust-123\n  1. Root: cust-123 \u0026#x3C; cust-500 ‚Üí go left\n  2. Node: cust-123 \u0026#x3C; cust-200 ‚Üí go left\n  3. Node: cust-123 \u003e cust-100 ‚Üí go right\n  4. Found: cust-123 ‚Üí pointer to row location\n\nCost: O(log n) = ~24 comparisons for 10M rows\nResult: 0.02ms vs 10 seconds\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach B-Tree leaf node stores:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIndex key value (customer_id)\u003c/li\u003e\n\u003cli\u003ePointer to heap page (the actual table row)\u003c/li\u003e\n\u003cli\u003ePointer to next/previous leaf node (for range scans)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe leaf-node linking is what makes range queries (\u003ccode\u003eWHERE created_at BETWEEN x AND y\u003c/code\u003e) efficient on B-Trees. Once you find the starting key, you just follow the linked list of leaf nodes forward ‚Äî no need to traverse the tree again for each value.\u003c/p\u003e\n\u003ch2\u003eIndex Scans vs Heap Fetches\u003c/h2\u003e\n\u003cp\u003eCreating an index is only half the work. You also need to understand what happens after the index is used ‚Äî specifically, the extra step of fetching the actual row data from the table heap. The \u003ccode\u003eEXPLAIN ANALYZE\u003c/code\u003e output below shows what this looks like in practice and hints at the opportunity for covering indexes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Create table and index\nCREATE TABLE orders (\n    id          BIGSERIAL PRIMARY KEY,\n    customer_id VARCHAR(36),\n    status      VARCHAR(20),\n    total_cents INTEGER,\n    created_at  TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_orders_customer ON orders (customer_id);\n\n-- Query 1: Point lookup ‚Äî extremely efficient\nEXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 'cust-123';\n\n-- Output:\n-- Index Scan using idx_orders_customer on orders\n--   (cost=0.56..8.58 rows=5 width=80) (actual time=0.030..0.045 rows=5 loops=1)\n--   Index Cond: (customer_id = 'cust-123')\n\n-- Query 2: Range scan ‚Äî also efficient\nEXPLAIN ANALYZE SELECT * FROM orders\nWHERE customer_id = 'cust-123' AND created_at \u003e NOW() - INTERVAL '30 days';\n\n-- The planner uses the index on customer_id, then filters by created_at\n-- Better: composite index (customer_id, created_at)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eComposite Indexes: Order Matters\u003c/h2\u003e\n\u003cp\u003eThe column order in a composite index determines which queries benefit.\u003c/p\u003e\n\u003cp\u003eA composite index is like a phone book sorted by last name, then first name. You can efficiently look up everyone named \"Smith\" (leftmost column), or find \"John Smith\" specifically (both columns). But you cannot efficiently find everyone named \"John\" across all last names ‚Äî there is no way to skip the first sort key. This is the leftmost prefix rule, and it governs every composite index you create.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Index: (customer_id, created_at)\nCREATE INDEX idx_orders_customer_date ON orders (customer_id, created_at DESC);\n\n-- This index CAN satisfy these queries (leftmost prefix rule):\n-- 1. WHERE customer_id = ?                          ‚Üê uses full index\n-- 2. WHERE customer_id = ? AND created_at \u003e ?       ‚Üê uses full index\n-- 3. WHERE customer_id = ? ORDER BY created_at DESC ‚Üê uses index order (no sort)\n\n-- This index CANNOT satisfy:\n-- 4. WHERE created_at \u003e ?                           ‚Üê can't skip first column\n-- 5. WHERE status = ?                               ‚Üê not in index\n\n-- For query 4, you need a separate index: CREATE INDEX ON orders (created_at);\n\n-- Rule: put equality conditions first, range conditions last\n-- (a = ?, b = ?, c \u003e ?)  ‚Üí  INDEX(a, b, c)  ‚Üê correct\n-- (c \u003e ?, a = ?, b = ?)  ‚Üí  INDEX(a, b, c)  ‚Üê correct index, wrong column order\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlways place equality conditions before range conditions in a composite index. PostgreSQL can use equality conditions to narrow down a specific sub-tree of the B-Tree, then scan forward for the range ‚Äî but only if the range column comes after the equality columns.\u003c/p\u003e\n\u003ch2\u003eCovering Indexes: Eliminate Heap Fetches\u003c/h2\u003e\n\u003cp\u003eA covering index contains all columns the query needs ‚Äî the index itself answers the query without touching the table.\u003c/p\u003e\n\u003cp\u003eEvery time your query returns a column that is not in the index, PostgreSQL must jump from the index to the actual table heap to fetch that column. For a query returning 50,000 rows, that is 50,000 random disk reads. A covering index eliminates all of them by embedding the needed column values directly in the index leaf nodes using \u003ccode\u003eINCLUDE\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Query: get order IDs and totals for a customer (no need to fetch full row)\nSELECT id, total_cents FROM orders WHERE customer_id = 'cust-123';\n\n-- Without covering index:\n--   1. Scan index ‚Üí find matching row pointers\n--   2. Fetch each row from heap (random I/O ‚Äî expensive for many rows)\n\n-- Covering index (INCLUDE adds columns to leaf nodes without affecting tree structure):\nCREATE INDEX idx_orders_customer_covering\n  ON orders (customer_id)\n  INCLUDE (id, total_cents);\n\n-- Now query can be answered from index only ‚Äî \"Index Only Scan\"\nEXPLAIN ANALYZE SELECT id, total_cents FROM orders WHERE customer_id = 'cust-123';\n-- Index Only Scan using idx_orders_customer_covering on orders\n--   Heap Fetches: 0  ‚Üê zero table reads!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eHeap Fetches: 0\u003c/code\u003e is what you are aiming for with a covering index. The \u003ccode\u003eINCLUDE\u003c/code\u003e columns live only in the leaf nodes and are not part of the B-Tree sort key, so they do not increase index maintenance cost as much as adding them as regular index columns would.\u003c/p\u003e\n\u003ch2\u003ePartial Indexes: Index Only What You Query\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Problem: 10M orders, but 99% are DELIVERED (rarely queried)\n-- Full index on status wastes space and slows writes\n\n-- Partial index: only index PENDING and PROCESSING orders\nCREATE INDEX idx_orders_active_status\n  ON orders (status, created_at)\n  WHERE status IN ('PENDING', 'PROCESSING');\n\n-- This index is tiny (~50K rows instead of 10M) and fast\n-- Query:\nSELECT * FROM orders WHERE status = 'PENDING' ORDER BY created_at;\n-- Uses partial index ‚Äî only scans the 50K active rows\n\n-- Useful patterns:\n-- WHERE deleted_at IS NULL    (soft-deleted records)\n-- WHERE processed = false     (queue-like patterns)\n-- WHERE status != 'COMPLETED' (active/pending states)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePartial indexes are one of the most underused PostgreSQL features. If you have a queue-like table where 99% of rows are in a terminal state (COMPLETED, DELIVERED, ARCHIVED) but your application only queries active rows, a full index on the status column is 99% waste. A partial index covering only the active states is smaller, faster to update, and more likely to fit in the OS page cache.\u003c/p\u003e\n\u003ch2\u003eHash Indexes\u003c/h2\u003e\n\u003cp\u003eHash indexes are faster for equality lookups than B-Trees but support only \u003ccode\u003e=\u003c/code\u003e (no ranges, no ordering).\u003c/p\u003e\n\u003cp\u003eThink of a hash index as a lookup dictionary with direct addressing: given a key, compute a hash, jump directly to the bucket. This is O(1) rather than B-Tree's O(log n), making hash lookups faster for pure equality queries. The trade-off is that hash functions produce no ordering ‚Äî so range queries, sorting, and prefix searches are impossible.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Create hash index\nCREATE INDEX idx_orders_id_hash ON orders USING HASH (id);\n\n-- Hash index uses: O(1) lookup for equality\n-- B-Tree: O(log n)\n-- Hash advantage: 20-40% faster for equality-only lookups\n\n-- BUT: hash indexes don't support:\n-- ORDER BY, BETWEEN, \u003e, \u0026#x3C;, \u003e=, \u0026#x3C;=\n-- LIKE 'prefix%'\n-- Multiple columns\n\n-- Use hash indexes for: lookup tables, user ID lookups, session tokens\n-- Use B-Tree indexes for: everything else\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eIndex Bloat and Maintenance\u003c/h2\u003e\n\u003cp\u003eOver time, indexes accumulate dead weight. Every \u003ccode\u003eUPDATE\u003c/code\u003e or \u003ccode\u003eDELETE\u003c/code\u003e marks old index entries as dead rather than immediately removing them ‚Äî PostgreSQL's MVCC model requires this so that older transactions can still use the stale entries. \u003ccode\u003eVACUUM\u003c/code\u003e reclaims this space automatically, but on very high-churn tables, bloat can accumulate faster than \u003ccode\u003eautovacuum\u003c/code\u003e clears it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Check index size and bloat\nSELECT\n    indexname,\n    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n    idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\nFROM pg_stat_user_indexes\nWHERE relname = 'orders'\nORDER BY pg_relation_size(indexrelid) DESC;\n\n-- Find unused indexes (never scanned ‚Äî wasting write overhead)\nSELECT indexname, idx_scan\nFROM pg_stat_user_indexes\nWHERE relname = 'orders' AND idx_scan = 0;\n-- These indexes are candidates for removal\n\n-- Index bloat: happens after many updates/deletes\n-- PostgreSQL marks old versions dead but doesn't immediately reclaim space\n-- Fix: VACUUM ANALYZE (automatic) or REINDEX CONCURRENTLY (manual, online)\n\n-- Reindex without locking (PostgreSQL 12+):\nREINDEX INDEX CONCURRENTLY idx_orders_customer;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny index with \u003ccode\u003eidx_scan = 0\u003c/code\u003e is a write tax with no corresponding read benefit. Drop it. Unused indexes are surprisingly common ‚Äî they often accumulate from exploratory optimization attempts that were later superseded by a different index.\u003c/p\u003e\n\u003ch2\u003eReading EXPLAIN ANALYZE Output\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eEXPLAIN ANALYZE\u003c/code\u003e is your most powerful tool for understanding what PostgreSQL actually does when it runs a query. The query below joins orders with customers and filters by status and date ‚Äî a common pattern that exercises index selection, join strategy, and sort behavior all at once.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eEXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)\nSELECT o.id, o.total_cents, c.name\nFROM orders o\nJOIN customers c ON c.id = o.customer_id\nWHERE o.status = 'PENDING'\n  AND o.created_at \u003e NOW() - INTERVAL '7 days'\nORDER BY o.total_cents DESC\nLIMIT 10;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eHash Join  (cost=1234.56..2345.67 rows=10 width=80)\n           (actual time=45.234..89.123 rows=10 loops=1)\n   Buffers: shared hit=1234 read=567  ‚Üê hit=cache, read=disk I/O\n   -\u003e  Limit  (cost=1000.00..1100.00 rows=10 width=60)\n         (actual time=40.123..40.456 rows=10 loops=1)\n       -\u003e  Sort  (cost=1000.00..1050.00 rows=50 width=60)\n                 (actual time=40.100..40.200 rows=10 loops=1)\n             Sort Key: o.total_cents DESC\n             Sort Method: top-N heapsort  Memory: 25kB\n             -\u003e  Index Scan using idx_orders_status_date on orders o\n                           (cost=0.56..900.34 rows=50 width=60)\n                           (actual time=0.100..35.234 rows=2847 loops=1)\n                   Index Cond: (status = 'PENDING' AND created_at \u003e ...)\n   -\u003e  Hash  (cost=100.00..100.00 rows=10000 width=40)\n             (actual time=4.567..4.567 rows=10000 loops=1)\n         -\u003e  Seq Scan on customers c  ‚Üê WARNING: full table scan on customers\n               (cost=0.00..100.00 rows=10000 width=40)\n               (actual time=0.100..2.345 rows=10000 loops=1)\n\nPlanning Time: 2.345 ms\nExecution Time: 89.456 ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eReading the output:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecost=X..Y\u003c/code\u003e: Estimated cost (X=first row, Y=all rows)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eactual time=X..Y\u003c/code\u003e: Real measured time in ms\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erows=N\u003c/code\u003e: Estimated vs actual rows (large difference = stale statistics)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq Scan\u003c/code\u003e: Full table scan ‚Äî usually needs an index\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBuffers: read=567\u003c/code\u003e: Disk reads ‚Äî high count = slow query, consider caching\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSort Method: external merge\u003c/code\u003e: Sorting spilled to disk ‚Äî increase work_mem\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the output above, the \u003ccode\u003eSeq Scan on customers\u003c/code\u003e is the red flag ‚Äî every query hitting this join is doing a full scan of the customers table. Adding an index on \u003ccode\u003ecustomers.id\u003c/code\u003e would likely eliminate it. Always look for \u003ccode\u003eSeq Scan\u003c/code\u003e on large tables as your first optimization target.\u003c/p\u003e\n\u003ch2\u003eIndex Strategy for Common Patterns\u003c/h2\u003e\n\u003cp\u003eNow that you understand the tools, here is how they combine for the most common query patterns you will encounter in production applications. Each pattern below pairs a real-world query type with the optimal index structure.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Pattern 1: User's recent orders (most common)\nCREATE INDEX idx_orders_user_recent ON orders (customer_id, created_at DESC)\n  WHERE status != 'CANCELLED';\n\n-- Pattern 2: Admin dashboard ‚Äî orders by status with pagination\nCREATE INDEX idx_orders_status_created ON orders (status, created_at DESC);\n\n-- Pattern 3: Slow full-text search on description\nCREATE INDEX idx_products_search ON products USING GIN (\n  to_tsvector('english', name || ' ' || description)\n);\n\n-- Query:\nSELECT * FROM products\nWHERE to_tsvector('english', name || ' ' || description) @@ plainto_tsquery('wireless headphones');\n\n-- Pattern 4: JSON column queries\nCREATE INDEX idx_events_metadata ON events USING GIN (metadata jsonb_path_ops);\n-- Query: WHERE metadata @\u003e '{\"type\": \"PAYMENT_FAILED\"}'\n\n-- Pattern 5: UUID primary key ‚Äî use BRIN for sequential UUIDs (v7)\n-- UUIDv7 is monotonically increasing ‚Äî use BRIN for 99% smaller index\nCREATE INDEX idx_orders_id_brin ON orders USING BRIN (id)\n  WHERE id::text ~ '^[0-9a-f]{8}-7';  -- Only UUIDv7 style\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Index Decision Framework\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eShould I add this index?\n\n1. Is this query in a hot path? (runs frequently or is user-facing)\n   NO ‚Üí probably not worth it\n\n2. Does EXPLAIN show Seq Scan on a large table (\u003e100K rows)?\n   YES ‚Üí strong signal for an index\n\n3. What's the selectivity?\n   HIGH selectivity (WHERE user_id = ?) ‚Üí B-Tree index\n   LOW selectivity (WHERE status = 'active', 90% rows) ‚Üí partial index or no index\n\n4. Is this a write-heavy table?\n   YES ‚Üí every index adds overhead to INSERT/UPDATE/DELETE\n   Rule: never add an index without measuring write performance impact\n\n5. Can a covering index eliminate heap fetches?\n   YES, if query reads few columns ‚Üí INCLUDE those columns\n\nThe right number of indexes for most tables: 2-5.\nEvery additional index costs write throughput. Choose carefully.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe discipline of database optimization is 90% indexing and 10% everything else. Before touching application code, schema, or hardware, run EXPLAIN ANALYZE on your slowest queries and check: Is the query planner using the right index? If not, why not? Missing index? Wrong column order? Stale statistics? Answer those questions first.\u003c/p\u003e\n","tableOfContents":[{"id":"how-b-tree-indexes-work","text":"How B-Tree Indexes Work","level":2},{"id":"index-scans-vs-heap-fetches","text":"Index Scans vs Heap Fetches","level":2},{"id":"composite-indexes-order-matters","text":"Composite Indexes: Order Matters","level":2},{"id":"covering-indexes-eliminate-heap-fetches","text":"Covering Indexes: Eliminate Heap Fetches","level":2},{"id":"partial-indexes-index-only-what-you-query","text":"Partial Indexes: Index Only What You Query","level":2},{"id":"hash-indexes","text":"Hash Indexes","level":2},{"id":"index-bloat-and-maintenance","text":"Index Bloat and Maintenance","level":2},{"id":"reading-explain-analyze-output","text":"Reading EXPLAIN ANALYZE Output","level":2},{"id":"index-strategy-for-common-patterns","text":"Index Strategy for Common Patterns","level":2},{"id":"the-index-decision-framework","text":"The Index Decision Framework","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"database-indexing-deep-dive"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>