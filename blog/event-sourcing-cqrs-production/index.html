<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Event Sourcing and CQRS in Production: Beyond the Theory<!-- --> | CodeSprintPro</title><meta name="description" content="What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/event-sourcing-cqrs-production/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Event Sourcing and CQRS in Production: Beyond the Theory" data-next-head=""/><meta property="og:description" content="What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/event-sourcing-cqrs-production/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-06-23" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="System Design" data-next-head=""/><meta property="article:tag" content="event sourcing" data-next-head=""/><meta property="article:tag" content="cqrs" data-next-head=""/><meta property="article:tag" content="system design" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="distributed systems" data-next-head=""/><meta property="article:tag" content="kafka" data-next-head=""/><meta property="article:tag" content="spring boot" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Event Sourcing and CQRS in Production: Beyond the Theory" data-next-head=""/><meta name="twitter:description" content="What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-06-23","dateModified":"2025-06-23","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/event-sourcing-cqrs-production/"},"keywords":"event sourcing, cqrs, system design, java, distributed systems, kafka, spring boot","articleSection":"System Design"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Event Sourcing and CQRS in Production: Beyond the Theory</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">System Design</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Event Sourcing and CQRS in Production: Beyond the Theory</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>June 23, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->event sourcing</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->cqrs</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->system design</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->distributed systems</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->kafka</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->spring boot</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory ‚Äî store events instead of state, derive state by replaying events ‚Äî is sound. The practice involves snapshot strategies, projection rebuilding, schema evolution, and operational tooling that most tutorials skip entirely.</p>
<p>This article is about what comes after you've decided to use event sourcing.</p>
<h2>The Event Store: Core Design</h2>
<p>An event store is an append-only log of domain events. Every state change is expressed as an immutable event:</p>
<pre><code class="language-sql">-- Event store schema (PostgreSQL):
CREATE TABLE domain_events (
    id              BIGSERIAL PRIMARY KEY,
    aggregate_id    UUID NOT NULL,
    aggregate_type  VARCHAR(100) NOT NULL,       -- 'Order', 'Account', 'Shipment'
    event_type      VARCHAR(100) NOT NULL,        -- 'OrderPlaced', 'OrderShipped'
    event_version   INT NOT NULL DEFAULT 1,       -- Schema version for evolution
    sequence_number BIGINT NOT NULL,              -- Position within aggregate
    data            JSONB NOT NULL,               -- Event payload
    metadata        JSONB,                        -- Correlation ID, user ID, etc.
    occurred_at     TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (aggregate_id, sequence_number)        -- No gaps in sequence per aggregate
);

CREATE INDEX idx_events_aggregate ON domain_events (aggregate_id, sequence_number);
CREATE INDEX idx_events_type_occurred ON domain_events (event_type, occurred_at DESC);
</code></pre>
<p>Loading an aggregate's current state requires replaying its events:</p>
<pre><code class="language-java">public class OrderRepository {

    public Order load(UUID orderId) {
        List&#x3C;DomainEvent> events = eventStore.loadEvents(orderId);
        if (events.isEmpty()) {
            throw new AggregateNotFoundException(orderId);
        }
        return Order.reconstitute(events);
    }

    public void save(Order order) {
        List&#x3C;DomainEvent> newEvents = order.getUncommittedEvents();
        long expectedSequence = order.getSequenceNumber();

        // Optimistic concurrency: if another process saved between our load and save,
        // sequence number won't match ‚Üí conflict detected
        eventStore.append(order.getId(), newEvents, expectedSequence);
        order.clearUncommittedEvents();
    }
}

// Order aggregate:
public class Order {
    private UUID id;
    private OrderStatus status;
    private List&#x3C;OrderItem> items;
    private long sequenceNumber;

    // Reconstitute from events
    public static Order reconstitute(List&#x3C;DomainEvent> events) {
        Order order = new Order();
        events.forEach(order::apply);
        return order;
    }

    // Apply event (mutates state, no side effects)
    private void apply(DomainEvent event) {
        this.sequenceNumber = event.getSequenceNumber();
        switch (event) {
            case OrderPlacedEvent e -> {
                this.id = e.getOrderId();
                this.status = OrderStatus.PLACED;
                this.items = e.getItems();
            }
            case OrderShippedEvent e -> this.status = OrderStatus.SHIPPED;
            case OrderCancelledEvent e -> this.status = OrderStatus.CANCELLED;
        }
    }
}
</code></pre>
<h2>Snapshot Strategy</h2>
<p>For aggregates with long event histories, replaying 10,000 events to load a single aggregate is unacceptable. Snapshots checkpoint the aggregate's state:</p>
<pre><code class="language-sql">CREATE TABLE aggregate_snapshots (
    aggregate_id        UUID PRIMARY KEY,
    aggregate_type      VARCHAR(100) NOT NULL,
    snapshot_data       JSONB NOT NULL,
    snapshot_version    INT NOT NULL,            -- Schema version of snapshot
    sequence_number     BIGINT NOT NULL,         -- Event sequence at snapshot time
    created_at          TIMESTAMPTZ DEFAULT NOW()
);
</code></pre>
<pre><code class="language-java">public Order loadWithSnapshot(UUID orderId) {
    // 1. Load most recent snapshot
    Optional&#x3C;Snapshot> snapshot = snapshotStore.loadLatest(orderId);

    // 2. Load events after snapshot
    long fromSequence = snapshot.map(Snapshot::getSequenceNumber).orElse(0L);
    List&#x3C;DomainEvent> events = eventStore.loadEvents(orderId, fromSequence + 1);

    // 3. Reconstitute from snapshot + subsequent events
    if (snapshot.isPresent()) {
        Order order = Order.fromSnapshot(snapshot.get());
        events.forEach(order::apply);
        return order;
    } else {
        return Order.reconstitute(events);
    }
}

// Snapshot policy: snapshot after every N events
@Scheduled(fixedDelay = 60_000)
public void snapshotHighVolumeAggregates() {
    List&#x3C;UUID> candidates = eventStore.findAggregatesWithEventsAbove(
        SNAPSHOT_THRESHOLD = 100
    );
    candidates.forEach(id -> {
        Order order = load(id);
        snapshotStore.save(Snapshot.from(order));
    });
}
</code></pre>
<h2>CQRS: Separate Read and Write Models</h2>
<p>CQRS (Command Query Responsibility Segregation) pairs naturally with event sourcing: the event store is the write model; projections (denormalized views) are read models built from events.</p>
<pre><code>CQRS Architecture:

Command Side:                 Event Side:                Read Side:

User ‚Üí OrderController  ‚Üí   Event Store (append)  ‚Üí   Projection Worker
       (Command)             domain_events              ‚Üì
       ‚Üì                                            Read Model DB
       Order.apply()                                (PostgreSQL/Elasticsearch/Redis)
       ‚Üì                                                ‚Üì
       Emit events ‚Üí  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  API Response
</code></pre>
<pre><code class="language-java">// Projection: build a denormalized order summary for quick reads
@Component
@Transactional
public class OrderSummaryProjection {

    @EventHandler
    public void on(OrderPlacedEvent event) {
        orderSummaryRepository.save(new OrderSummary(
            event.getOrderId(),
            event.getUserId(),
            event.getTotalAmount(),
            "PLACED",
            event.getOccurredAt()
        ));
    }

    @EventHandler
    public void on(OrderShippedEvent event) {
        orderSummaryRepository.updateStatus(event.getOrderId(), "SHIPPED");
    }

    @EventHandler
    public void on(OrderItemAddedEvent event) {
        orderSummaryRepository.addItem(event.getOrderId(), event.getItem());
    }
}
</code></pre>
<h2>Projection Rebuilding</h2>
<p>Projections are disposable ‚Äî they can always be rebuilt from the event store. This is a key advantage. When you add a new projection, or fix a bug in an existing one, you replay all events:</p>
<pre><code class="language-java">@Component
public class ProjectionRebuilder {

    public void rebuild(Class&#x3C;? extends Projection> projectionClass, String aggregateType) {
        Projection projection = context.getBean(projectionClass);

        // Clear existing projection data
        projection.reset();

        // Stream events from beginning
        long position = 0;
        int batchSize = 1000;
        List&#x3C;DomainEvent> batch;

        do {
            batch = eventStore.loadAll(aggregateType, position, batchSize);
            batch.forEach(event -> {
                try {
                    projection.apply(event);
                } catch (Exception e) {
                    log.error("Failed to apply event {} to projection {}",
                        event.getId(), projectionClass.getSimpleName(), e);
                }
            });
            position += batch.size();
        } while (batch.size() == batchSize);

        log.info("Rebuilt projection {} with {} events", projectionClass.getSimpleName(), position);
    }
}
</code></pre>
<p>For millions of events, rebuilding in-process is too slow. Use a dedicated rebuild pipeline: stream events from the store to Kafka, run projection workers at full throughput in parallel.</p>
<h2>Schema Evolution</h2>
<p>Events are immutable. Once committed, the <code>OrderPlacedEvent</code> from 2022 cannot be changed. But your schema will evolve. Handle this with upcasters ‚Äî functions that transform old event versions to the current format:</p>
<pre><code class="language-java">public interface EventUpcaster&#x3C;T extends DomainEvent> {
    int fromVersion();
    T upcast(JsonNode rawEvent);
}

@Component
public class OrderPlacedEventV1ToV2Upcaster implements EventUpcaster&#x3C;OrderPlacedEvent> {

    @Override
    public int fromVersion() { return 1; }

    @Override
    public OrderPlacedEvent upcast(JsonNode rawEvent) {
        // V1 had 'customer_id', V2 renamed to 'user_id'
        ObjectNode upgraded = rawEvent.deepCopy();
        upgraded.put("user_id", rawEvent.get("customer_id").asText());
        upgraded.remove("customer_id");
        return objectMapper.treeToValue(upgraded, OrderPlacedEvent.class);
    }
}

// Event serialization layer applies upcasters transparently:
public DomainEvent deserialize(StoredEvent stored) {
    DomainEvent event = objectMapper.readValue(stored.getData(), getDomainEventClass(stored.getEventType()));
    return upcasterRegistry.upcastChain(event, stored.getEventVersion(), currentVersion());
}
</code></pre>
<h2>The Operational Challenges Nobody Talks About</h2>
<p><strong>1. Event store grows unboundedly.</strong> Unlike a state-based system where you UPDATE rows, event sourcing only INSERTs. A system with 100 commands/second generates 8.6M events/day. After 1 year: 3.1B events. Plan for:</p>
<ul>
<li>Archival: move events older than N years to cold storage (S3 + Parquet)</li>
<li>Index maintenance: <code>domain_events</code> index grows with the table</li>
<li>Backup strategies: event stores are large</li>
</ul>
<p><strong>2. Eventual consistency between write and read models.</strong> After a command executes, the projection may not be updated for tens of milliseconds. API clients reading immediately after a write may see stale data. Options:</p>
<ul>
<li>Return event data directly in command response (avoid the read model for the "write response")</li>
<li>Client polls until the projection catches up (pessimistic, bad UX)</li>
<li>Optimistic UI updates (update UI before projection confirms)</li>
</ul>
<p><strong>3. Process manager complexity.</strong> Long-running business processes (order fulfillment, subscription renewals) require sagas that span multiple aggregates. These are stateful and must handle partial failures. The saga state machine itself needs an event log to be recoverable.</p>
<p><strong>4. Querying across aggregates.</strong> The event store is aggregate-centric. "Give me all orders placed in the last 24 hours over $500" requires a projection. Every new query pattern potentially needs a new projection. Plan your read model database carefully.</p>
<h2>When Event Sourcing is Worth It</h2>
<p>Event sourcing is excellent for:</p>
<ul>
<li>Domains with audit requirements (finance, healthcare, compliance)</li>
<li>Complex domain logic where understanding "how did we get here" matters</li>
<li>Systems that benefit from temporal queries (state at any point in time)</li>
<li>High-throughput write paths (append-only is fast)</li>
</ul>
<p>It adds complexity that rarely pays off for:</p>
<ul>
<li>Simple CRUD systems</li>
<li>Systems without audit requirements</li>
<li>Small teams without DDD expertise</li>
<li>Services with simple, flat domain models</li>
</ul>
<p>The decision should be per-domain, not per-system. Your order management service might benefit from event sourcing; your user profile service almost certainly doesn't.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">The definitive guide to building scalable, reliable distributed systems by Martin Kleppmann.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Kafka: The Definitive Guide</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Editor&#x27;s Pick</span></div><p class="text-xs text-gray-600">Real-time data and stream processing by Confluent engineers.</p></div><a href="https://amzn.to/3TpGKsI" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Apache Kafka Series on Udemy</span></div><p class="text-xs text-gray-600">Hands-on Kafka course covering producers, consumers, Kafka Streams, and Connect.</p></div><a href="https://www.udemy.com/course/apache-kafka/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Event%20Sourcing%20and%20CQRS%20in%20Production%3A%20Beyond%20the%20Theory&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fevent-sourcing-cqrs-production%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fevent-sourcing-cqrs-production%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-event-store-core-design" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Event Store: Core Design</a></li><li class=""><a href="#snapshot-strategy" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Snapshot Strategy</a></li><li class=""><a href="#cqrs-separate-read-and-write-models" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">CQRS: Separate Read and Write Models</a></li><li class=""><a href="#projection-rebuilding" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Projection Rebuilding</a></li><li class=""><a href="#schema-evolution" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Schema Evolution</a></li><li class=""><a href="#the-operational-challenges-nobody-talks-about" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Operational Challenges Nobody Talks About</a></li><li class=""><a href="#when-event-sourcing-is-worth-it" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">When Event Sourcing is Worth It</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/observability-opentelemetry-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Building Production Observability with OpenTelemetry and Grafana Stack</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why ‚Äî by exploring system state through metrics, traces, and logs without needing to know in advance‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>6 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->observability</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->opentelemetry</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->prometheus</span></div></article></a><a href="/blog/grpc-vs-rest-vs-graphql/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">gRPC vs REST vs GraphQL: Choosing the Right API Protocol</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->grpc</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->rest</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->graphql</span></div></article></a><a href="/blog/multi-tenancy-architecture/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Multi-Tenancy Architecture: Database, Application, and Infrastructure Patterns</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Multi-tenancy is the architecture pattern where a single deployed instance of a software system serves multiple customers (tenants), with each tenant&#x27;s data logically or physically isolated from others. It&#x27;s the foundati‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>May 24, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->multi-tenancy</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->saas</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->system design</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory ‚Äî store events instead of state, derive state by replaying events ‚Äî is sou‚Ä¶","contentHtml":"\u003cp\u003eEvent sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory ‚Äî store events instead of state, derive state by replaying events ‚Äî is sound. The practice involves snapshot strategies, projection rebuilding, schema evolution, and operational tooling that most tutorials skip entirely.\u003c/p\u003e\n\u003cp\u003eThis article is about what comes after you've decided to use event sourcing.\u003c/p\u003e\n\u003ch2\u003eThe Event Store: Core Design\u003c/h2\u003e\n\u003cp\u003eAn event store is an append-only log of domain events. Every state change is expressed as an immutable event:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Event store schema (PostgreSQL):\nCREATE TABLE domain_events (\n    id              BIGSERIAL PRIMARY KEY,\n    aggregate_id    UUID NOT NULL,\n    aggregate_type  VARCHAR(100) NOT NULL,       -- 'Order', 'Account', 'Shipment'\n    event_type      VARCHAR(100) NOT NULL,        -- 'OrderPlaced', 'OrderShipped'\n    event_version   INT NOT NULL DEFAULT 1,       -- Schema version for evolution\n    sequence_number BIGINT NOT NULL,              -- Position within aggregate\n    data            JSONB NOT NULL,               -- Event payload\n    metadata        JSONB,                        -- Correlation ID, user ID, etc.\n    occurred_at     TIMESTAMPTZ DEFAULT NOW(),\n    UNIQUE (aggregate_id, sequence_number)        -- No gaps in sequence per aggregate\n);\n\nCREATE INDEX idx_events_aggregate ON domain_events (aggregate_id, sequence_number);\nCREATE INDEX idx_events_type_occurred ON domain_events (event_type, occurred_at DESC);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLoading an aggregate's current state requires replaying its events:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class OrderRepository {\n\n    public Order load(UUID orderId) {\n        List\u0026#x3C;DomainEvent\u003e events = eventStore.loadEvents(orderId);\n        if (events.isEmpty()) {\n            throw new AggregateNotFoundException(orderId);\n        }\n        return Order.reconstitute(events);\n    }\n\n    public void save(Order order) {\n        List\u0026#x3C;DomainEvent\u003e newEvents = order.getUncommittedEvents();\n        long expectedSequence = order.getSequenceNumber();\n\n        // Optimistic concurrency: if another process saved between our load and save,\n        // sequence number won't match ‚Üí conflict detected\n        eventStore.append(order.getId(), newEvents, expectedSequence);\n        order.clearUncommittedEvents();\n    }\n}\n\n// Order aggregate:\npublic class Order {\n    private UUID id;\n    private OrderStatus status;\n    private List\u0026#x3C;OrderItem\u003e items;\n    private long sequenceNumber;\n\n    // Reconstitute from events\n    public static Order reconstitute(List\u0026#x3C;DomainEvent\u003e events) {\n        Order order = new Order();\n        events.forEach(order::apply);\n        return order;\n    }\n\n    // Apply event (mutates state, no side effects)\n    private void apply(DomainEvent event) {\n        this.sequenceNumber = event.getSequenceNumber();\n        switch (event) {\n            case OrderPlacedEvent e -\u003e {\n                this.id = e.getOrderId();\n                this.status = OrderStatus.PLACED;\n                this.items = e.getItems();\n            }\n            case OrderShippedEvent e -\u003e this.status = OrderStatus.SHIPPED;\n            case OrderCancelledEvent e -\u003e this.status = OrderStatus.CANCELLED;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSnapshot Strategy\u003c/h2\u003e\n\u003cp\u003eFor aggregates with long event histories, replaying 10,000 events to load a single aggregate is unacceptable. Snapshots checkpoint the aggregate's state:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE TABLE aggregate_snapshots (\n    aggregate_id        UUID PRIMARY KEY,\n    aggregate_type      VARCHAR(100) NOT NULL,\n    snapshot_data       JSONB NOT NULL,\n    snapshot_version    INT NOT NULL,            -- Schema version of snapshot\n    sequence_number     BIGINT NOT NULL,         -- Event sequence at snapshot time\n    created_at          TIMESTAMPTZ DEFAULT NOW()\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Order loadWithSnapshot(UUID orderId) {\n    // 1. Load most recent snapshot\n    Optional\u0026#x3C;Snapshot\u003e snapshot = snapshotStore.loadLatest(orderId);\n\n    // 2. Load events after snapshot\n    long fromSequence = snapshot.map(Snapshot::getSequenceNumber).orElse(0L);\n    List\u0026#x3C;DomainEvent\u003e events = eventStore.loadEvents(orderId, fromSequence + 1);\n\n    // 3. Reconstitute from snapshot + subsequent events\n    if (snapshot.isPresent()) {\n        Order order = Order.fromSnapshot(snapshot.get());\n        events.forEach(order::apply);\n        return order;\n    } else {\n        return Order.reconstitute(events);\n    }\n}\n\n// Snapshot policy: snapshot after every N events\n@Scheduled(fixedDelay = 60_000)\npublic void snapshotHighVolumeAggregates() {\n    List\u0026#x3C;UUID\u003e candidates = eventStore.findAggregatesWithEventsAbove(\n        SNAPSHOT_THRESHOLD = 100\n    );\n    candidates.forEach(id -\u003e {\n        Order order = load(id);\n        snapshotStore.save(Snapshot.from(order));\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCQRS: Separate Read and Write Models\u003c/h2\u003e\n\u003cp\u003eCQRS (Command Query Responsibility Segregation) pairs naturally with event sourcing: the event store is the write model; projections (denormalized views) are read models built from events.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCQRS Architecture:\n\nCommand Side:                 Event Side:                Read Side:\n\nUser ‚Üí OrderController  ‚Üí   Event Store (append)  ‚Üí   Projection Worker\n       (Command)             domain_events              ‚Üì\n       ‚Üì                                            Read Model DB\n       Order.apply()                                (PostgreSQL/Elasticsearch/Redis)\n       ‚Üì                                                ‚Üì\n       Emit events ‚Üí  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  API Response\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Projection: build a denormalized order summary for quick reads\n@Component\n@Transactional\npublic class OrderSummaryProjection {\n\n    @EventHandler\n    public void on(OrderPlacedEvent event) {\n        orderSummaryRepository.save(new OrderSummary(\n            event.getOrderId(),\n            event.getUserId(),\n            event.getTotalAmount(),\n            \"PLACED\",\n            event.getOccurredAt()\n        ));\n    }\n\n    @EventHandler\n    public void on(OrderShippedEvent event) {\n        orderSummaryRepository.updateStatus(event.getOrderId(), \"SHIPPED\");\n    }\n\n    @EventHandler\n    public void on(OrderItemAddedEvent event) {\n        orderSummaryRepository.addItem(event.getOrderId(), event.getItem());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eProjection Rebuilding\u003c/h2\u003e\n\u003cp\u003eProjections are disposable ‚Äî they can always be rebuilt from the event store. This is a key advantage. When you add a new projection, or fix a bug in an existing one, you replay all events:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class ProjectionRebuilder {\n\n    public void rebuild(Class\u0026#x3C;? extends Projection\u003e projectionClass, String aggregateType) {\n        Projection projection = context.getBean(projectionClass);\n\n        // Clear existing projection data\n        projection.reset();\n\n        // Stream events from beginning\n        long position = 0;\n        int batchSize = 1000;\n        List\u0026#x3C;DomainEvent\u003e batch;\n\n        do {\n            batch = eventStore.loadAll(aggregateType, position, batchSize);\n            batch.forEach(event -\u003e {\n                try {\n                    projection.apply(event);\n                } catch (Exception e) {\n                    log.error(\"Failed to apply event {} to projection {}\",\n                        event.getId(), projectionClass.getSimpleName(), e);\n                }\n            });\n            position += batch.size();\n        } while (batch.size() == batchSize);\n\n        log.info(\"Rebuilt projection {} with {} events\", projectionClass.getSimpleName(), position);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor millions of events, rebuilding in-process is too slow. Use a dedicated rebuild pipeline: stream events from the store to Kafka, run projection workers at full throughput in parallel.\u003c/p\u003e\n\u003ch2\u003eSchema Evolution\u003c/h2\u003e\n\u003cp\u003eEvents are immutable. Once committed, the \u003ccode\u003eOrderPlacedEvent\u003c/code\u003e from 2022 cannot be changed. But your schema will evolve. Handle this with upcasters ‚Äî functions that transform old event versions to the current format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface EventUpcaster\u0026#x3C;T extends DomainEvent\u003e {\n    int fromVersion();\n    T upcast(JsonNode rawEvent);\n}\n\n@Component\npublic class OrderPlacedEventV1ToV2Upcaster implements EventUpcaster\u0026#x3C;OrderPlacedEvent\u003e {\n\n    @Override\n    public int fromVersion() { return 1; }\n\n    @Override\n    public OrderPlacedEvent upcast(JsonNode rawEvent) {\n        // V1 had 'customer_id', V2 renamed to 'user_id'\n        ObjectNode upgraded = rawEvent.deepCopy();\n        upgraded.put(\"user_id\", rawEvent.get(\"customer_id\").asText());\n        upgraded.remove(\"customer_id\");\n        return objectMapper.treeToValue(upgraded, OrderPlacedEvent.class);\n    }\n}\n\n// Event serialization layer applies upcasters transparently:\npublic DomainEvent deserialize(StoredEvent stored) {\n    DomainEvent event = objectMapper.readValue(stored.getData(), getDomainEventClass(stored.getEventType()));\n    return upcasterRegistry.upcastChain(event, stored.getEventVersion(), currentVersion());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Operational Challenges Nobody Talks About\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e1. Event store grows unboundedly.\u003c/strong\u003e Unlike a state-based system where you UPDATE rows, event sourcing only INSERTs. A system with 100 commands/second generates 8.6M events/day. After 1 year: 3.1B events. Plan for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eArchival: move events older than N years to cold storage (S3 + Parquet)\u003c/li\u003e\n\u003cli\u003eIndex maintenance: \u003ccode\u003edomain_events\u003c/code\u003e index grows with the table\u003c/li\u003e\n\u003cli\u003eBackup strategies: event stores are large\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. Eventual consistency between write and read models.\u003c/strong\u003e After a command executes, the projection may not be updated for tens of milliseconds. API clients reading immediately after a write may see stale data. Options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReturn event data directly in command response (avoid the read model for the \"write response\")\u003c/li\u003e\n\u003cli\u003eClient polls until the projection catches up (pessimistic, bad UX)\u003c/li\u003e\n\u003cli\u003eOptimistic UI updates (update UI before projection confirms)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3. Process manager complexity.\u003c/strong\u003e Long-running business processes (order fulfillment, subscription renewals) require sagas that span multiple aggregates. These are stateful and must handle partial failures. The saga state machine itself needs an event log to be recoverable.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4. Querying across aggregates.\u003c/strong\u003e The event store is aggregate-centric. \"Give me all orders placed in the last 24 hours over $500\" requires a projection. Every new query pattern potentially needs a new projection. Plan your read model database carefully.\u003c/p\u003e\n\u003ch2\u003eWhen Event Sourcing is Worth It\u003c/h2\u003e\n\u003cp\u003eEvent sourcing is excellent for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDomains with audit requirements (finance, healthcare, compliance)\u003c/li\u003e\n\u003cli\u003eComplex domain logic where understanding \"how did we get here\" matters\u003c/li\u003e\n\u003cli\u003eSystems that benefit from temporal queries (state at any point in time)\u003c/li\u003e\n\u003cli\u003eHigh-throughput write paths (append-only is fast)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt adds complexity that rarely pays off for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSimple CRUD systems\u003c/li\u003e\n\u003cli\u003eSystems without audit requirements\u003c/li\u003e\n\u003cli\u003eSmall teams without DDD expertise\u003c/li\u003e\n\u003cli\u003eServices with simple, flat domain models\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe decision should be per-domain, not per-system. Your order management service might benefit from event sourcing; your user profile service almost certainly doesn't.\u003c/p\u003e\n","tableOfContents":[{"id":"the-event-store-core-design","text":"The Event Store: Core Design","level":2},{"id":"snapshot-strategy","text":"Snapshot Strategy","level":2},{"id":"cqrs-separate-read-and-write-models","text":"CQRS: Separate Read and Write Models","level":2},{"id":"projection-rebuilding","text":"Projection Rebuilding","level":2},{"id":"schema-evolution","text":"Schema Evolution","level":2},{"id":"the-operational-challenges-nobody-talks-about","text":"The Operational Challenges Nobody Talks About","level":2},{"id":"when-event-sourcing-is-worth-it","text":"When Event Sourcing is Worth It","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why ‚Äî by exploring system state through metrics, traces, and logs without needing to know in advance‚Ä¶"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t‚Ä¶"},{"title":"Multi-Tenancy Architecture: Database, Application, and Infrastructure Patterns","description":"Production multi-tenancy: database isolation models (shared schema, shared database, separate database), tenant routing, data partitioning strategies, cross-tenant query prevention, Spring Boot tenant context propagation, and the trade-offs at each isolation level.","date":"2025-05-24","category":"System Design","tags":["multi-tenancy","saas","system design","database","spring boot","architecture","isolation"],"featured":false,"affiliateSection":"system-design-courses","slug":"multi-tenancy-architecture","readingTime":"8 min read","excerpt":"Multi-tenancy is the architecture pattern where a single deployed instance of a software system serves multiple customers (tenants), with each tenant's data logically or physically isolated from others. It's the foundati‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"event-sourcing-cqrs-production"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>