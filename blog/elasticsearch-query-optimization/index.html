<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Elasticsearch Query Optimization: From Slow to Sub-100ms<!-- --> | CodeSprintPro</title><meta name="description" content="Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/elasticsearch-query-optimization/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Elasticsearch Query Optimization: From Slow to Sub-100ms" data-next-head=""/><meta property="og:description" content="Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/elasticsearch-query-optimization/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-05-29" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="elasticsearch" data-next-head=""/><meta property="article:tag" content="search" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta property="article:tag" content="indexing" data-next-head=""/><meta property="article:tag" content="aggregations" data-next-head=""/><meta property="article:tag" content="kibana" data-next-head=""/><meta property="article:tag" content="spring boot" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Elasticsearch Query Optimization: From Slow to Sub-100ms" data-next-head=""/><meta name="twitter:description" content="Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elasticsearch Query Optimization: From Slow to Sub-100ms","description":"Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-05-29","dateModified":"2025-05-29","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/elasticsearch-query-optimization/"},"keywords":"elasticsearch, search, performance, indexing, aggregations, kibana, spring boot","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Elasticsearch Query Optimization: From Slow to Sub-100ms</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Elasticsearch Query Optimization: From Slow to Sub-100ms</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>May 29, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->elasticsearch</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->search</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->indexing</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->aggregations</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->kibana</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->spring boot</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Elasticsearch is a distributed search and analytics engine built on top of Apache Lucene. At small scale, it's fast regardless of what you do. At production scale ‚Äî billions of documents, hundreds of concurrent queries, real-time indexing ‚Äî the difference between a well-tuned cluster and a poorly configured one is 10-100√ó in query latency. Most Elasticsearch performance problems are caused by a small set of well-understood mistakes.</p>
<h2>Query Context vs. Filter Context</h2>
<p>The single most impactful optimization: use filter context instead of query context wherever relevance scoring is not needed.</p>
<pre><code class="language-json">// SLOW: Query context ‚Äî calculates relevance scores for every document
GET /orders/_search
{
  "query": {
    "bool": {
      "must": [
        { "term": { "status": "pending" } },
        { "term": { "region": "us-east-1" } },
        { "range": { "created_at": { "gte": "2025-01-01" } } }
      ]
    }
  }
}

// FAST: Filter context ‚Äî binary match/no-match, results are CACHED
GET /orders/_search
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "status": "pending" } },
        { "term": { "region": "us-east-1" } },
        { "range": { "created_at": { "gte": "2025-01-01" } } }
      ]
    }
  }
}
</code></pre>
<p>Filter context differences from query context:</p>
<ol>
<li><strong>No scoring</strong> ‚Äî filters are true/false, no TF-IDF calculation</li>
<li><strong>Cached</strong> ‚Äî Elasticsearch caches filter results in the filter cache (not query cache)</li>
<li><strong>Faster</strong> ‚Äî 2-10√ó faster for exact-value and range queries</li>
</ol>
<p>Rule: put <code>must</code> clauses in <code>filter</code> unless you actually need relevance ranking. Use <code>must</code> (query context) only for full-text search where you need <code>_score</code>.</p>
<pre><code class="language-json">// Correct hybrid: full-text search with filters
{
  "query": {
    "bool": {
      "must": [
        { "match": { "description": "blue running shoes" } }  // Query context: scoring needed
      ],
      "filter": [
        { "term": { "in_stock": true } },                    // Filter context: no scoring
        { "range": { "price": { "lte": 100 } } }
      ]
    }
  }
}
</code></pre>
<h2>Mapping Optimization: Disable What You Don't Need</h2>
<p>Elasticsearch's default dynamic mapping indexes everything with maximum flexibility. In production, disable features you don't use:</p>
<pre><code class="language-json">PUT /orders
{
  "mappings": {
    "dynamic": "strict",  // Reject unknown fields (don't silently index new fields)
    "properties": {
      "order_id": {
        "type": "keyword"  // Exact match ‚Äî don't use 'text' for IDs
      },
      "status": {
        "type": "keyword",
        "doc_values": true,  // For sorting/aggregations (default true for keyword)
        "index": true        // For filtering (default true)
      },
      "description": {
        "type": "text",
        "index": true,
        "doc_values": false,  // Text fields can't be aggregated anyway
        "norms": false,       // Disable length normalization if not needed
        "index_options": "docs"  // 'docs' &#x3C; 'freqs' &#x3C; 'positions' &#x3C; 'offsets' (ascending cost)
      },
      "user_id": {
        "type": "keyword",
        "index": true,
        "doc_values": false   // No aggregations on user_id ‚Üí disable doc_values (saves heap)
      },
      "internal_notes": {
        "type": "text",
        "index": false        // Store the field but don't index it (can't search, can retrieve)
      },
      "created_at": {
        "type": "date",
        "format": "strict_date_optional_time"
      },
      "amount_cents": {
        "type": "long"
      }
    }
  }
}
</code></pre>
<p><strong>doc_values vs fielddata:</strong></p>
<p>For aggregations and sorting on <code>keyword</code> fields: use <code>doc_values</code> (default on, stored on disk, low heap impact).</p>
<p>For aggregations on <code>text</code> fields: requires <code>fielddata: true</code> ‚Äî this loads the entire inverted index into heap memory. On a large index, this can OOM your cluster.</p>
<pre><code class="language-json">// DANGEROUS: Enabling fielddata on a high-cardinality text field
PUT /orders/_mapping
{
  "properties": {
    "description": {
      "type": "text",
      "fielddata": true  // Loads all text terms into heap ‚Äî can cause OOM
    }
  }
}

// CORRECT: Use a multi-field ‚Äî text for searching, keyword for aggregating
"product_name": {
  "type": "text",
  "fields": {
    "keyword": {           // product_name.keyword ‚Üí exact match + aggregations
      "type": "keyword",
      "ignore_above": 256  // Don't index very long strings as keyword
    }
  }
}
</code></pre>
<h2>Shard Sizing: The Root Cause of Most Performance Problems</h2>
<p>Shards are the unit of parallelism in Elasticsearch. Too few: can't parallelize. Too many: excessive overhead.</p>
<pre><code>Shard sizing guidelines:
- Target: 10-50GB per shard
- Too small (&#x3C; 1GB): overhead per shard dominates, cluster management expensive
- Too large (> 50GB): recovery time after node failure is too long

Common mistake: 5 shards √ó 1 replica = 10 shards for an index with 1GB of data
‚Üí Each shard: 100MB ‚Äî massive overhead
‚Üí Should be 1 shard or reduce replica count

Calculation example:
Index: product catalog
Data: 50GB expected
Shards: 50GB √∑ 30GB target = ~2 primary shards
Replicas: 1 (for redundancy)
Total: 4 shards across cluster

Number of shards also determines maximum parallelism for a single query:
A query hits all shards ‚Äî 2 shards = query runs on 2 nodes in parallel
</code></pre>
<p><strong>You cannot change the number of primary shards without reindexing.</strong> Set it correctly when creating the index. For time-based data, use ILM (Index Lifecycle Management) instead of one giant index.</p>
<h2>Index Lifecycle Management (ILM) for Time-Series Data</h2>
<pre><code class="language-json">// ILM policy: roll over active index when it hits 50GB or 30 days
PUT _ilm/policy/logs-policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50GB",
            "max_age": "30d"
          },
          "set_priority": { "priority": 100 }
        }
      },
      "warm": {
        "min_age": "30d",
        "actions": {
          "shrink": { "number_of_shards": 1 },   // Reduce to 1 shard (read-only)
          "forcemerge": { "max_num_segments": 1 }, // Merge to 1 segment (fast reads)
          "set_priority": { "priority": 50 }
        }
      },
      "cold": {
        "min_age": "90d",
        "actions": {
          "freeze": {}     // Minimize memory usage ‚Äî slow to query but searchable
        }
      },
      "delete": {
        "min_age": "365d",
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
</code></pre>
<p>Forcemerge in the warm phase reduces each index from many small segments (created during heavy indexing) to a single segment. Single-segment indexes are faster to read because Lucene doesn't need to merge results from multiple segments.</p>
<h2>Aggregation Performance</h2>
<pre><code class="language-json">// SLOW: Aggregation on a high-cardinality text field with fielddata
// FAST: Aggregation on a keyword field with doc_values

// Cardinality aggregation (approximate count of unique values):
GET /orders/_search
{
  "size": 0,  // Don't return hits, just aggregation results
  "aggs": {
    "unique_customers": {
      "cardinality": {
        "field": "user_id",
        "precision_threshold": 40000  // Higher = more accurate, more memory (max 40000)
      }
    }
  }
}

// Date histogram for time-series data:
GET /orders/_search
{
  "size": 0,
  "query": {
    "bool": {
      "filter": [
        { "range": { "created_at": { "gte": "now-30d/d", "lte": "now/d" } } }
      ]
    }
  },
  "aggs": {
    "orders_over_time": {
      "date_histogram": {
        "field": "created_at",
        "calendar_interval": "1d",
        "time_zone": "UTC"
      },
      "aggs": {
        "total_revenue": {
          "sum": { "field": "amount_cents" }
        }
      }
    }
  }
}
</code></pre>
<p><strong>Aggregation optimization techniques:</strong></p>
<ol>
<li><strong>Filter before aggregating</strong> ‚Äî use <code>query.bool.filter</code> to reduce the document set before running aggregations</li>
<li><strong>Use <code>size: 0</code></strong> ‚Äî if you only need aggregation results, don't fetch any hits (eliminates top-N scoring overhead)</li>
<li><strong>Limit terms aggregation size</strong> ‚Äî <code>"terms": {"field": "status", "size": 10}</code> ‚Äî default size is 10, but large sizes (> 10,000) are expensive</li>
<li><strong>Shard-level aggregation</strong> ‚Äî Elasticsearch aggregates on each shard, then merges. More shards = more parallel aggregation = faster for large datasets</li>
</ol>
<h2>Query Profiling</h2>
<p>Use the Profile API to understand where time goes:</p>
<pre><code class="language-json">GET /orders/_search
{
  "profile": true,
  "query": {
    "bool": {
      "filter": [
        { "term": { "status": "pending" } },
        { "range": { "created_at": { "gte": "now-1d" } } }
      ]
    }
  }
}

// Profile response (simplified):
{
  "profile": {
    "shards": [{
      "searches": [{
        "query": [{
          "type": "BooleanQuery",
          "description": "+status:pending +created_at:[...]",
          "time_in_nanos": 1532000,  // 1.5ms ‚Äî whole query
          "breakdown": {
            "create_weight": 450000,
            "build_scorer": 380000,
            "next_doc": 420000,
            "score": 80000,          // 0ms ‚Äî filter context, no scoring
            "advance": 120000
          },
          "children": [...]
        }]
      }]
    }]
  }
}
</code></pre>
<p>High <code>create_weight</code> time often indicates an expensive <code>must</code> clause that should be moved to <code>filter</code>. High <code>next_doc</code> time indicates iterating many documents ‚Äî consider if the index is missing a useful field for filtering.</p>
<h2>Bulk Indexing Optimization</h2>
<pre><code class="language-java">// Spring Data Elasticsearch ‚Äî bulk indexing:
@Service
public class ProductIndexService {

    @Autowired
    private ElasticsearchOperations operations;

    public void bulkIndex(List&#x3C;Product> products) {
        List&#x3C;IndexQuery> queries = products.stream()
            .map(product -> new IndexQueryBuilder()
                .withId(product.getId().toString())
                .withObject(product)
                .build())
            .collect(Collectors.toList());

        operations.bulkIndex(queries, IndexCoordinates.of("products"));
    }
}

// Optimal bulk indexing settings (disable during bulk load):
PUT /products/_settings
{
  "settings": {
    "refresh_interval": "-1",        // Disable auto-refresh during bulk load
    "number_of_replicas": "0"        // No replicas during load (re-enable after)
  }
}
// After bulk load completes:
PUT /products/_settings
{
  "settings": {
    "refresh_interval": "30s",       // Or "1s" for near-real-time search
    "number_of_replicas": "1"
  }
}
POST /products/_forcemerge?max_num_segments=5  // Merge segments after bulk load
</code></pre>
<p><strong>Index refresh_interval:</strong> Every 1 second (default), Elasticsearch makes new documents searchable by refreshing the in-memory buffer to disk. Each refresh creates a new Lucene segment. Too many small segments ‚Üí slow searches. During bulk indexing, set <code>refresh_interval: -1</code> to batch many documents into fewer, larger segments. After loading, set to <code>30s</code> or <code>1s</code> depending on your freshness requirement.</p>
<h2>Java Client Configuration</h2>
<pre><code class="language-java">@Configuration
public class ElasticsearchConfig {

    @Bean
    public ElasticsearchClient elasticsearchClient() {
        RestClient restClient = RestClient.builder(
            new HttpHost("es-cluster.example.com", 9200, "https")
        )
        .setRequestConfigCallback(config -> config
            .setConnectTimeout(5000)
            .setSocketTimeout(30000)   // Allow time for complex queries
        )
        .setHttpClientConfigCallback(httpClient -> httpClient
            .setMaxConnTotal(50)           // Connection pool size
            .setMaxConnPerRoute(50)
        )
        .build();

        ElasticsearchTransport transport = new RestClientTransport(
            restClient, new JacksonJsonpMapper());

        return new ElasticsearchClient(transport);
    }
}
</code></pre>
<p>The path to fast Elasticsearch queries is systematic: understand why filter context is cached, map only what you query, size shards to 10-50GB, let ILM manage index rollover, profile slow queries to find the expensive clause, and use bulk API with refresh disabled for heavy indexing. Each optimization compounds ‚Äî a well-mapped index in filter context on properly-sized shards can be 10-50√ó faster than the same data with default settings.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Elasticsearch%20Query%20Optimization%3A%20From%20Slow%20to%20Sub-100ms&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Felasticsearch-query-optimization%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Felasticsearch-query-optimization%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#query-context-vs-filter-context" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Query Context vs. Filter Context</a></li><li class=""><a href="#mapping-optimization-disable-what-you-dont-need" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Mapping Optimization: Disable What You Don&#x27;t Need</a></li><li class=""><a href="#shard-sizing-the-root-cause-of-most-performance-problems" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Shard Sizing: The Root Cause of Most Performance Problems</a></li><li class=""><a href="#index-lifecycle-management-ilm-for-time-series-data" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Lifecycle Management (ILM) for Time-Series Data</a></li><li class=""><a href="#aggregation-performance" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Aggregation Performance</a></li><li class=""><a href="#query-profiling" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Query Profiling</a></li><li class=""><a href="#bulk-indexing-optimization" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Bulk Indexing Optimization</a></li><li class=""><a href="#java-client-configuration" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Java Client Configuration</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there&#x27;s no primary, and data placement is determined by partit‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Elasticsearch Query Optimization: From Slow to Sub-100ms","description":"Elasticsearch performance tuning in production: query vs filter context, mapping optimization, shard sizing strategy, field data vs doc values, aggregation performance, index lifecycle management, and the profiling tools that identify bottlenecks.","date":"2025-05-29","category":"Databases","tags":["elasticsearch","search","performance","indexing","aggregations","kibana","spring boot"],"featured":false,"affiliateSection":"database-resources","slug":"elasticsearch-query-optimization","readingTime":"8 min read","excerpt":"Elasticsearch is a distributed search and analytics engine built on top of Apache Lucene. At small scale, it's fast regardless of what you do. At production scale ‚Äî billions of documents, hundreds of concurrent queries, ‚Ä¶","contentHtml":"\u003cp\u003eElasticsearch is a distributed search and analytics engine built on top of Apache Lucene. At small scale, it's fast regardless of what you do. At production scale ‚Äî billions of documents, hundreds of concurrent queries, real-time indexing ‚Äî the difference between a well-tuned cluster and a poorly configured one is 10-100√ó in query latency. Most Elasticsearch performance problems are caused by a small set of well-understood mistakes.\u003c/p\u003e\n\u003ch2\u003eQuery Context vs. Filter Context\u003c/h2\u003e\n\u003cp\u003eThe single most impactful optimization: use filter context instead of query context wherever relevance scoring is not needed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// SLOW: Query context ‚Äî calculates relevance scores for every document\nGET /orders/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"term\": { \"status\": \"pending\" } },\n        { \"term\": { \"region\": \"us-east-1\" } },\n        { \"range\": { \"created_at\": { \"gte\": \"2025-01-01\" } } }\n      ]\n    }\n  }\n}\n\n// FAST: Filter context ‚Äî binary match/no-match, results are CACHED\nGET /orders/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"term\": { \"status\": \"pending\" } },\n        { \"term\": { \"region\": \"us-east-1\" } },\n        { \"range\": { \"created_at\": { \"gte\": \"2025-01-01\" } } }\n      ]\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFilter context differences from query context:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eNo scoring\u003c/strong\u003e ‚Äî filters are true/false, no TF-IDF calculation\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCached\u003c/strong\u003e ‚Äî Elasticsearch caches filter results in the filter cache (not query cache)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFaster\u003c/strong\u003e ‚Äî 2-10√ó faster for exact-value and range queries\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eRule: put \u003ccode\u003emust\u003c/code\u003e clauses in \u003ccode\u003efilter\u003c/code\u003e unless you actually need relevance ranking. Use \u003ccode\u003emust\u003c/code\u003e (query context) only for full-text search where you need \u003ccode\u003e_score\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Correct hybrid: full-text search with filters\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"description\": \"blue running shoes\" } }  // Query context: scoring needed\n      ],\n      \"filter\": [\n        { \"term\": { \"in_stock\": true } },                    // Filter context: no scoring\n        { \"range\": { \"price\": { \"lte\": 100 } } }\n      ]\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMapping Optimization: Disable What You Don't Need\u003c/h2\u003e\n\u003cp\u003eElasticsearch's default dynamic mapping indexes everything with maximum flexibility. In production, disable features you don't use:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003ePUT /orders\n{\n  \"mappings\": {\n    \"dynamic\": \"strict\",  // Reject unknown fields (don't silently index new fields)\n    \"properties\": {\n      \"order_id\": {\n        \"type\": \"keyword\"  // Exact match ‚Äî don't use 'text' for IDs\n      },\n      \"status\": {\n        \"type\": \"keyword\",\n        \"doc_values\": true,  // For sorting/aggregations (default true for keyword)\n        \"index\": true        // For filtering (default true)\n      },\n      \"description\": {\n        \"type\": \"text\",\n        \"index\": true,\n        \"doc_values\": false,  // Text fields can't be aggregated anyway\n        \"norms\": false,       // Disable length normalization if not needed\n        \"index_options\": \"docs\"  // 'docs' \u0026#x3C; 'freqs' \u0026#x3C; 'positions' \u0026#x3C; 'offsets' (ascending cost)\n      },\n      \"user_id\": {\n        \"type\": \"keyword\",\n        \"index\": true,\n        \"doc_values\": false   // No aggregations on user_id ‚Üí disable doc_values (saves heap)\n      },\n      \"internal_notes\": {\n        \"type\": \"text\",\n        \"index\": false        // Store the field but don't index it (can't search, can retrieve)\n      },\n      \"created_at\": {\n        \"type\": \"date\",\n        \"format\": \"strict_date_optional_time\"\n      },\n      \"amount_cents\": {\n        \"type\": \"long\"\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003edoc_values vs fielddata:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor aggregations and sorting on \u003ccode\u003ekeyword\u003c/code\u003e fields: use \u003ccode\u003edoc_values\u003c/code\u003e (default on, stored on disk, low heap impact).\u003c/p\u003e\n\u003cp\u003eFor aggregations on \u003ccode\u003etext\u003c/code\u003e fields: requires \u003ccode\u003efielddata: true\u003c/code\u003e ‚Äî this loads the entire inverted index into heap memory. On a large index, this can OOM your cluster.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// DANGEROUS: Enabling fielddata on a high-cardinality text field\nPUT /orders/_mapping\n{\n  \"properties\": {\n    \"description\": {\n      \"type\": \"text\",\n      \"fielddata\": true  // Loads all text terms into heap ‚Äî can cause OOM\n    }\n  }\n}\n\n// CORRECT: Use a multi-field ‚Äî text for searching, keyword for aggregating\n\"product_name\": {\n  \"type\": \"text\",\n  \"fields\": {\n    \"keyword\": {           // product_name.keyword ‚Üí exact match + aggregations\n      \"type\": \"keyword\",\n      \"ignore_above\": 256  // Don't index very long strings as keyword\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eShard Sizing: The Root Cause of Most Performance Problems\u003c/h2\u003e\n\u003cp\u003eShards are the unit of parallelism in Elasticsearch. Too few: can't parallelize. Too many: excessive overhead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eShard sizing guidelines:\n- Target: 10-50GB per shard\n- Too small (\u0026#x3C; 1GB): overhead per shard dominates, cluster management expensive\n- Too large (\u003e 50GB): recovery time after node failure is too long\n\nCommon mistake: 5 shards √ó 1 replica = 10 shards for an index with 1GB of data\n‚Üí Each shard: 100MB ‚Äî massive overhead\n‚Üí Should be 1 shard or reduce replica count\n\nCalculation example:\nIndex: product catalog\nData: 50GB expected\nShards: 50GB √∑ 30GB target = ~2 primary shards\nReplicas: 1 (for redundancy)\nTotal: 4 shards across cluster\n\nNumber of shards also determines maximum parallelism for a single query:\nA query hits all shards ‚Äî 2 shards = query runs on 2 nodes in parallel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eYou cannot change the number of primary shards without reindexing.\u003c/strong\u003e Set it correctly when creating the index. For time-based data, use ILM (Index Lifecycle Management) instead of one giant index.\u003c/p\u003e\n\u003ch2\u003eIndex Lifecycle Management (ILM) for Time-Series Data\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// ILM policy: roll over active index when it hits 50GB or 30 days\nPUT _ilm/policy/logs-policy\n{\n  \"policy\": {\n    \"phases\": {\n      \"hot\": {\n        \"actions\": {\n          \"rollover\": {\n            \"max_size\": \"50GB\",\n            \"max_age\": \"30d\"\n          },\n          \"set_priority\": { \"priority\": 100 }\n        }\n      },\n      \"warm\": {\n        \"min_age\": \"30d\",\n        \"actions\": {\n          \"shrink\": { \"number_of_shards\": 1 },   // Reduce to 1 shard (read-only)\n          \"forcemerge\": { \"max_num_segments\": 1 }, // Merge to 1 segment (fast reads)\n          \"set_priority\": { \"priority\": 50 }\n        }\n      },\n      \"cold\": {\n        \"min_age\": \"90d\",\n        \"actions\": {\n          \"freeze\": {}     // Minimize memory usage ‚Äî slow to query but searchable\n        }\n      },\n      \"delete\": {\n        \"min_age\": \"365d\",\n        \"actions\": {\n          \"delete\": {}\n        }\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eForcemerge in the warm phase reduces each index from many small segments (created during heavy indexing) to a single segment. Single-segment indexes are faster to read because Lucene doesn't need to merge results from multiple segments.\u003c/p\u003e\n\u003ch2\u003eAggregation Performance\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// SLOW: Aggregation on a high-cardinality text field with fielddata\n// FAST: Aggregation on a keyword field with doc_values\n\n// Cardinality aggregation (approximate count of unique values):\nGET /orders/_search\n{\n  \"size\": 0,  // Don't return hits, just aggregation results\n  \"aggs\": {\n    \"unique_customers\": {\n      \"cardinality\": {\n        \"field\": \"user_id\",\n        \"precision_threshold\": 40000  // Higher = more accurate, more memory (max 40000)\n      }\n    }\n  }\n}\n\n// Date histogram for time-series data:\nGET /orders/_search\n{\n  \"size\": 0,\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"range\": { \"created_at\": { \"gte\": \"now-30d/d\", \"lte\": \"now/d\" } } }\n      ]\n    }\n  },\n  \"aggs\": {\n    \"orders_over_time\": {\n      \"date_histogram\": {\n        \"field\": \"created_at\",\n        \"calendar_interval\": \"1d\",\n        \"time_zone\": \"UTC\"\n      },\n      \"aggs\": {\n        \"total_revenue\": {\n          \"sum\": { \"field\": \"amount_cents\" }\n        }\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAggregation optimization techniques:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eFilter before aggregating\u003c/strong\u003e ‚Äî use \u003ccode\u003equery.bool.filter\u003c/code\u003e to reduce the document set before running aggregations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse \u003ccode\u003esize: 0\u003c/code\u003e\u003c/strong\u003e ‚Äî if you only need aggregation results, don't fetch any hits (eliminates top-N scoring overhead)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLimit terms aggregation size\u003c/strong\u003e ‚Äî \u003ccode\u003e\"terms\": {\"field\": \"status\", \"size\": 10}\u003c/code\u003e ‚Äî default size is 10, but large sizes (\u003e 10,000) are expensive\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eShard-level aggregation\u003c/strong\u003e ‚Äî Elasticsearch aggregates on each shard, then merges. More shards = more parallel aggregation = faster for large datasets\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eQuery Profiling\u003c/h2\u003e\n\u003cp\u003eUse the Profile API to understand where time goes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003eGET /orders/_search\n{\n  \"profile\": true,\n  \"query\": {\n    \"bool\": {\n      \"filter\": [\n        { \"term\": { \"status\": \"pending\" } },\n        { \"range\": { \"created_at\": { \"gte\": \"now-1d\" } } }\n      ]\n    }\n  }\n}\n\n// Profile response (simplified):\n{\n  \"profile\": {\n    \"shards\": [{\n      \"searches\": [{\n        \"query\": [{\n          \"type\": \"BooleanQuery\",\n          \"description\": \"+status:pending +created_at:[...]\",\n          \"time_in_nanos\": 1532000,  // 1.5ms ‚Äî whole query\n          \"breakdown\": {\n            \"create_weight\": 450000,\n            \"build_scorer\": 380000,\n            \"next_doc\": 420000,\n            \"score\": 80000,          // 0ms ‚Äî filter context, no scoring\n            \"advance\": 120000\n          },\n          \"children\": [...]\n        }]\n      }]\n    }]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHigh \u003ccode\u003ecreate_weight\u003c/code\u003e time often indicates an expensive \u003ccode\u003emust\u003c/code\u003e clause that should be moved to \u003ccode\u003efilter\u003c/code\u003e. High \u003ccode\u003enext_doc\u003c/code\u003e time indicates iterating many documents ‚Äî consider if the index is missing a useful field for filtering.\u003c/p\u003e\n\u003ch2\u003eBulk Indexing Optimization\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Spring Data Elasticsearch ‚Äî bulk indexing:\n@Service\npublic class ProductIndexService {\n\n    @Autowired\n    private ElasticsearchOperations operations;\n\n    public void bulkIndex(List\u0026#x3C;Product\u003e products) {\n        List\u0026#x3C;IndexQuery\u003e queries = products.stream()\n            .map(product -\u003e new IndexQueryBuilder()\n                .withId(product.getId().toString())\n                .withObject(product)\n                .build())\n            .collect(Collectors.toList());\n\n        operations.bulkIndex(queries, IndexCoordinates.of(\"products\"));\n    }\n}\n\n// Optimal bulk indexing settings (disable during bulk load):\nPUT /products/_settings\n{\n  \"settings\": {\n    \"refresh_interval\": \"-1\",        // Disable auto-refresh during bulk load\n    \"number_of_replicas\": \"0\"        // No replicas during load (re-enable after)\n  }\n}\n// After bulk load completes:\nPUT /products/_settings\n{\n  \"settings\": {\n    \"refresh_interval\": \"30s\",       // Or \"1s\" for near-real-time search\n    \"number_of_replicas\": \"1\"\n  }\n}\nPOST /products/_forcemerge?max_num_segments=5  // Merge segments after bulk load\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eIndex refresh_interval:\u003c/strong\u003e Every 1 second (default), Elasticsearch makes new documents searchable by refreshing the in-memory buffer to disk. Each refresh creates a new Lucene segment. Too many small segments ‚Üí slow searches. During bulk indexing, set \u003ccode\u003erefresh_interval: -1\u003c/code\u003e to batch many documents into fewer, larger segments. After loading, set to \u003ccode\u003e30s\u003c/code\u003e or \u003ccode\u003e1s\u003c/code\u003e depending on your freshness requirement.\u003c/p\u003e\n\u003ch2\u003eJava Client Configuration\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Configuration\npublic class ElasticsearchConfig {\n\n    @Bean\n    public ElasticsearchClient elasticsearchClient() {\n        RestClient restClient = RestClient.builder(\n            new HttpHost(\"es-cluster.example.com\", 9200, \"https\")\n        )\n        .setRequestConfigCallback(config -\u003e config\n            .setConnectTimeout(5000)\n            .setSocketTimeout(30000)   // Allow time for complex queries\n        )\n        .setHttpClientConfigCallback(httpClient -\u003e httpClient\n            .setMaxConnTotal(50)           // Connection pool size\n            .setMaxConnPerRoute(50)\n        )\n        .build();\n\n        ElasticsearchTransport transport = new RestClientTransport(\n            restClient, new JacksonJsonpMapper());\n\n        return new ElasticsearchClient(transport);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe path to fast Elasticsearch queries is systematic: understand why filter context is cached, map only what you query, size shards to 10-50GB, let ILM manage index rollover, profile slow queries to find the expensive clause, and use bulk API with refresh disabled for heavy indexing. Each optimization compounds ‚Äî a well-mapped index in filter context on properly-sized shards can be 10-50√ó faster than the same data with default settings.\u003c/p\u003e\n","tableOfContents":[{"id":"query-context-vs-filter-context","text":"Query Context vs. Filter Context","level":2},{"id":"mapping-optimization-disable-what-you-dont-need","text":"Mapping Optimization: Disable What You Don't Need","level":2},{"id":"shard-sizing-the-root-cause-of-most-performance-problems","text":"Shard Sizing: The Root Cause of Most Performance Problems","level":2},{"id":"index-lifecycle-management-ilm-for-time-series-data","text":"Index Lifecycle Management (ILM) for Time-Series Data","level":2},{"id":"aggregation-performance","text":"Aggregation Performance","level":2},{"id":"query-profiling","text":"Query Profiling","level":2},{"id":"bulk-indexing-optimization","text":"Bulk Indexing Optimization","level":2},{"id":"java-client-configuration","text":"Java Client Configuration","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"elasticsearch-query-optimization"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>