<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks<!-- --> | CodeSprintPro</title><meta name="description" content="Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/java-profiling-heap-analysis/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks" data-next-head=""/><meta property="og:description" content="Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/java-profiling-heap-analysis/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-05-09" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="profiling" data-next-head=""/><meta property="article:tag" content="heap analysis" data-next-head=""/><meta property="article:tag" content="memory leak" data-next-head=""/><meta property="article:tag" content="jvm" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta property="article:tag" content="async-profiler" data-next-head=""/><meta property="article:tag" content="gc" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks" data-next-head=""/><meta name="twitter:description" content="Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks","description":"Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-05-09","dateModified":"2025-05-09","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/java-profiling-heap-analysis/"},"keywords":"java, profiling, heap analysis, memory leak, jvm, performance, async-profiler, gc","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>May 9, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->profiling</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->heap analysis</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->memory leak</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->jvm</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->async-profiler</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->gc</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Java applications in production develop performance problems that don't reproduce locally: memory that grows slowly until OOM, GC pauses that spike P99 latency, threads that contend on a lock under load. The difference between an engineer who fixes these problems in hours versus days is knowing which tool to use and how to read what it shows.</p>
<h2>The Profiling Toolkit</h2>
<pre><code>Problem type ‚Üí Tool to use:
CPU bottleneck (high CPU, slow response)  ‚Üí async-profiler (CPU mode)
Memory leak (OOM, growing heap)           ‚Üí async-profiler (allocation) + heap dump + MAT
GC pressure (GC overhead, pauses)        ‚Üí GC logs + GCViewer / GC Easy
Thread contention (lock waits, deadlock) ‚Üí async-profiler (wall-clock mode) + thread dump
Latency spikes (P99 >> P50)              ‚Üí async-profiler + distributed tracing
Startup performance                       ‚Üí JVM startup flags + GraalVM profile
</code></pre>
<h2>async-profiler: Low-Overhead Production Profiling</h2>
<p><a href="https://github.com/async-profiler/async-profiler">async-profiler</a> is the best production-safe profiler for JVM applications. It uses AsyncGetCallTrace (bypasses safepoints ‚Äî true async sampling, no "safepoint bias" that makes synchronized code look fast) and perf_events for native stack frames.</p>
<p><strong>Installation and basic usage:</strong></p>
<pre><code class="language-bash"># Download:
wget https://github.com/async-profiler/async-profiler/releases/download/v3.0/async-profiler-3.0-linux-x64.tar.gz
tar xzf async-profiler-3.0-linux-x64.tar.gz

# Find target JVM PID:
jps -l
# ‚Üí 12345 com.example.OrderServiceApplication

# CPU profiling (30 seconds, flamegraph output):
./asprof -d 30 -f /tmp/cpu-profile.html 12345

# Allocation profiling (which code allocates the most memory):
./asprof -e alloc -d 30 -f /tmp/alloc-profile.html 12345

# Wall-clock profiling (including I/O and lock waits ‚Äî not just CPU):
./asprof -e wall -d 30 -f /tmp/wall-profile.html 12345

# Lock profiling (find lock contention):
./asprof -e lock -d 30 -f /tmp/lock-profile.html 12345
</code></pre>
<p><strong>Reading a flame graph:</strong></p>
<pre><code>Flame graph anatomy:

Y-axis: stack depth (bottom = thread entry, top = leaf frame where CPU is spent)
X-axis: time percentage (wider = more time spent in this frame and its callees)
Colors: arbitrary (but consistent ‚Äî same function same color)

Wide frames at the TOP are the bottleneck.
Wide frames in the MIDDLE are code paths that lead to the bottleneck.

Example: Wide frame "HashMap.get()" at top of many stacks
‚Üí All requests are spending time in HashMap.get()
‚Üí Could be: GC resizing (too-small initial capacity)
‚Üí Could be: Thread contention on a shared HashMap
‚Üí Look at the frame below: what's calling HashMap.get()?
</code></pre>
<p><strong>JVM flags to enable profiling in production:</strong></p>
<pre><code class="language-bash"># Add to JVM startup (low overhead, safe for production):
-XX:+UnlockDiagnosticVMOptions
-XX:+DebugNonSafepoints  # Required for async-profiler accuracy

# GC logging (essential ‚Äî always enable in production):
-Xlog:gc*:file=/var/log/app/gc.log:time,uptime:filecount=10,filesize=50m

# Enable JFR (Java Flight Recorder ‚Äî built-in profiler, low overhead):
-XX:+FlightRecorder
-XX:StartFlightRecording=duration=120s,filename=/tmp/recording.jfr
</code></pre>
<h2>Heap Dump Analysis with Eclipse MAT</h2>
<p>When memory grows and OOM is imminent, take a heap dump:</p>
<pre><code class="language-bash"># On running JVM:
jmap -dump:live,format=b,file=/tmp/heap.hprof 12345
# "live" ‚Äî only live objects (reachable from GC roots) ‚Äî smaller, more useful

# On OOM (add to JVM flags ‚Äî auto-dump on OOM):
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heap-dumps/
# Creates heap-dump-&#x3C;timestamp>.hprof on OOM

# Compress heap dump for transfer (heap dumps are large):
gzip /tmp/heap.hprof  # 10GB dump ‚Üí ~2GB compressed
</code></pre>
<p><strong>Eclipse MAT analysis workflow:</strong></p>
<pre><code>1. Open heap.hprof in Eclipse MAT

2. Overview tab: pie chart of object sizes
   ‚Üí Look for: one class consuming disproportionate heap (> 20%)

3. Leak Suspects report (MAT auto-generates):
   ‚Üí "One instance of com.example.RequestContext occupies 2.4GB (85%)"
   ‚Üí This is your leak

4. Dominator Tree: shows objects that retain the most heap
   ‚Üí Find the largest retained size objects
   ‚Üí Expand: what's inside? Why is it still referenced?

5. Histogram: list all object types by count and size
   ‚Üí Filter by count: char[] and byte[] at top = normal (String internals)
   ‚Üí "HashMap$Entry √ó 5,000,000" = possibly a growing cache / map

6. Paths to GC Roots: for a suspicious object, find what keeps it alive
   ‚Üí Right-click object ‚Üí "Merge Shortest Paths to GC Roots"
   ‚Üí Shows the chain of references keeping this object in memory
</code></pre>
<p><strong>Common memory leak patterns:</strong></p>
<pre><code class="language-java">// Pattern 1: Static map used as cache (never evicts)
public class ProductService {
    private static final Map&#x3C;Long, Product> cache = new HashMap&#x3C;>();

    public Product getProduct(long id) {
        return cache.computeIfAbsent(id, productRepo::findById);
        // Problem: cache grows forever ‚Äî every product ever queried is retained
    }
}
// Fix: Use Caffeine or Guava Cache with size limit and TTL

// Pattern 2: Event listener not deregistered
public class EventProcessor {
    @Autowired
    private EventBus eventBus;

    @PostConstruct
    public void init() {
        eventBus.register(this);  // Registers listener
        // Problem: if EventProcessor is prototype-scoped and created many times,
        // each instance is retained by eventBus forever ‚Üí memory leak
    }

    @PreDestroy
    public void cleanup() {
        eventBus.unregister(this);  // Fix: always deregister on destroy
    }
}

// Pattern 3: ThreadLocal not cleaned up
public class TenantContext {
    private static final ThreadLocal&#x3C;String> tenant = new ThreadLocal&#x3C;>();

    public static void set(String id) { tenant.set(id); }
    public static String get() { return tenant.get(); }

    // Missing: clear() called after request completes
    // In a thread pool, threads are reused ‚Äî ThreadLocal carries value to next request
    // If value is a large object: memory leak across requests
    public static void clear() { tenant.remove(); }  // Must be called in finally block
}
</code></pre>
<h2>GC Log Analysis</h2>
<p>GC logs reveal pause patterns, GC frequency, and heap sizing problems:</p>
<pre><code class="language-bash"># GC log enabled (JVM 11+ format):
-Xlog:gc*:file=/var/log/gc.log:time,uptime

# Sample GC log output:
[2025-01-15T10:23:45.123+0000][1234.567s] GC(42) Pause Young (Normal) (G1 Evacuation Pause)
  Eden: 512M->0M(512M)  Survivors: 32M->64M  Heap: 2048M->1536M(4096M)
  User=0.450s Sys=0.020s Real=0.047s  ‚Üê 47ms pause ‚Äî check if this is acceptable

# Problematic patterns to look for:
# 1. "Pause Full" (stop-the-world full GC) ‚Üí heap too small or memory leak
# 2. GC frequency increasing ‚Üí heap filling faster over time (leak)
# 3. Heap after GC increasing each time ‚Üí objects surviving that shouldn't
# 4. Very long pauses (> 500ms) ‚Üí GC tuning needed
</code></pre>
<p><strong>GC visualization with GCViewer:</strong></p>
<pre><code class="language-bash"># Parse GC log and show graphical analysis:
java -jar gcviewer.jar /var/log/gc.log
# Shows: pause time histogram, heap usage over time, GC throughput %
</code></pre>
<p><strong>Key GC metrics in Micrometer (Spring Boot Actuator):</strong></p>
<pre><code>jvm.gc.pause{action="end of minor GC", cause="G1 Evacuation Pause"}
jvm.gc.memory.allocated  ‚Üê Allocation rate (bytes/second)
jvm.gc.memory.promoted   ‚Üê Old gen promotion rate
jvm.memory.used{area="heap"}

Alert thresholds:
GC pause > 200ms (95th percentile) ‚Üí investigate
GC time > 5% of total time ‚Üí heap sizing issue
Old gen > 80% after full GC ‚Üí potential memory leak
</code></pre>
<h2>Thread Dump Analysis</h2>
<p>For hung applications and deadlocks:</p>
<pre><code class="language-bash"># Take thread dump:
jstack 12345 > /tmp/threads.txt

# Or via JVM signal:
kill -3 12345  # Prints thread dump to stdout (redirected from service logs)

# Thread dump shows each thread's state and stack:
"http-nio-8080-exec-42" #154 daemon prio=5
   java.lang.Thread.State: BLOCKED (on object monitor)
   ‚Üí waiting to lock &#x3C;0x00000006c0987a80> (a java.util.HashMap)
   ‚Üí held by "http-nio-8080-exec-3"

# This indicates: two request threads contending on a shared HashMap
# exec-3 holds the lock, exec-42 is waiting
# Fix: use ConcurrentHashMap or move to per-request scope
</code></pre>
<p><strong>fastthread.io:</strong> Upload thread dump for automated analysis ‚Äî identifies deadlocks, blocked threads, and contention patterns.</p>
<h2>CPU Profiling: Case Study</h2>
<p>Scenario: order service P99 latency jumped from 80ms to 800ms after a deploy. No OOM, memory looks fine.</p>
<pre><code class="language-bash"># 1. Capture CPU flame graph:
./asprof -d 60 -f /tmp/cpu.html $(pgrep -f OrderService)

# 2. Open flame graph, look for wide top frames:
# Found: 40% of CPU time in:
#   com.example.OrderService.calculateTotals
#   ‚Üí java.util.stream.Stream.sorted()
#   ‚Üí java.util.Arrays.mergeSort()

# This is suspicious ‚Äî why is sort taking 40% of CPU?

# 3. Check the code:
public BigDecimal calculateTotals(List&#x3C;OrderItem> items) {
    return items.stream()
        .sorted(Comparator.comparing(OrderItem::getPrice).reversed())  // ‚Üê sorting each time
        .map(OrderItem::getPrice)
        .reduce(BigDecimal.ZERO, BigDecimal::add);
}
</code></pre>
<p>The bug: <code>sorted()</code> was added "for display purposes" but calculateTotals doesn't need sorted items. The sort is O(n log n) per call. At 1,000 calls/second on a list of 100 items ‚Äî enormous wasted work.</p>
<p>Fix: remove the sort. P99 drops back to 85ms.</p>
<p>The tooling only reveals what you're looking for. But the pattern is consistent: CPU flame graph points to the hot function; code review explains why it's hot. async-profiler + 30 seconds of sampling + MAT for memory ‚Äî these tools find in minutes what weeks of log analysis won't.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass ‚Äî Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Java%20Profiling%20and%20Heap%20Analysis%3A%20Finding%20Memory%20Leaks%20and%20CPU%20Bottlenecks&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-profiling-heap-analysis%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-profiling-heap-analysis%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-profiling-toolkit" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Profiling Toolkit</a></li><li class=""><a href="#async-profiler-low-overhead-production-profiling" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">async-profiler: Low-Overhead Production Profiling</a></li><li class=""><a href="#heap-dump-analysis-with-eclipse-mat" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Heap Dump Analysis with Eclipse MAT</a></li><li class=""><a href="#gc-log-analysis" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">GC Log Analysis</a></li><li class=""><a href="#thread-dump-analysis" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Thread Dump Analysis</a></li><li class=""><a href="#cpu-profiling-case-study" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">CPU Profiling: Case Study</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-concurrency-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era&#x27;s patterns still exist in production codebases. Understanding all th‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->concurrency</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->completablefuture</span></div></article></a><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java Profiling and Heap Analysis: Finding Memory Leaks and CPU Bottlenecks","description":"Production Java profiling: async-profiler for CPU and allocation profiling, heap dump analysis with Eclipse MAT, finding memory leaks, GC log analysis, detecting thread contention, JVM flags for profiling in production, and reading flame graphs.","date":"2025-05-09","category":"Java","tags":["java","profiling","heap analysis","memory leak","jvm","performance","async-profiler","gc"],"featured":false,"affiliateSection":"java-courses","slug":"java-profiling-heap-analysis","readingTime":"7 min read","excerpt":"Java applications in production develop performance problems that don't reproduce locally: memory that grows slowly until OOM, GC pauses that spike P99 latency, threads that contend on a lock under load. The difference b‚Ä¶","contentHtml":"\u003cp\u003eJava applications in production develop performance problems that don't reproduce locally: memory that grows slowly until OOM, GC pauses that spike P99 latency, threads that contend on a lock under load. The difference between an engineer who fixes these problems in hours versus days is knowing which tool to use and how to read what it shows.\u003c/p\u003e\n\u003ch2\u003eThe Profiling Toolkit\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eProblem type ‚Üí Tool to use:\nCPU bottleneck (high CPU, slow response)  ‚Üí async-profiler (CPU mode)\nMemory leak (OOM, growing heap)           ‚Üí async-profiler (allocation) + heap dump + MAT\nGC pressure (GC overhead, pauses)        ‚Üí GC logs + GCViewer / GC Easy\nThread contention (lock waits, deadlock) ‚Üí async-profiler (wall-clock mode) + thread dump\nLatency spikes (P99 \u003e\u003e P50)              ‚Üí async-profiler + distributed tracing\nStartup performance                       ‚Üí JVM startup flags + GraalVM profile\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003easync-profiler: Low-Overhead Production Profiling\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/async-profiler/async-profiler\"\u003easync-profiler\u003c/a\u003e is the best production-safe profiler for JVM applications. It uses AsyncGetCallTrace (bypasses safepoints ‚Äî true async sampling, no \"safepoint bias\" that makes synchronized code look fast) and perf_events for native stack frames.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eInstallation and basic usage:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Download:\nwget https://github.com/async-profiler/async-profiler/releases/download/v3.0/async-profiler-3.0-linux-x64.tar.gz\ntar xzf async-profiler-3.0-linux-x64.tar.gz\n\n# Find target JVM PID:\njps -l\n# ‚Üí 12345 com.example.OrderServiceApplication\n\n# CPU profiling (30 seconds, flamegraph output):\n./asprof -d 30 -f /tmp/cpu-profile.html 12345\n\n# Allocation profiling (which code allocates the most memory):\n./asprof -e alloc -d 30 -f /tmp/alloc-profile.html 12345\n\n# Wall-clock profiling (including I/O and lock waits ‚Äî not just CPU):\n./asprof -e wall -d 30 -f /tmp/wall-profile.html 12345\n\n# Lock profiling (find lock contention):\n./asprof -e lock -d 30 -f /tmp/lock-profile.html 12345\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eReading a flame graph:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFlame graph anatomy:\n\nY-axis: stack depth (bottom = thread entry, top = leaf frame where CPU is spent)\nX-axis: time percentage (wider = more time spent in this frame and its callees)\nColors: arbitrary (but consistent ‚Äî same function same color)\n\nWide frames at the TOP are the bottleneck.\nWide frames in the MIDDLE are code paths that lead to the bottleneck.\n\nExample: Wide frame \"HashMap.get()\" at top of many stacks\n‚Üí All requests are spending time in HashMap.get()\n‚Üí Could be: GC resizing (too-small initial capacity)\n‚Üí Could be: Thread contention on a shared HashMap\n‚Üí Look at the frame below: what's calling HashMap.get()?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eJVM flags to enable profiling in production:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Add to JVM startup (low overhead, safe for production):\n-XX:+UnlockDiagnosticVMOptions\n-XX:+DebugNonSafepoints  # Required for async-profiler accuracy\n\n# GC logging (essential ‚Äî always enable in production):\n-Xlog:gc*:file=/var/log/app/gc.log:time,uptime:filecount=10,filesize=50m\n\n# Enable JFR (Java Flight Recorder ‚Äî built-in profiler, low overhead):\n-XX:+FlightRecorder\n-XX:StartFlightRecording=duration=120s,filename=/tmp/recording.jfr\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHeap Dump Analysis with Eclipse MAT\u003c/h2\u003e\n\u003cp\u003eWhen memory grows and OOM is imminent, take a heap dump:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# On running JVM:\njmap -dump:live,format=b,file=/tmp/heap.hprof 12345\n# \"live\" ‚Äî only live objects (reachable from GC roots) ‚Äî smaller, more useful\n\n# On OOM (add to JVM flags ‚Äî auto-dump on OOM):\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/tmp/heap-dumps/\n# Creates heap-dump-\u0026#x3C;timestamp\u003e.hprof on OOM\n\n# Compress heap dump for transfer (heap dumps are large):\ngzip /tmp/heap.hprof  # 10GB dump ‚Üí ~2GB compressed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eEclipse MAT analysis workflow:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. Open heap.hprof in Eclipse MAT\n\n2. Overview tab: pie chart of object sizes\n   ‚Üí Look for: one class consuming disproportionate heap (\u003e 20%)\n\n3. Leak Suspects report (MAT auto-generates):\n   ‚Üí \"One instance of com.example.RequestContext occupies 2.4GB (85%)\"\n   ‚Üí This is your leak\n\n4. Dominator Tree: shows objects that retain the most heap\n   ‚Üí Find the largest retained size objects\n   ‚Üí Expand: what's inside? Why is it still referenced?\n\n5. Histogram: list all object types by count and size\n   ‚Üí Filter by count: char[] and byte[] at top = normal (String internals)\n   ‚Üí \"HashMap$Entry √ó 5,000,000\" = possibly a growing cache / map\n\n6. Paths to GC Roots: for a suspicious object, find what keeps it alive\n   ‚Üí Right-click object ‚Üí \"Merge Shortest Paths to GC Roots\"\n   ‚Üí Shows the chain of references keeping this object in memory\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCommon memory leak patterns:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Pattern 1: Static map used as cache (never evicts)\npublic class ProductService {\n    private static final Map\u0026#x3C;Long, Product\u003e cache = new HashMap\u0026#x3C;\u003e();\n\n    public Product getProduct(long id) {\n        return cache.computeIfAbsent(id, productRepo::findById);\n        // Problem: cache grows forever ‚Äî every product ever queried is retained\n    }\n}\n// Fix: Use Caffeine or Guava Cache with size limit and TTL\n\n// Pattern 2: Event listener not deregistered\npublic class EventProcessor {\n    @Autowired\n    private EventBus eventBus;\n\n    @PostConstruct\n    public void init() {\n        eventBus.register(this);  // Registers listener\n        // Problem: if EventProcessor is prototype-scoped and created many times,\n        // each instance is retained by eventBus forever ‚Üí memory leak\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        eventBus.unregister(this);  // Fix: always deregister on destroy\n    }\n}\n\n// Pattern 3: ThreadLocal not cleaned up\npublic class TenantContext {\n    private static final ThreadLocal\u0026#x3C;String\u003e tenant = new ThreadLocal\u0026#x3C;\u003e();\n\n    public static void set(String id) { tenant.set(id); }\n    public static String get() { return tenant.get(); }\n\n    // Missing: clear() called after request completes\n    // In a thread pool, threads are reused ‚Äî ThreadLocal carries value to next request\n    // If value is a large object: memory leak across requests\n    public static void clear() { tenant.remove(); }  // Must be called in finally block\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eGC Log Analysis\u003c/h2\u003e\n\u003cp\u003eGC logs reveal pause patterns, GC frequency, and heap sizing problems:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# GC log enabled (JVM 11+ format):\n-Xlog:gc*:file=/var/log/gc.log:time,uptime\n\n# Sample GC log output:\n[2025-01-15T10:23:45.123+0000][1234.567s] GC(42) Pause Young (Normal) (G1 Evacuation Pause)\n  Eden: 512M-\u003e0M(512M)  Survivors: 32M-\u003e64M  Heap: 2048M-\u003e1536M(4096M)\n  User=0.450s Sys=0.020s Real=0.047s  ‚Üê 47ms pause ‚Äî check if this is acceptable\n\n# Problematic patterns to look for:\n# 1. \"Pause Full\" (stop-the-world full GC) ‚Üí heap too small or memory leak\n# 2. GC frequency increasing ‚Üí heap filling faster over time (leak)\n# 3. Heap after GC increasing each time ‚Üí objects surviving that shouldn't\n# 4. Very long pauses (\u003e 500ms) ‚Üí GC tuning needed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eGC visualization with GCViewer:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Parse GC log and show graphical analysis:\njava -jar gcviewer.jar /var/log/gc.log\n# Shows: pause time histogram, heap usage over time, GC throughput %\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eKey GC metrics in Micrometer (Spring Boot Actuator):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ejvm.gc.pause{action=\"end of minor GC\", cause=\"G1 Evacuation Pause\"}\njvm.gc.memory.allocated  ‚Üê Allocation rate (bytes/second)\njvm.gc.memory.promoted   ‚Üê Old gen promotion rate\njvm.memory.used{area=\"heap\"}\n\nAlert thresholds:\nGC pause \u003e 200ms (95th percentile) ‚Üí investigate\nGC time \u003e 5% of total time ‚Üí heap sizing issue\nOld gen \u003e 80% after full GC ‚Üí potential memory leak\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThread Dump Analysis\u003c/h2\u003e\n\u003cp\u003eFor hung applications and deadlocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Take thread dump:\njstack 12345 \u003e /tmp/threads.txt\n\n# Or via JVM signal:\nkill -3 12345  # Prints thread dump to stdout (redirected from service logs)\n\n# Thread dump shows each thread's state and stack:\n\"http-nio-8080-exec-42\" #154 daemon prio=5\n   java.lang.Thread.State: BLOCKED (on object monitor)\n   ‚Üí waiting to lock \u0026#x3C;0x00000006c0987a80\u003e (a java.util.HashMap)\n   ‚Üí held by \"http-nio-8080-exec-3\"\n\n# This indicates: two request threads contending on a shared HashMap\n# exec-3 holds the lock, exec-42 is waiting\n# Fix: use ConcurrentHashMap or move to per-request scope\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003efastthread.io:\u003c/strong\u003e Upload thread dump for automated analysis ‚Äî identifies deadlocks, blocked threads, and contention patterns.\u003c/p\u003e\n\u003ch2\u003eCPU Profiling: Case Study\u003c/h2\u003e\n\u003cp\u003eScenario: order service P99 latency jumped from 80ms to 800ms after a deploy. No OOM, memory looks fine.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 1. Capture CPU flame graph:\n./asprof -d 60 -f /tmp/cpu.html $(pgrep -f OrderService)\n\n# 2. Open flame graph, look for wide top frames:\n# Found: 40% of CPU time in:\n#   com.example.OrderService.calculateTotals\n#   ‚Üí java.util.stream.Stream.sorted()\n#   ‚Üí java.util.Arrays.mergeSort()\n\n# This is suspicious ‚Äî why is sort taking 40% of CPU?\n\n# 3. Check the code:\npublic BigDecimal calculateTotals(List\u0026#x3C;OrderItem\u003e items) {\n    return items.stream()\n        .sorted(Comparator.comparing(OrderItem::getPrice).reversed())  // ‚Üê sorting each time\n        .map(OrderItem::getPrice)\n        .reduce(BigDecimal.ZERO, BigDecimal::add);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe bug: \u003ccode\u003esorted()\u003c/code\u003e was added \"for display purposes\" but calculateTotals doesn't need sorted items. The sort is O(n log n) per call. At 1,000 calls/second on a list of 100 items ‚Äî enormous wasted work.\u003c/p\u003e\n\u003cp\u003eFix: remove the sort. P99 drops back to 85ms.\u003c/p\u003e\n\u003cp\u003eThe tooling only reveals what you're looking for. But the pattern is consistent: CPU flame graph points to the hot function; code review explains why it's hot. async-profiler + 30 seconds of sampling + MAT for memory ‚Äî these tools find in minutes what weeks of log analysis won't.\u003c/p\u003e\n","tableOfContents":[{"id":"the-profiling-toolkit","text":"The Profiling Toolkit","level":2},{"id":"async-profiler-low-overhead-production-profiling","text":"async-profiler: Low-Overhead Production Profiling","level":2},{"id":"heap-dump-analysis-with-eclipse-mat","text":"Heap Dump Analysis with Eclipse MAT","level":2},{"id":"gc-log-analysis","text":"GC Log Analysis","level":2},{"id":"thread-dump-analysis","text":"Thread Dump Analysis","level":2},{"id":"cpu-profiling-case-study","text":"CPU Profiling: Case Study","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th‚Ä¶"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-profiling-heap-analysis"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>