<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design<!-- --> | CodeSprintPro</title><meta name="description" content="Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/java-concurrency-patterns/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design" data-next-head=""/><meta property="og:description" content="Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/java-concurrency-patterns/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-07-08" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="concurrency" data-next-head=""/><meta property="article:tag" content="completablefuture" data-next-head=""/><meta property="article:tag" content="virtual threads" data-next-head=""/><meta property="article:tag" content="java21" data-next-head=""/><meta property="article:tag" content="thread-safe" data-next-head=""/><meta property="article:tag" content="async" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design" data-next-head=""/><meta name="twitter:description" content="Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-07-08","dateModified":"2025-07-08","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/java-concurrency-patterns/"},"keywords":"java, concurrency, completablefuture, virtual threads, java21, thread-safe, async","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>July 8, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->concurrency</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->completablefuture</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->virtual threads</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java21</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->thread-safe</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->async</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Java concurrency has three eras: raw <code>Thread</code> and <code>synchronized</code> (Java 1-4), the <code>java.util.concurrent</code> framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all three ‚Äî and knowing which to use when ‚Äî separates engineers who write concurrent code from engineers who write correct concurrent code.</p>
<h2>CompletableFuture: Composing Async Operations</h2>
<p><code>CompletableFuture</code> is the fundamental async primitive since Java 8. It represents a future value and provides a fluent API for transforming and combining async results.</p>
<pre><code class="language-java">// Parallel data fetching with CompletableFuture:
public OrderSummary buildOrderSummary(String orderId) {
    Executor executor = ForkJoinPool.commonPool(); // Or custom executor

    CompletableFuture&#x3C;Order> orderFuture = CompletableFuture
        .supplyAsync(() -> orderRepo.findById(orderId), executor);

    CompletableFuture&#x3C;Customer> customerFuture = orderFuture
        .thenApplyAsync(order -> customerRepo.findById(order.getCustomerId()), executor);

    CompletableFuture&#x3C;List&#x3C;Product>> productsFuture = orderFuture
        .thenApplyAsync(order ->
            productRepo.findAllById(order.getProductIds()), executor);

    CompletableFuture&#x3C;ShippingStatus> shippingFuture = orderFuture
        .thenApplyAsync(order ->
            shippingService.getStatus(order.getShipmentId()), executor);

    // Combine results (customer + products + shipping in parallel after order loads):
    return CompletableFuture.allOf(customerFuture, productsFuture, shippingFuture)
        .thenApply(v -> OrderSummary.builder()
            .order(orderFuture.join())
            .customer(customerFuture.join())
            .products(productsFuture.join())
            .shipping(shippingFuture.join())
            .build())
        .join();
}
</code></pre>
<p><code>orderFuture</code> runs first; <code>customerFuture</code>, <code>productsFuture</code>, and <code>shippingFuture</code> all start after <code>orderFuture</code> completes but run in parallel with each other. The total time is <code>order_fetch + max(customer, products, shipping)</code> instead of the sum.</p>
<p><strong>Exception handling in async chains:</strong></p>
<pre><code class="language-java">CompletableFuture&#x3C;PricingResult> priceFuture = CompletableFuture
    .supplyAsync(() -> pricingService.calculate(request))
    .exceptionally(ex -> {
        log.warn("Pricing service failed, using fallback: {}", ex.getMessage());
        return PricingResult.fallback(request.getBasePrice()); // Graceful degradation
    })
    .thenApply(pricing -> applyDiscounts(pricing))
    .handle((result, ex) -> {
        // handle() receives BOTH result and exception (either may be null)
        if (ex != null) {
            metrics.recordPricingError(ex);
            return PricingResult.fallback(request.getBasePrice());
        }
        metrics.recordPricingSuccess();
        return result;
    });
</code></pre>
<p><strong>Critical pitfall: join() blocks ‚Äî use carefully:</strong></p>
<pre><code class="language-java">// BAD: Calling join() inside an async chain on ForkJoinPool common pool
CompletableFuture.supplyAsync(() -> {
    // This is running on ForkJoinPool.commonPool()
    String result = anotherFuture.join(); // BLOCKS a ForkJoinPool thread
    // If all threads are blocked waiting for other futures: DEADLOCK
    return process(result);
});

// GOOD: Use thenCompose for chaining async operations:
CompletableFuture&#x3C;String> result = firstFuture
    .thenComposeAsync(value -> createSecondFuture(value), customExecutor);
</code></pre>
<h2>Custom Executors: Don't Use the Default</h2>
<p><code>ForkJoinPool.commonPool()</code> is shared across the entire JVM. In a Spring Boot application, Tomcat, Spring's <code>@Async</code>, CompletableFuture defaults, and parallel streams all compete for it. Use dedicated executors:</p>
<pre><code class="language-java">@Configuration
public class ExecutorConfig {

    @Bean("ioExecutor")
    public ExecutorService ioExecutor() {
        return new ThreadPoolExecutor(
            10,           // corePoolSize
            50,           // maximumPoolSize
            60, TimeUnit.SECONDS,
            new LinkedBlockingQueue&#x3C;>(200),  // bounded queue ‚Äî important!
            new ThreadFactoryBuilder()
                .setNameFormat("io-worker-%d")
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy()  // Backpressure: caller thread runs task
        );
    }

    @Bean("cpuExecutor")
    public ExecutorService cpuExecutor() {
        int cores = Runtime.getRuntime().availableProcessors();
        return Executors.newFixedThreadPool(cores,
            new ThreadFactoryBuilder().setNameFormat("cpu-worker-%d").build());
    }
}

// Usage:
CompletableFuture
    .supplyAsync(() -> fetchFromDatabase(id), ioExecutor)     // I/O bound
    .thenApplyAsync(data -> processData(data), cpuExecutor)  // CPU bound
    .thenApplyAsync(result -> saveResult(result), ioExecutor) // I/O bound
</code></pre>
<p><strong>Bounded queues are mandatory.</strong> An unbounded queue (<code>LinkedBlockingQueue()</code> with no capacity) allows tasks to queue indefinitely, consuming memory and masking backpressure problems. A bounded queue with <code>CallerRunsPolicy</code> provides natural backpressure: when the executor is full, the calling thread executes the task directly ‚Äî slowing the producer.</p>
<h2>Java 21 Structured Concurrency</h2>
<p>Structured concurrency (JEP 453, finalized in Java 21) makes concurrent task lifetime match lexical scope ‚Äî no task outlives its parent scope:</p>
<pre><code class="language-java">// Classic CompletableFuture: tasks can outlive scope, error handling is scattered
// Structured concurrency: all tasks within try-block, exceptions propagate cleanly

public OrderSummary buildSummary(String orderId) throws InterruptedException {
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        // Fork concurrent subtasks:
        Subtask&#x3C;Order> orderTask = scope.fork(() -> orderRepo.findById(orderId));
        Subtask&#x3C;Inventory> inventoryTask = scope.fork(() -> inventoryService.check(orderId));
        Subtask&#x3C;PriceResult> priceTask = scope.fork(() -> pricingService.calculate(orderId));

        // Wait for all tasks (or until one fails):
        scope.join()           // Wait for all
             .throwIfFailed(); // Throw if any failed (cancels remaining)

        // All tasks succeeded ‚Äî results are available:
        return OrderSummary.of(
            orderTask.get(),
            inventoryTask.get(),
            priceTask.get()
        );
    }
    // When try-block exits: ALL forked tasks are guaranteed to have completed
    // No task leaks, no partial results, clean cancellation
}
</code></pre>
<p><strong>ShutdownOnSuccess:</strong> Return the first successful result, cancel the rest (racing pattern):</p>
<pre><code class="language-java">public String fetchFromFastestReplica(String key) throws InterruptedException {
    try (var scope = new StructuredTaskScope.ShutdownOnSuccess&#x3C;String>()) {
        scope.fork(() -> replicaA.get(key));
        scope.fork(() -> replicaB.get(key));
        scope.fork(() -> replicaC.get(key));

        scope.join();
        return scope.result();  // Returns result of first successful subtask
    }
    // The other 2 replicas are automatically cancelled
}
</code></pre>
<h2>Thread-Safe Collection Patterns</h2>
<p><strong>ConcurrentHashMap vs synchronized HashMap:</strong></p>
<pre><code class="language-java">// ConcurrentHashMap: lock striping ‚Äî 16 independent segments, highly concurrent
ConcurrentHashMap&#x3C;String, User> cache = new ConcurrentHashMap&#x3C;>();

// computeIfAbsent is atomic ‚Äî safe for cache population:
User user = cache.computeIfAbsent(userId, id -> userRepo.findById(id));

// NOT atomic: check-then-act on ConcurrentHashMap
if (!cache.containsKey(key)) {          // Thread A checks: false
    cache.put(key, computeExpensive());  // Thread B also passes check, both compute!
}
// Use computeIfAbsent instead.
</code></pre>
<p><strong>CopyOnWriteArrayList:</strong> For read-heavy, write-rare scenarios:</p>
<pre><code class="language-java">// Good for: event listeners, read-heavy configuration lists
// Bad for: frequent writes (every write copies the entire array)
CopyOnWriteArrayList&#x3C;EventListener> listeners = new CopyOnWriteArrayList&#x3C;>();
// Reads: zero synchronization (reads see a consistent snapshot)
// Writes: creates a new copy of the underlying array
</code></pre>
<p><strong>BlockingQueue for producer-consumer:</strong></p>
<pre><code class="language-java">BlockingQueue&#x3C;Task> queue = new LinkedBlockingQueue&#x3C;>(1000); // Bounded!

// Producer thread:
queue.put(task); // Blocks if queue is full ‚Äî natural backpressure

// Consumer thread:
Task task = queue.take(); // Blocks if queue is empty ‚Äî no busy-waiting
</code></pre>
<h2>Common Concurrency Bugs</h2>
<p><strong>Bug 1: Unsafe lazy initialization (double-checked locking without volatile)</strong></p>
<pre><code class="language-java">// BROKEN: compilers/CPUs can reorder writes
private static DatabaseConnection instance;

public static DatabaseConnection getInstance() {
    if (instance == null) {
        synchronized (DatabaseConnection.class) {
            if (instance == null) {
                instance = new DatabaseConnection(); // 3 operations: alloc, init, assign
                // CPU can reorder: assign before init ‚Üí other threads see half-initialized object
            }
        }
    }
    return instance;
}

// FIXED: volatile ensures visibility ordering
private static volatile DatabaseConnection instance;
// Or better: use initialization-on-demand holder:
private static class Holder {
    static final DatabaseConnection INSTANCE = new DatabaseConnection();
}
public static DatabaseConnection getInstance() { return Holder.INSTANCE; }
</code></pre>
<p><strong>Bug 2: Lost updates with compound operations</strong></p>
<pre><code class="language-java">// BROKEN: read-modify-write is not atomic
private int counter = 0;
public void increment() { counter++; } // Actually: temp=counter; temp+1; counter=temp
// Two threads: both read 5, both write 6. Count is 6 not 7.

// FIXED:
private AtomicInteger counter = new AtomicInteger(0);
public void increment() { counter.incrementAndGet(); } // CAS ‚Äî atomic

// Or for complex state:
private final Object lock = new Object();
private int counter = 0;
public synchronized void increment() { counter++; }
</code></pre>
<p><strong>Bug 3: Publishing objects before initialization completes</strong></p>
<pre><code class="language-java">// BROKEN: 'this' escapes constructor before fully initialized
public class EventProcessor {
    private final List&#x3C;String> processors;

    public EventProcessor(EventBus bus) {
        bus.register(this); // 'this' is published here...
        this.processors = new ArrayList&#x3C;>(); // ...but this runs AFTER
        // Another thread calls handle() before processors is initialized ‚Üí NPE
    }

    public void handle(Event e) {
        processors.add(e.toString()); // NullPointerException
    }
}

// FIXED: use factory method
public static EventProcessor create(EventBus bus) {
    EventProcessor ep = new EventProcessor();
    bus.register(ep); // Register after fully constructed
    return ep;
}
</code></pre>
<h2>AtomicReference for Lock-Free Updates</h2>
<pre><code class="language-java">// Thread-safe config hot-reload without locking:
private final AtomicReference&#x3C;FeatureFlags> config =
    new AtomicReference&#x3C;>(FeatureFlags.loadFromFile());

// Background thread refreshes config:
@Scheduled(fixedDelay = 60_000)
public void refreshConfig() {
    FeatureFlags newFlags = FeatureFlags.loadFromFile();
    config.set(newFlags); // Atomic swap ‚Äî readers always see consistent snapshot
}

// Readers:
public boolean isEnabled(String feature) {
    return config.get().isEnabled(feature); // No locking needed
}

// CAS for optimistic updates:
public boolean tryUpdateFlag(String feature, boolean expected, boolean newValue) {
    FeatureFlags current = config.get();
    FeatureFlags updated = current.withFlag(feature, newValue);
    return config.compareAndSet(current, updated); // Succeeds only if unchanged
}
</code></pre>
<p>The rule for Java concurrency in 2025: prefer virtual threads + structured concurrency for I/O-bound concurrent work; use <code>CompletableFuture</code> when you need fine-grained composition; reach for <code>AtomicReference</code>/<code>ConcurrentHashMap</code> for shared mutable state; avoid raw <code>synchronized</code> blocks except for simple critical sections. The concurrency primitives introduced in Java 21 make the "correct by construction" approach significantly easier than it was five years ago.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass ‚Äî Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Java%20Concurrency%20Patterns%3A%20CompletableFuture%2C%20Structured%20Concurrency%2C%20and%20Thread-Safe%20Design&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-concurrency-patterns%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-concurrency-patterns%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#completablefuture-composing-async-operations" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">CompletableFuture: Composing Async Operations</a></li><li class=""><a href="#custom-executors-dont-use-the-default" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Custom Executors: Don&#x27;t Use the Default</a></li><li class=""><a href="#java-21-structured-concurrency" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Java 21 Structured Concurrency</a></li><li class=""><a href="#thread-safe-collection-patterns" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Thread-Safe Collection Patterns</a></li><li class=""><a href="#common-concurrency-bugs" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Common Concurrency Bugs</a></li><li class=""><a href="#atomicreference-for-lock-free-updates" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">AtomicReference for Lock-Free Updates</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a><a href="/blog/scaling-spring-boot-10m-dau/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Scaling Spring Boot Applications to Handle 10 Million Daily Active Users</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">10 million daily active users is not an exotic scale ‚Äî it&#x27;s where a successful mid-stage startup or a growing enterprise service lands. At this scale, the things that worked for 100,000 users start breaking in interestin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>May 28, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>10 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring boot</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->scaling</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th‚Ä¶","contentHtml":"\u003cp\u003eJava concurrency has three eras: raw \u003ccode\u003eThread\u003c/code\u003e and \u003ccode\u003esynchronized\u003c/code\u003e (Java 1-4), the \u003ccode\u003ejava.util.concurrent\u003c/code\u003e framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all three ‚Äî and knowing which to use when ‚Äî separates engineers who write concurrent code from engineers who write correct concurrent code.\u003c/p\u003e\n\u003ch2\u003eCompletableFuture: Composing Async Operations\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eCompletableFuture\u003c/code\u003e is the fundamental async primitive since Java 8. It represents a future value and provides a fluent API for transforming and combining async results.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Parallel data fetching with CompletableFuture:\npublic OrderSummary buildOrderSummary(String orderId) {\n    Executor executor = ForkJoinPool.commonPool(); // Or custom executor\n\n    CompletableFuture\u0026#x3C;Order\u003e orderFuture = CompletableFuture\n        .supplyAsync(() -\u003e orderRepo.findById(orderId), executor);\n\n    CompletableFuture\u0026#x3C;Customer\u003e customerFuture = orderFuture\n        .thenApplyAsync(order -\u003e customerRepo.findById(order.getCustomerId()), executor);\n\n    CompletableFuture\u0026#x3C;List\u0026#x3C;Product\u003e\u003e productsFuture = orderFuture\n        .thenApplyAsync(order -\u003e\n            productRepo.findAllById(order.getProductIds()), executor);\n\n    CompletableFuture\u0026#x3C;ShippingStatus\u003e shippingFuture = orderFuture\n        .thenApplyAsync(order -\u003e\n            shippingService.getStatus(order.getShipmentId()), executor);\n\n    // Combine results (customer + products + shipping in parallel after order loads):\n    return CompletableFuture.allOf(customerFuture, productsFuture, shippingFuture)\n        .thenApply(v -\u003e OrderSummary.builder()\n            .order(orderFuture.join())\n            .customer(customerFuture.join())\n            .products(productsFuture.join())\n            .shipping(shippingFuture.join())\n            .build())\n        .join();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eorderFuture\u003c/code\u003e runs first; \u003ccode\u003ecustomerFuture\u003c/code\u003e, \u003ccode\u003eproductsFuture\u003c/code\u003e, and \u003ccode\u003eshippingFuture\u003c/code\u003e all start after \u003ccode\u003eorderFuture\u003c/code\u003e completes but run in parallel with each other. The total time is \u003ccode\u003eorder_fetch + max(customer, products, shipping)\u003c/code\u003e instead of the sum.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eException handling in async chains:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCompletableFuture\u0026#x3C;PricingResult\u003e priceFuture = CompletableFuture\n    .supplyAsync(() -\u003e pricingService.calculate(request))\n    .exceptionally(ex -\u003e {\n        log.warn(\"Pricing service failed, using fallback: {}\", ex.getMessage());\n        return PricingResult.fallback(request.getBasePrice()); // Graceful degradation\n    })\n    .thenApply(pricing -\u003e applyDiscounts(pricing))\n    .handle((result, ex) -\u003e {\n        // handle() receives BOTH result and exception (either may be null)\n        if (ex != null) {\n            metrics.recordPricingError(ex);\n            return PricingResult.fallback(request.getBasePrice());\n        }\n        metrics.recordPricingSuccess();\n        return result;\n    });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCritical pitfall: join() blocks ‚Äî use carefully:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// BAD: Calling join() inside an async chain on ForkJoinPool common pool\nCompletableFuture.supplyAsync(() -\u003e {\n    // This is running on ForkJoinPool.commonPool()\n    String result = anotherFuture.join(); // BLOCKS a ForkJoinPool thread\n    // If all threads are blocked waiting for other futures: DEADLOCK\n    return process(result);\n});\n\n// GOOD: Use thenCompose for chaining async operations:\nCompletableFuture\u0026#x3C;String\u003e result = firstFuture\n    .thenComposeAsync(value -\u003e createSecondFuture(value), customExecutor);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCustom Executors: Don't Use the Default\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eForkJoinPool.commonPool()\u003c/code\u003e is shared across the entire JVM. In a Spring Boot application, Tomcat, Spring's \u003ccode\u003e@Async\u003c/code\u003e, CompletableFuture defaults, and parallel streams all compete for it. Use dedicated executors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Configuration\npublic class ExecutorConfig {\n\n    @Bean(\"ioExecutor\")\n    public ExecutorService ioExecutor() {\n        return new ThreadPoolExecutor(\n            10,           // corePoolSize\n            50,           // maximumPoolSize\n            60, TimeUnit.SECONDS,\n            new LinkedBlockingQueue\u0026#x3C;\u003e(200),  // bounded queue ‚Äî important!\n            new ThreadFactoryBuilder()\n                .setNameFormat(\"io-worker-%d\")\n                .build(),\n            new ThreadPoolExecutor.CallerRunsPolicy()  // Backpressure: caller thread runs task\n        );\n    }\n\n    @Bean(\"cpuExecutor\")\n    public ExecutorService cpuExecutor() {\n        int cores = Runtime.getRuntime().availableProcessors();\n        return Executors.newFixedThreadPool(cores,\n            new ThreadFactoryBuilder().setNameFormat(\"cpu-worker-%d\").build());\n    }\n}\n\n// Usage:\nCompletableFuture\n    .supplyAsync(() -\u003e fetchFromDatabase(id), ioExecutor)     // I/O bound\n    .thenApplyAsync(data -\u003e processData(data), cpuExecutor)  // CPU bound\n    .thenApplyAsync(result -\u003e saveResult(result), ioExecutor) // I/O bound\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBounded queues are mandatory.\u003c/strong\u003e An unbounded queue (\u003ccode\u003eLinkedBlockingQueue()\u003c/code\u003e with no capacity) allows tasks to queue indefinitely, consuming memory and masking backpressure problems. A bounded queue with \u003ccode\u003eCallerRunsPolicy\u003c/code\u003e provides natural backpressure: when the executor is full, the calling thread executes the task directly ‚Äî slowing the producer.\u003c/p\u003e\n\u003ch2\u003eJava 21 Structured Concurrency\u003c/h2\u003e\n\u003cp\u003eStructured concurrency (JEP 453, finalized in Java 21) makes concurrent task lifetime match lexical scope ‚Äî no task outlives its parent scope:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Classic CompletableFuture: tasks can outlive scope, error handling is scattered\n// Structured concurrency: all tasks within try-block, exceptions propagate cleanly\n\npublic OrderSummary buildSummary(String orderId) throws InterruptedException {\n    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n        // Fork concurrent subtasks:\n        Subtask\u0026#x3C;Order\u003e orderTask = scope.fork(() -\u003e orderRepo.findById(orderId));\n        Subtask\u0026#x3C;Inventory\u003e inventoryTask = scope.fork(() -\u003e inventoryService.check(orderId));\n        Subtask\u0026#x3C;PriceResult\u003e priceTask = scope.fork(() -\u003e pricingService.calculate(orderId));\n\n        // Wait for all tasks (or until one fails):\n        scope.join()           // Wait for all\n             .throwIfFailed(); // Throw if any failed (cancels remaining)\n\n        // All tasks succeeded ‚Äî results are available:\n        return OrderSummary.of(\n            orderTask.get(),\n            inventoryTask.get(),\n            priceTask.get()\n        );\n    }\n    // When try-block exits: ALL forked tasks are guaranteed to have completed\n    // No task leaks, no partial results, clean cancellation\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eShutdownOnSuccess:\u003c/strong\u003e Return the first successful result, cancel the rest (racing pattern):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String fetchFromFastestReplica(String key) throws InterruptedException {\n    try (var scope = new StructuredTaskScope.ShutdownOnSuccess\u0026#x3C;String\u003e()) {\n        scope.fork(() -\u003e replicaA.get(key));\n        scope.fork(() -\u003e replicaB.get(key));\n        scope.fork(() -\u003e replicaC.get(key));\n\n        scope.join();\n        return scope.result();  // Returns result of first successful subtask\n    }\n    // The other 2 replicas are automatically cancelled\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThread-Safe Collection Patterns\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eConcurrentHashMap vs synchronized HashMap:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ConcurrentHashMap: lock striping ‚Äî 16 independent segments, highly concurrent\nConcurrentHashMap\u0026#x3C;String, User\u003e cache = new ConcurrentHashMap\u0026#x3C;\u003e();\n\n// computeIfAbsent is atomic ‚Äî safe for cache population:\nUser user = cache.computeIfAbsent(userId, id -\u003e userRepo.findById(id));\n\n// NOT atomic: check-then-act on ConcurrentHashMap\nif (!cache.containsKey(key)) {          // Thread A checks: false\n    cache.put(key, computeExpensive());  // Thread B also passes check, both compute!\n}\n// Use computeIfAbsent instead.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyOnWriteArrayList:\u003c/strong\u003e For read-heavy, write-rare scenarios:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Good for: event listeners, read-heavy configuration lists\n// Bad for: frequent writes (every write copies the entire array)\nCopyOnWriteArrayList\u0026#x3C;EventListener\u003e listeners = new CopyOnWriteArrayList\u0026#x3C;\u003e();\n// Reads: zero synchronization (reads see a consistent snapshot)\n// Writes: creates a new copy of the underlying array\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBlockingQueue for producer-consumer:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eBlockingQueue\u0026#x3C;Task\u003e queue = new LinkedBlockingQueue\u0026#x3C;\u003e(1000); // Bounded!\n\n// Producer thread:\nqueue.put(task); // Blocks if queue is full ‚Äî natural backpressure\n\n// Consumer thread:\nTask task = queue.take(); // Blocks if queue is empty ‚Äî no busy-waiting\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCommon Concurrency Bugs\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eBug 1: Unsafe lazy initialization (double-checked locking without volatile)\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// BROKEN: compilers/CPUs can reorder writes\nprivate static DatabaseConnection instance;\n\npublic static DatabaseConnection getInstance() {\n    if (instance == null) {\n        synchronized (DatabaseConnection.class) {\n            if (instance == null) {\n                instance = new DatabaseConnection(); // 3 operations: alloc, init, assign\n                // CPU can reorder: assign before init ‚Üí other threads see half-initialized object\n            }\n        }\n    }\n    return instance;\n}\n\n// FIXED: volatile ensures visibility ordering\nprivate static volatile DatabaseConnection instance;\n// Or better: use initialization-on-demand holder:\nprivate static class Holder {\n    static final DatabaseConnection INSTANCE = new DatabaseConnection();\n}\npublic static DatabaseConnection getInstance() { return Holder.INSTANCE; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBug 2: Lost updates with compound operations\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// BROKEN: read-modify-write is not atomic\nprivate int counter = 0;\npublic void increment() { counter++; } // Actually: temp=counter; temp+1; counter=temp\n// Two threads: both read 5, both write 6. Count is 6 not 7.\n\n// FIXED:\nprivate AtomicInteger counter = new AtomicInteger(0);\npublic void increment() { counter.incrementAndGet(); } // CAS ‚Äî atomic\n\n// Or for complex state:\nprivate final Object lock = new Object();\nprivate int counter = 0;\npublic synchronized void increment() { counter++; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBug 3: Publishing objects before initialization completes\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// BROKEN: 'this' escapes constructor before fully initialized\npublic class EventProcessor {\n    private final List\u0026#x3C;String\u003e processors;\n\n    public EventProcessor(EventBus bus) {\n        bus.register(this); // 'this' is published here...\n        this.processors = new ArrayList\u0026#x3C;\u003e(); // ...but this runs AFTER\n        // Another thread calls handle() before processors is initialized ‚Üí NPE\n    }\n\n    public void handle(Event e) {\n        processors.add(e.toString()); // NullPointerException\n    }\n}\n\n// FIXED: use factory method\npublic static EventProcessor create(EventBus bus) {\n    EventProcessor ep = new EventProcessor();\n    bus.register(ep); // Register after fully constructed\n    return ep;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAtomicReference for Lock-Free Updates\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Thread-safe config hot-reload without locking:\nprivate final AtomicReference\u0026#x3C;FeatureFlags\u003e config =\n    new AtomicReference\u0026#x3C;\u003e(FeatureFlags.loadFromFile());\n\n// Background thread refreshes config:\n@Scheduled(fixedDelay = 60_000)\npublic void refreshConfig() {\n    FeatureFlags newFlags = FeatureFlags.loadFromFile();\n    config.set(newFlags); // Atomic swap ‚Äî readers always see consistent snapshot\n}\n\n// Readers:\npublic boolean isEnabled(String feature) {\n    return config.get().isEnabled(feature); // No locking needed\n}\n\n// CAS for optimistic updates:\npublic boolean tryUpdateFlag(String feature, boolean expected, boolean newValue) {\n    FeatureFlags current = config.get();\n    FeatureFlags updated = current.withFlag(feature, newValue);\n    return config.compareAndSet(current, updated); // Succeeds only if unchanged\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe rule for Java concurrency in 2025: prefer virtual threads + structured concurrency for I/O-bound concurrent work; use \u003ccode\u003eCompletableFuture\u003c/code\u003e when you need fine-grained composition; reach for \u003ccode\u003eAtomicReference\u003c/code\u003e/\u003ccode\u003eConcurrentHashMap\u003c/code\u003e for shared mutable state; avoid raw \u003ccode\u003esynchronized\u003c/code\u003e blocks except for simple critical sections. The concurrency primitives introduced in Java 21 make the \"correct by construction\" approach significantly easier than it was five years ago.\u003c/p\u003e\n","tableOfContents":[{"id":"completablefuture-composing-async-operations","text":"CompletableFuture: Composing Async Operations","level":2},{"id":"custom-executors-dont-use-the-default","text":"Custom Executors: Don't Use the Default","level":2},{"id":"java-21-structured-concurrency","text":"Java 21 Structured Concurrency","level":2},{"id":"thread-safe-collection-patterns","text":"Thread-Safe Collection Patterns","level":2},{"id":"common-concurrency-bugs","text":"Common Concurrency Bugs","level":2},{"id":"atomicreference-for-lock-free-updates","text":"AtomicReference for Lock-Free Updates","level":2}]},"relatedPosts":[{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶"},{"title":"Scaling Spring Boot Applications to Handle 10 Million Daily Active Users","description":"A practical performance engineering guide: load balancing, horizontal scaling, database tuning, JVM optimization, autoscaling, and the observability stack to find and fix bottlenecks before they page you.","date":"2025-05-28","category":"Java","tags":["spring boot","java","scaling","performance","jvm","kubernetes","prometheus","grafana"],"featured":false,"affiliateSection":"java-courses","slug":"scaling-spring-boot-10m-dau","readingTime":"10 min read","excerpt":"10 million daily active users is not an exotic scale ‚Äî it's where a successful mid-stage startup or a growing enterprise service lands. At this scale, the things that worked for 100,000 users start breaking in interestin‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-concurrency-patterns"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>