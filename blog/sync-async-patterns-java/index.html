<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads<!-- --> | CodeSprintPro</title><meta name="description" content="Master Java&#x27;s concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/sync-async-patterns-java/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads" data-next-head=""/><meta property="og:description" content="Master Java&#x27;s concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/sync-async-patterns-java/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-01-26" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="async" data-next-head=""/><meta property="article:tag" content="concurrency" data-next-head=""/><meta property="article:tag" content="reactive" data-next-head=""/><meta property="article:tag" content="spring boot" data-next-head=""/><meta property="article:tag" content="webflux" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads" data-next-head=""/><meta name="twitter:description" content="Master Java&#x27;s concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads","description":"Master Java's concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-01-26","dateModified":"2025-01-26","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/sync-async-patterns-java/"},"keywords":"java, async, concurrency, reactive, spring boot, webflux","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Master Java&#x27;s concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>January 26, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>11 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->async</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->concurrency</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->reactive</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->spring boot</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->webflux</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Java has accumulated three distinct paradigms for handling concurrency over the past 15 years: traditional blocking threads, CompletableFuture-based async composition, and reactive programming with Project Reactor/RxJava. Now Java 21 adds virtual threads. Each solves a real problem ‚Äî but choosing the wrong one for your use case introduces unnecessary complexity or leaves performance on the table.</p>
<p>This article gives you the mental model to choose correctly.</p>
<h2>The Core Problem: Threads Are Expensive</h2>
<p>Before comparing the options, it helps to understand precisely why concurrency is a challenge in the first place. A Java thread waiting on IO (database query, HTTP call, disk read) <strong>holds an OS thread</strong> that could be serving other requests. With a thread pool of 200 (Tomcat default), you can handle 200 concurrent IO-bound requests before requests start queuing. The following breakdown shows how quickly that limit becomes a bottleneck as concurrency grows:</p>
<pre><code>200 concurrent users, each waits 100ms for DB:
  Sequential (1 thread): 200 √ó 100ms = 20 seconds
  200 threads (Tomcat default): all 200 run concurrently ‚Üí 100ms total
  1,000 concurrent users: 800 queue behind 200 threads ‚Üí queueing latency

Solution options:
  1. Bigger thread pool (200 ‚Üí 2000): High memory usage, GC pressure
  2. Non-blocking async: Release thread during IO wait ‚Üí serve more with fewer threads
  3. Virtual threads (Java 21): OS-level non-blocking, write blocking code
</code></pre>
<h2>Option 1: Blocking I/O with Bounded Thread Pool</h2>
<p>The simplest model. Still correct for most applications with moderate concurrency. If your service handles fewer than a few hundred concurrent requests and all of them are short CRUD operations, this is likely all you need ‚Äî additional complexity buys you nothing:</p>
<pre><code class="language-java">@Service
public class OrderService {

    @Autowired
    private OrderRepository repository;  // Blocking JDBC

    // Runs on Tomcat thread pool (default 200 threads)
    // Blocking ‚Äî holds thread during DB wait
    public Order getOrder(String orderId) {
        return repository.findById(orderId)  // Blocks thread here
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }
}
</code></pre>
<p><strong>When this is fine:</strong></p>
<ul>
<li>&#x3C; 200 concurrent requests that involve IO</li>
<li>Simple CRUD operations</li>
<li>Teams unfamiliar with async patterns (simplicity wins)</li>
</ul>
<p><strong>When this breaks:</strong></p>
<ul>
<li>
<blockquote>
<p>1000 concurrent requests with IO wait</p>
</blockquote>
</li>
<li>Long-polling, WebSockets, streaming endpoints</li>
<li>Services calling 5+ downstream APIs per request</li>
</ul>
<h2>Option 2: CompletableFuture ‚Äî Async Composition</h2>
<p>CompletableFuture (Java 8+) runs tasks asynchronously and composes their results without blocking threads. It is most useful when you need to execute multiple independent IO operations in parallel and combine their results ‚Äî turning sequential waits into concurrent ones. The following example builds a dashboard by fetching a user profile, recent orders, and notifications at the same time rather than one after another:</p>
<pre><code class="language-java">@Service
public class DashboardService {

    // Run three API calls concurrently ‚Äî don't wait for each one serially
    public CompletableFuture&#x3C;Dashboard> buildDashboard(String userId) {
        Executor executor = ForkJoinPool.commonPool(); // Or custom executor

        CompletableFuture&#x3C;UserProfile> profileFuture =
            CompletableFuture.supplyAsync(() -> fetchProfile(userId), executor);

        CompletableFuture&#x3C;List&#x3C;Order>> ordersFuture =
            CompletableFuture.supplyAsync(() -> fetchRecentOrders(userId, 10), executor);

        CompletableFuture&#x3C;List&#x3C;Notification>> notifFuture =
            CompletableFuture.supplyAsync(() -> fetchNotifications(userId), executor);

        // Combine all three: continue only when all complete
        return CompletableFuture.allOf(profileFuture, ordersFuture, notifFuture)
            .thenApply(__ -> new Dashboard(
                profileFuture.join(),   // .join() here is safe ‚Äî allOf guarantees completion
                ordersFuture.join(),
                notifFuture.join()
            ))
            .exceptionally(e -> {
                log.error("Dashboard build failed for user {}: {}", userId, e.getMessage());
                return Dashboard.empty(); // Graceful degradation
            });
    }
}
</code></pre>
<h3>CompletableFuture Chaining</h3>
<p>Once you have a single async result, you can chain subsequent operations using <code>thenApply</code> and <code>thenCompose</code>. The distinction between these two methods is the most important thing to understand: use <code>thenApply</code> when the next step is synchronous, and <code>thenCompose</code> when the next step is itself asynchronous and returns a <code>CompletableFuture</code>. Mixing them up leads to nested <code>CompletableFuture&#x3C;CompletableFuture&#x3C;T>></code> types that are difficult to unwrap correctly:</p>
<pre><code class="language-java">public CompletableFuture&#x3C;String> processOrder(String orderId) {
    return CompletableFuture
        .supplyAsync(() -> orderRepository.findById(orderId))    // Fetch order
        .thenApply(order -> validateOrder(order))                // Validate (sync)
        .thenCompose(order -> inventoryService.reserveAsync(order)) // Reserve (async)
        .thenCompose(reserved -> paymentService.chargeAsync(reserved)) // Charge (async)
        .thenApply(result -> result.getConfirmationId())        // Extract ID (sync)
        .whenComplete((result, error) -> {
            if (error != null) {
                auditLog.logFailure(orderId, error);
            } else {
                auditLog.logSuccess(orderId, result);
            }
        });
}
</code></pre>
<p><strong>Key CompletableFuture methods:</strong></p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Input</th>
<th>Output</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenApply</code></td>
<td>sync function</td>
<td>CF of result</td>
<td>Transform result synchronously</td>
</tr>
<tr>
<td><code>thenCompose</code></td>
<td>async function returning CF</td>
<td>CF of result</td>
<td>Chain async operations (flatMap)</td>
</tr>
<tr>
<td><code>thenCombine</code></td>
<td>two CFs</td>
<td>CF of combined</td>
<td>Merge two concurrent results</td>
</tr>
<tr>
<td><code>allOf</code></td>
<td>N CFs</td>
<td>CF<Void></td>
<td>Wait for all</td>
</tr>
<tr>
<td><code>anyOf</code></td>
<td>N CFs</td>
<td>CF<Object></td>
<td>First to complete wins</td>
</tr>
<tr>
<td><code>exceptionally</code></td>
<td>exception handler</td>
<td>CF of fallback</td>
<td>Handle errors</td>
</tr>
<tr>
<td><code>whenComplete</code></td>
<td>BiConsumer</td>
<td>CF of result</td>
<td>Side effect on completion</td>
</tr>
</tbody>
</table>
<h3>CompletableFuture Pitfalls</h3>
<p>CompletableFuture is easy to misuse in ways that silently defeat its purpose. The two most common mistakes involve either blocking inside the async chain, or using the wrong thread pool for IO-bound work:</p>
<pre><code class="language-java">// WRONG: Blocking inside async chain ‚Äî wastes the thread
CompletableFuture.supplyAsync(() -> {
    return httpClient.get(url).get(); // .get() BLOCKS the thread!
    // Defeats the purpose of async
});

// WRONG: Using ForkJoinPool for blocking IO
CompletableFuture.supplyAsync(() -> jdbcTemplate.queryForList(sql));
// ForkJoinPool is for CPU-bound work ‚Äî blocking IO starves it
// Use a dedicated IO thread pool instead

// RIGHT: Separate executor for IO-bound async tasks
Executor ioExecutor = Executors.newFixedThreadPool(50);

CompletableFuture.supplyAsync(() -> jdbcTemplate.queryForList(sql), ioExecutor);
</code></pre>
<p>The reason <code>ForkJoinPool</code> is wrong for IO work is subtle: <code>ForkJoinPool</code> is designed to keep all threads busy with CPU work by work-stealing. If your tasks block on IO, those threads sit idle and the pool cannot compensate by spinning up new ones ‚Äî you end up with all threads blocked and new tasks queuing up behind them.</p>
<h2>Option 3: Project Reactor (Spring WebFlux)</h2>
<p>Reactor provides a fully non-blocking reactive pipeline using <code>Mono</code> (0-1 elements) and <code>Flux</code> (0-N elements). Unlike <code>CompletableFuture</code>, which models a single eventual value, Reactor can model streams of values over time ‚Äî making it the right choice for server-sent events, WebSocket feeds, and any scenario where the producer generates data faster than the consumer can process it. The entire call stack must be non-blocking ‚Äî including database drivers (R2DBC) and HTTP clients (WebClient):</p>
<pre><code class="language-java">@RestController
public class ReactiveOrderController {

    @Autowired
    private R2dbcOrderRepository repository;  // Non-blocking R2DBC

    @Autowired
    private WebClient inventoryClient;

    // Flux: stream of events (Server-Sent Events)
    @GetMapping(value = "/orders/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&#x3C;Order> streamOrders() {
        return repository.findAll()
            .delayElements(Duration.ofMillis(100)) // Throttle for streaming
            .doOnError(e -> log.error("Stream error", e));
    }

    // Mono: single order with enrichment
    @GetMapping("/orders/{id}")
    public Mono&#x3C;OrderDetail> getOrderDetail(@PathVariable String id) {
        return repository.findById(id)
            .switchIfEmpty(Mono.error(new OrderNotFoundException(id)))
            .flatMap(order ->
                inventoryClient.get()
                    .uri("/items/{id}", order.getItemId())
                    .retrieve()
                    .bodyToMono(Item.class)
                    .map(item -> new OrderDetail(order, item))
            )
            .timeout(Duration.ofSeconds(3))
            .onErrorResume(TimeoutException.class, e -> {
                log.warn("Inventory timeout for order {}", id);
                return repository.findById(id).map(o -> new OrderDetail(o, Item.unknown()));
            });
    }
}
</code></pre>
<p>The <code>onErrorResume</code> block at the end demonstrates one of Reactor's strengths over <code>CompletableFuture</code>: typed error handling. You can match on the specific exception type (<code>TimeoutException</code>) and provide a degraded response ‚Äî in this case returning the order with an <code>Item.unknown()</code> placeholder rather than failing the entire request.</p>
<h3>subscribeOn vs publishOn</h3>
<p>The most confusing part of Reactor is understanding which thread executes which part of your pipeline. Reactor uses a scheduler model where you explicitly control thread assignment. The key mental model is that <code>subscribeOn</code> affects the entire upstream (where subscription starts), while <code>publishOn</code> is a one-way switch that affects only the operators that come after it:</p>
<pre><code class="language-java">Flux.fromIterable(largeList)
    .subscribeOn(Schedulers.boundedElastic())  // Which thread SUBSCRIBES (starts) the chain
    .map(item -> expensiveComputation(item))   // Runs on subscribeOn thread
    .publishOn(Schedulers.parallel())          // Switch thread for downstream ops
    .map(result -> transformResult(result))    // Runs on parallel scheduler
    .subscribe(result -> log.info(result));    // Runs on parallel scheduler

// subscribeOn: affects where the entire upstream runs
// publishOn: switches scheduler for operations AFTER it in the chain
</code></pre>
<p><strong>Reactor schedulers:</strong></p>
<table>
<thead>
<tr>
<th>Scheduler</th>
<th>Use For</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Schedulers.parallel()</code></td>
<td>CPU-bound work, sized to CPU cores</td>
</tr>
<tr>
<td><code>Schedulers.boundedElastic()</code></td>
<td>Blocking IO wrappers, sized dynamically (max 10√óCPU)</td>
</tr>
<tr>
<td><code>Schedulers.immediate()</code></td>
<td>Current thread (no context switch)</td>
</tr>
<tr>
<td><code>Schedulers.single()</code></td>
<td>Sequential background tasks, 1 thread</td>
</tr>
</tbody>
</table>
<h3>Wrapping Blocking IO in Reactor</h3>
<p>If you are migrating an existing application to WebFlux incrementally, you will likely have some JDBC or legacy code that cannot be made reactive immediately. The correct approach is to wrap it in <code>Mono.fromCallable</code> and offload it to <code>boundedElastic</code>, which is specifically designed to handle a dynamic number of blocking IO tasks:</p>
<pre><code class="language-java">// Database calls (without R2DBC), legacy APIs ‚Äî wrap in boundedElastic
public Mono&#x3C;Order> getOrder(String id) {
    return Mono.fromCallable(() -> jdbcOrderRepository.findById(id)) // Blocking
        .subscribeOn(Schedulers.boundedElastic()) // Run on IO-capable scheduler
        .doOnError(e -> log.error("DB error", e));
}

// DON'T: Call blocking code on parallel() scheduler ‚Äî starves CPU threads
public Mono&#x3C;Order> broken(String id) {
    return Mono.fromCallable(() -> jdbcOrderRepository.findById(id))
        .subscribeOn(Schedulers.parallel()); // WRONG for IO
}
</code></pre>
<h2>Option 4: Virtual Threads (Java 21)</h2>
<p>Virtual threads write like blocking code but scale like reactive code. If you are starting a new project on Java 21, virtual threads should be your first consideration for IO-bound services ‚Äî they give you the readability of blocking code without the scalability ceiling of platform threads and without the learning curve of reactive programming:</p>
<pre><code class="language-java">// Same blocking code ‚Äî but runs on a virtual thread
// No CompletableFuture composition, no subscribeOn, no reactive operators
@GetMapping("/orders/{id}")
public OrderDetail getOrderDetail(@PathVariable String id) {
    // All these block the current virtual thread ‚Äî not the OS carrier thread
    Order order = orderRepository.findById(id)  // Blocks VT
        .orElseThrow(() -> new OrderNotFoundException(id));

    Item item = inventoryClient.getItem(order.getItemId()); // Blocks VT

    return new OrderDetail(order, item); // Simple, readable, debuggable
}
</code></pre>
<p>Compare this to the equivalent <code>Mono</code>-based version above. The virtual thread version is shorter, has full stack traces, works naturally with debuggers, and is immediately readable to anyone who knows Java ‚Äî without sacrificing the ability to handle thousands of concurrent requests. See the Java Virtual Threads article for full details on configuration and pitfalls.</p>
<h2>Decision Tree</h2>
<p>With all four options covered, use this decision tree to choose the right approach for your situation. The single most impactful question is whether you are on Java 21 or later ‚Äî if you are, virtual threads eliminate most of the reasons to reach for <code>CompletableFuture</code> or Reactor for IO-bound work:</p>
<pre><code>Is your workload IO-bound (DB, HTTP, files)?
‚îú‚îÄ‚îÄ YES: How many concurrent requests?
‚îÇ   ‚îú‚îÄ‚îÄ &#x3C; 500: Platform threads (blocking), simple, fast to develop
‚îÇ   ‚îú‚îÄ‚îÄ 500-10K: Virtual threads (Java 21) OR CompletableFuture
‚îÇ   ‚îî‚îÄ‚îÄ > 10K: Virtual threads (Java 21) OR Reactive (WebFlux + R2DBC)
‚îÇ
‚îî‚îÄ‚îÄ NO (CPU-bound: sorting, compression, ML inference):
    ‚îî‚îÄ‚îÄ ForkJoinPool / parallel streams (thread-per-core)

Using Java 21+?
‚îú‚îÄ‚îÄ YES: Virtual threads for most IO cases ‚Äî simple and scalable
‚îî‚îÄ‚îÄ NO:  CompletableFuture (fan-out) or Reactor (streaming, backpressure)

Need backpressure (consumer slower than producer)?
‚îî‚îÄ‚îÄ YES: Project Reactor Flux ‚Äî built-in backpressure via demand signals

Need to stream data to client (SSE, WebSocket)?
‚îî‚îÄ‚îÄ YES: Project Reactor Flux with streaming media type
</code></pre>
<h2>Performance Comparison (IO-bound, 50ms wait per request)</h2>
<p>The numbers in the table below are the most important takeaway from this article. They quantify what the decision tree above implies: at low concurrency every approach performs similarly, but the differences become dramatic as you scale past the platform thread pool limit. Notice how blocking threads hit a hard wall while the other approaches continue to scale:</p>
<pre><code>Concurrency ‚îÇ Blocking (200 threads) ‚îÇ CompletableFuture ‚îÇ Reactor ‚îÇ Virtual Threads
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       200  ‚îÇ 3,900 rps, p99: 52ms   ‚îÇ 3,950 rps, 51ms   ‚îÇ 3,980   ‚îÇ 3,960 rps, 51ms
     1,000  ‚îÇ   980 rps, p99: 1.02s  ‚îÇ 9,700 rps, 103ms  ‚îÇ 9,800   ‚îÇ 9,800 rps, 52ms
    10,000  ‚îÇ timeout (queue full)   ‚îÇ 47K rps, 210ms    ‚îÇ 96K rps  ‚îÇ 97K rps, 53ms
    50,000  ‚îÇ OOM                    ‚îÇ 50K rps, OOM risk ‚îÇ 97K rps  ‚îÇ 96K rps, 56ms
</code></pre>
<p><strong>Takeaways:</strong></p>
<ul>
<li>CompletableFuture helps but still requires thread pool management</li>
<li>Reactor and virtual threads achieve similar throughput for IO-bound workloads</li>
<li>Reactor has better backpressure for streaming; virtual threads are simpler to write and maintain</li>
</ul>
<p>The right choice depends on your Java version, team familiarity, and streaming requirements ‚Äî not on which paradigm is theoretically "best".</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass ‚Äî Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Sync%20vs%20Async%20in%20Java%3A%20CompletableFuture%2C%20Reactive%20Streams%2C%20and%20Virtual%20Threads&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsync-async-patterns-java%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fsync-async-patterns-java%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-core-problem-threads-are-expensive" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Core Problem: Threads Are Expensive</a></li><li class=""><a href="#option-1-blocking-io-with-bounded-thread-pool" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Option 1: Blocking I/O with Bounded Thread Pool</a></li><li class=""><a href="#option-2-completablefuture-async-composition" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Option 2: CompletableFuture ‚Äî Async Composition</a></li><li class="ml-4"><a href="#completablefuture-chaining" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">CompletableFuture Chaining</a></li><li class="ml-4"><a href="#completablefuture-pitfalls" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">CompletableFuture Pitfalls</a></li><li class=""><a href="#option-3-project-reactor-spring-webflux" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Option 3: Project Reactor (Spring WebFlux)</a></li><li class="ml-4"><a href="#subscribeon-vs-publishon" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">subscribeOn vs publishOn</a></li><li class="ml-4"><a href="#wrapping-blocking-io-in-reactor" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Wrapping Blocking IO in Reactor</a></li><li class=""><a href="#option-4-virtual-threads-java-21" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Option 4: Virtual Threads (Java 21)</a></li><li class=""><a href="#decision-tree" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Decision Tree</a></li><li class=""><a href="#performance-comparison-io-bound-50ms-wait-per-request" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Performance Comparison (IO-bound, 50ms wait per request)</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-concurrency-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era&#x27;s patterns still exist in production codebases. Understanding all th‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->concurrency</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->completablefuture</span></div></article></a><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Sync vs Async in Java: CompletableFuture, Reactive Streams, and Virtual Threads","description":"Master Java's concurrency toolkit ‚Äî from blocking calls and thread pools to CompletableFuture chains, Project Reactor, and the new virtual thread model. Know when each is the right tool.","date":"2025-01-26","category":"Java","tags":["java","async","concurrency","reactive","spring boot","webflux"],"featured":false,"affiliateSection":"java-courses","slug":"sync-async-patterns-java","readingTime":"11 min read","excerpt":"Java has accumulated three distinct paradigms for handling concurrency over the past 15 years: traditional blocking threads, CompletableFuture-based async composition, and reactive programming with Project Reactor/RxJava‚Ä¶","contentHtml":"\u003cp\u003eJava has accumulated three distinct paradigms for handling concurrency over the past 15 years: traditional blocking threads, CompletableFuture-based async composition, and reactive programming with Project Reactor/RxJava. Now Java 21 adds virtual threads. Each solves a real problem ‚Äî but choosing the wrong one for your use case introduces unnecessary complexity or leaves performance on the table.\u003c/p\u003e\n\u003cp\u003eThis article gives you the mental model to choose correctly.\u003c/p\u003e\n\u003ch2\u003eThe Core Problem: Threads Are Expensive\u003c/h2\u003e\n\u003cp\u003eBefore comparing the options, it helps to understand precisely why concurrency is a challenge in the first place. A Java thread waiting on IO (database query, HTTP call, disk read) \u003cstrong\u003eholds an OS thread\u003c/strong\u003e that could be serving other requests. With a thread pool of 200 (Tomcat default), you can handle 200 concurrent IO-bound requests before requests start queuing. The following breakdown shows how quickly that limit becomes a bottleneck as concurrency grows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e200 concurrent users, each waits 100ms for DB:\n  Sequential (1 thread): 200 √ó 100ms = 20 seconds\n  200 threads (Tomcat default): all 200 run concurrently ‚Üí 100ms total\n  1,000 concurrent users: 800 queue behind 200 threads ‚Üí queueing latency\n\nSolution options:\n  1. Bigger thread pool (200 ‚Üí 2000): High memory usage, GC pressure\n  2. Non-blocking async: Release thread during IO wait ‚Üí serve more with fewer threads\n  3. Virtual threads (Java 21): OS-level non-blocking, write blocking code\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eOption 1: Blocking I/O with Bounded Thread Pool\u003c/h2\u003e\n\u003cp\u003eThe simplest model. Still correct for most applications with moderate concurrency. If your service handles fewer than a few hundred concurrent requests and all of them are short CRUD operations, this is likely all you need ‚Äî additional complexity buys you nothing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderRepository repository;  // Blocking JDBC\n\n    // Runs on Tomcat thread pool (default 200 threads)\n    // Blocking ‚Äî holds thread during DB wait\n    public Order getOrder(String orderId) {\n        return repository.findById(orderId)  // Blocks thread here\n            .orElseThrow(() -\u003e new OrderNotFoundException(orderId));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWhen this is fine:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026#x3C; 200 concurrent requests that involve IO\u003c/li\u003e\n\u003cli\u003eSimple CRUD operations\u003c/li\u003e\n\u003cli\u003eTeams unfamiliar with async patterns (simplicity wins)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eWhen this breaks:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cblockquote\u003e\n\u003cp\u003e1000 concurrent requests with IO wait\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003eLong-polling, WebSockets, streaming endpoints\u003c/li\u003e\n\u003cli\u003eServices calling 5+ downstream APIs per request\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eOption 2: CompletableFuture ‚Äî Async Composition\u003c/h2\u003e\n\u003cp\u003eCompletableFuture (Java 8+) runs tasks asynchronously and composes their results without blocking threads. It is most useful when you need to execute multiple independent IO operations in parallel and combine their results ‚Äî turning sequential waits into concurrent ones. The following example builds a dashboard by fetching a user profile, recent orders, and notifications at the same time rather than one after another:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class DashboardService {\n\n    // Run three API calls concurrently ‚Äî don't wait for each one serially\n    public CompletableFuture\u0026#x3C;Dashboard\u003e buildDashboard(String userId) {\n        Executor executor = ForkJoinPool.commonPool(); // Or custom executor\n\n        CompletableFuture\u0026#x3C;UserProfile\u003e profileFuture =\n            CompletableFuture.supplyAsync(() -\u003e fetchProfile(userId), executor);\n\n        CompletableFuture\u0026#x3C;List\u0026#x3C;Order\u003e\u003e ordersFuture =\n            CompletableFuture.supplyAsync(() -\u003e fetchRecentOrders(userId, 10), executor);\n\n        CompletableFuture\u0026#x3C;List\u0026#x3C;Notification\u003e\u003e notifFuture =\n            CompletableFuture.supplyAsync(() -\u003e fetchNotifications(userId), executor);\n\n        // Combine all three: continue only when all complete\n        return CompletableFuture.allOf(profileFuture, ordersFuture, notifFuture)\n            .thenApply(__ -\u003e new Dashboard(\n                profileFuture.join(),   // .join() here is safe ‚Äî allOf guarantees completion\n                ordersFuture.join(),\n                notifFuture.join()\n            ))\n            .exceptionally(e -\u003e {\n                log.error(\"Dashboard build failed for user {}: {}\", userId, e.getMessage());\n                return Dashboard.empty(); // Graceful degradation\n            });\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCompletableFuture Chaining\u003c/h3\u003e\n\u003cp\u003eOnce you have a single async result, you can chain subsequent operations using \u003ccode\u003ethenApply\u003c/code\u003e and \u003ccode\u003ethenCompose\u003c/code\u003e. The distinction between these two methods is the most important thing to understand: use \u003ccode\u003ethenApply\u003c/code\u003e when the next step is synchronous, and \u003ccode\u003ethenCompose\u003c/code\u003e when the next step is itself asynchronous and returns a \u003ccode\u003eCompletableFuture\u003c/code\u003e. Mixing them up leads to nested \u003ccode\u003eCompletableFuture\u0026#x3C;CompletableFuture\u0026#x3C;T\u003e\u003e\u003c/code\u003e types that are difficult to unwrap correctly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic CompletableFuture\u0026#x3C;String\u003e processOrder(String orderId) {\n    return CompletableFuture\n        .supplyAsync(() -\u003e orderRepository.findById(orderId))    // Fetch order\n        .thenApply(order -\u003e validateOrder(order))                // Validate (sync)\n        .thenCompose(order -\u003e inventoryService.reserveAsync(order)) // Reserve (async)\n        .thenCompose(reserved -\u003e paymentService.chargeAsync(reserved)) // Charge (async)\n        .thenApply(result -\u003e result.getConfirmationId())        // Extract ID (sync)\n        .whenComplete((result, error) -\u003e {\n            if (error != null) {\n                auditLog.logFailure(orderId, error);\n            } else {\n                auditLog.logSuccess(orderId, result);\n            }\n        });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eKey CompletableFuture methods:\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eMethod\u003c/th\u003e\n\u003cth\u003eInput\u003c/th\u003e\n\u003cth\u003eOutput\u003c/th\u003e\n\u003cth\u003eNotes\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenApply\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003esync function\u003c/td\u003e\n\u003ctd\u003eCF of result\u003c/td\u003e\n\u003ctd\u003eTransform result synchronously\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenCompose\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003easync function returning CF\u003c/td\u003e\n\u003ctd\u003eCF of result\u003c/td\u003e\n\u003ctd\u003eChain async operations (flatMap)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenCombine\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003etwo CFs\u003c/td\u003e\n\u003ctd\u003eCF of combined\u003c/td\u003e\n\u003ctd\u003eMerge two concurrent results\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eallOf\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eN CFs\u003c/td\u003e\n\u003ctd\u003eCF\u003cVoid\u003e\u003c/td\u003e\n\u003ctd\u003eWait for all\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eanyOf\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eN CFs\u003c/td\u003e\n\u003ctd\u003eCF\u003cObject\u003e\u003c/td\u003e\n\u003ctd\u003eFirst to complete wins\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eexceptionally\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eexception handler\u003c/td\u003e\n\u003ctd\u003eCF of fallback\u003c/td\u003e\n\u003ctd\u003eHandle errors\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ewhenComplete\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eBiConsumer\u003c/td\u003e\n\u003ctd\u003eCF of result\u003c/td\u003e\n\u003ctd\u003eSide effect on completion\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eCompletableFuture Pitfalls\u003c/h3\u003e\n\u003cp\u003eCompletableFuture is easy to misuse in ways that silently defeat its purpose. The two most common mistakes involve either blocking inside the async chain, or using the wrong thread pool for IO-bound work:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// WRONG: Blocking inside async chain ‚Äî wastes the thread\nCompletableFuture.supplyAsync(() -\u003e {\n    return httpClient.get(url).get(); // .get() BLOCKS the thread!\n    // Defeats the purpose of async\n});\n\n// WRONG: Using ForkJoinPool for blocking IO\nCompletableFuture.supplyAsync(() -\u003e jdbcTemplate.queryForList(sql));\n// ForkJoinPool is for CPU-bound work ‚Äî blocking IO starves it\n// Use a dedicated IO thread pool instead\n\n// RIGHT: Separate executor for IO-bound async tasks\nExecutor ioExecutor = Executors.newFixedThreadPool(50);\n\nCompletableFuture.supplyAsync(() -\u003e jdbcTemplate.queryForList(sql), ioExecutor);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reason \u003ccode\u003eForkJoinPool\u003c/code\u003e is wrong for IO work is subtle: \u003ccode\u003eForkJoinPool\u003c/code\u003e is designed to keep all threads busy with CPU work by work-stealing. If your tasks block on IO, those threads sit idle and the pool cannot compensate by spinning up new ones ‚Äî you end up with all threads blocked and new tasks queuing up behind them.\u003c/p\u003e\n\u003ch2\u003eOption 3: Project Reactor (Spring WebFlux)\u003c/h2\u003e\n\u003cp\u003eReactor provides a fully non-blocking reactive pipeline using \u003ccode\u003eMono\u003c/code\u003e (0-1 elements) and \u003ccode\u003eFlux\u003c/code\u003e (0-N elements). Unlike \u003ccode\u003eCompletableFuture\u003c/code\u003e, which models a single eventual value, Reactor can model streams of values over time ‚Äî making it the right choice for server-sent events, WebSocket feeds, and any scenario where the producer generates data faster than the consumer can process it. The entire call stack must be non-blocking ‚Äî including database drivers (R2DBC) and HTTP clients (WebClient):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RestController\npublic class ReactiveOrderController {\n\n    @Autowired\n    private R2dbcOrderRepository repository;  // Non-blocking R2DBC\n\n    @Autowired\n    private WebClient inventoryClient;\n\n    // Flux: stream of events (Server-Sent Events)\n    @GetMapping(value = \"/orders/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n    public Flux\u0026#x3C;Order\u003e streamOrders() {\n        return repository.findAll()\n            .delayElements(Duration.ofMillis(100)) // Throttle for streaming\n            .doOnError(e -\u003e log.error(\"Stream error\", e));\n    }\n\n    // Mono: single order with enrichment\n    @GetMapping(\"/orders/{id}\")\n    public Mono\u0026#x3C;OrderDetail\u003e getOrderDetail(@PathVariable String id) {\n        return repository.findById(id)\n            .switchIfEmpty(Mono.error(new OrderNotFoundException(id)))\n            .flatMap(order -\u003e\n                inventoryClient.get()\n                    .uri(\"/items/{id}\", order.getItemId())\n                    .retrieve()\n                    .bodyToMono(Item.class)\n                    .map(item -\u003e new OrderDetail(order, item))\n            )\n            .timeout(Duration.ofSeconds(3))\n            .onErrorResume(TimeoutException.class, e -\u003e {\n                log.warn(\"Inventory timeout for order {}\", id);\n                return repository.findById(id).map(o -\u003e new OrderDetail(o, Item.unknown()));\n            });\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eonErrorResume\u003c/code\u003e block at the end demonstrates one of Reactor's strengths over \u003ccode\u003eCompletableFuture\u003c/code\u003e: typed error handling. You can match on the specific exception type (\u003ccode\u003eTimeoutException\u003c/code\u003e) and provide a degraded response ‚Äî in this case returning the order with an \u003ccode\u003eItem.unknown()\u003c/code\u003e placeholder rather than failing the entire request.\u003c/p\u003e\n\u003ch3\u003esubscribeOn vs publishOn\u003c/h3\u003e\n\u003cp\u003eThe most confusing part of Reactor is understanding which thread executes which part of your pipeline. Reactor uses a scheduler model where you explicitly control thread assignment. The key mental model is that \u003ccode\u003esubscribeOn\u003c/code\u003e affects the entire upstream (where subscription starts), while \u003ccode\u003epublishOn\u003c/code\u003e is a one-way switch that affects only the operators that come after it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eFlux.fromIterable(largeList)\n    .subscribeOn(Schedulers.boundedElastic())  // Which thread SUBSCRIBES (starts) the chain\n    .map(item -\u003e expensiveComputation(item))   // Runs on subscribeOn thread\n    .publishOn(Schedulers.parallel())          // Switch thread for downstream ops\n    .map(result -\u003e transformResult(result))    // Runs on parallel scheduler\n    .subscribe(result -\u003e log.info(result));    // Runs on parallel scheduler\n\n// subscribeOn: affects where the entire upstream runs\n// publishOn: switches scheduler for operations AFTER it in the chain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eReactor schedulers:\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eScheduler\u003c/th\u003e\n\u003cth\u003eUse For\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSchedulers.parallel()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCPU-bound work, sized to CPU cores\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSchedulers.boundedElastic()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eBlocking IO wrappers, sized dynamically (max 10√óCPU)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSchedulers.immediate()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCurrent thread (no context switch)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSchedulers.single()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSequential background tasks, 1 thread\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eWrapping Blocking IO in Reactor\u003c/h3\u003e\n\u003cp\u003eIf you are migrating an existing application to WebFlux incrementally, you will likely have some JDBC or legacy code that cannot be made reactive immediately. The correct approach is to wrap it in \u003ccode\u003eMono.fromCallable\u003c/code\u003e and offload it to \u003ccode\u003eboundedElastic\u003c/code\u003e, which is specifically designed to handle a dynamic number of blocking IO tasks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Database calls (without R2DBC), legacy APIs ‚Äî wrap in boundedElastic\npublic Mono\u0026#x3C;Order\u003e getOrder(String id) {\n    return Mono.fromCallable(() -\u003e jdbcOrderRepository.findById(id)) // Blocking\n        .subscribeOn(Schedulers.boundedElastic()) // Run on IO-capable scheduler\n        .doOnError(e -\u003e log.error(\"DB error\", e));\n}\n\n// DON'T: Call blocking code on parallel() scheduler ‚Äî starves CPU threads\npublic Mono\u0026#x3C;Order\u003e broken(String id) {\n    return Mono.fromCallable(() -\u003e jdbcOrderRepository.findById(id))\n        .subscribeOn(Schedulers.parallel()); // WRONG for IO\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eOption 4: Virtual Threads (Java 21)\u003c/h2\u003e\n\u003cp\u003eVirtual threads write like blocking code but scale like reactive code. If you are starting a new project on Java 21, virtual threads should be your first consideration for IO-bound services ‚Äî they give you the readability of blocking code without the scalability ceiling of platform threads and without the learning curve of reactive programming:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Same blocking code ‚Äî but runs on a virtual thread\n// No CompletableFuture composition, no subscribeOn, no reactive operators\n@GetMapping(\"/orders/{id}\")\npublic OrderDetail getOrderDetail(@PathVariable String id) {\n    // All these block the current virtual thread ‚Äî not the OS carrier thread\n    Order order = orderRepository.findById(id)  // Blocks VT\n        .orElseThrow(() -\u003e new OrderNotFoundException(id));\n\n    Item item = inventoryClient.getItem(order.getItemId()); // Blocks VT\n\n    return new OrderDetail(order, item); // Simple, readable, debuggable\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompare this to the equivalent \u003ccode\u003eMono\u003c/code\u003e-based version above. The virtual thread version is shorter, has full stack traces, works naturally with debuggers, and is immediately readable to anyone who knows Java ‚Äî without sacrificing the ability to handle thousands of concurrent requests. See the Java Virtual Threads article for full details on configuration and pitfalls.\u003c/p\u003e\n\u003ch2\u003eDecision Tree\u003c/h2\u003e\n\u003cp\u003eWith all four options covered, use this decision tree to choose the right approach for your situation. The single most impactful question is whether you are on Java 21 or later ‚Äî if you are, virtual threads eliminate most of the reasons to reach for \u003ccode\u003eCompletableFuture\u003c/code\u003e or Reactor for IO-bound work:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eIs your workload IO-bound (DB, HTTP, files)?\n‚îú‚îÄ‚îÄ YES: How many concurrent requests?\n‚îÇ   ‚îú‚îÄ‚îÄ \u0026#x3C; 500: Platform threads (blocking), simple, fast to develop\n‚îÇ   ‚îú‚îÄ‚îÄ 500-10K: Virtual threads (Java 21) OR CompletableFuture\n‚îÇ   ‚îî‚îÄ‚îÄ \u003e 10K: Virtual threads (Java 21) OR Reactive (WebFlux + R2DBC)\n‚îÇ\n‚îî‚îÄ‚îÄ NO (CPU-bound: sorting, compression, ML inference):\n    ‚îî‚îÄ‚îÄ ForkJoinPool / parallel streams (thread-per-core)\n\nUsing Java 21+?\n‚îú‚îÄ‚îÄ YES: Virtual threads for most IO cases ‚Äî simple and scalable\n‚îî‚îÄ‚îÄ NO:  CompletableFuture (fan-out) or Reactor (streaming, backpressure)\n\nNeed backpressure (consumer slower than producer)?\n‚îî‚îÄ‚îÄ YES: Project Reactor Flux ‚Äî built-in backpressure via demand signals\n\nNeed to stream data to client (SSE, WebSocket)?\n‚îî‚îÄ‚îÄ YES: Project Reactor Flux with streaming media type\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ePerformance Comparison (IO-bound, 50ms wait per request)\u003c/h2\u003e\n\u003cp\u003eThe numbers in the table below are the most important takeaway from this article. They quantify what the decision tree above implies: at low concurrency every approach performs similarly, but the differences become dramatic as you scale past the platform thread pool limit. Notice how blocking threads hit a hard wall while the other approaches continue to scale:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eConcurrency ‚îÇ Blocking (200 threads) ‚îÇ CompletableFuture ‚îÇ Reactor ‚îÇ Virtual Threads\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       200  ‚îÇ 3,900 rps, p99: 52ms   ‚îÇ 3,950 rps, 51ms   ‚îÇ 3,980   ‚îÇ 3,960 rps, 51ms\n     1,000  ‚îÇ   980 rps, p99: 1.02s  ‚îÇ 9,700 rps, 103ms  ‚îÇ 9,800   ‚îÇ 9,800 rps, 52ms\n    10,000  ‚îÇ timeout (queue full)   ‚îÇ 47K rps, 210ms    ‚îÇ 96K rps  ‚îÇ 97K rps, 53ms\n    50,000  ‚îÇ OOM                    ‚îÇ 50K rps, OOM risk ‚îÇ 97K rps  ‚îÇ 96K rps, 56ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eTakeaways:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCompletableFuture helps but still requires thread pool management\u003c/li\u003e\n\u003cli\u003eReactor and virtual threads achieve similar throughput for IO-bound workloads\u003c/li\u003e\n\u003cli\u003eReactor has better backpressure for streaming; virtual threads are simpler to write and maintain\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe right choice depends on your Java version, team familiarity, and streaming requirements ‚Äî not on which paradigm is theoretically \"best\".\u003c/p\u003e\n","tableOfContents":[{"id":"the-core-problem-threads-are-expensive","text":"The Core Problem: Threads Are Expensive","level":2},{"id":"option-1-blocking-io-with-bounded-thread-pool","text":"Option 1: Blocking I/O with Bounded Thread Pool","level":2},{"id":"option-2-completablefuture-async-composition","text":"Option 2: CompletableFuture ‚Äî Async Composition","level":2},{"id":"completablefuture-chaining","text":"CompletableFuture Chaining","level":3},{"id":"completablefuture-pitfalls","text":"CompletableFuture Pitfalls","level":3},{"id":"option-3-project-reactor-spring-webflux","text":"Option 3: Project Reactor (Spring WebFlux)","level":2},{"id":"subscribeon-vs-publishon","text":"subscribeOn vs publishOn","level":3},{"id":"wrapping-blocking-io-in-reactor","text":"Wrapping Blocking IO in Reactor","level":3},{"id":"option-4-virtual-threads-java-21","text":"Option 4: Virtual Threads (Java 21)","level":2},{"id":"decision-tree","text":"Decision Tree","level":2},{"id":"performance-comparison-io-bound-50ms-wait-per-request","text":"Performance Comparison (IO-bound, 50ms wait per request)","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th‚Ä¶"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"sync-async-patterns-java"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>