<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns<!-- --> | CodeSprintPro</title><meta name="description" content="Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/websocket-sse-real-time/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns" data-next-head=""/><meta property="og:description" content="Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/websocket-sse-real-time/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-05-04" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="System Design" data-next-head=""/><meta property="article:tag" content="websocket" data-next-head=""/><meta property="article:tag" content="sse" data-next-head=""/><meta property="article:tag" content="real-time" data-next-head=""/><meta property="article:tag" content="spring boot" data-next-head=""/><meta property="article:tag" content="redis" data-next-head=""/><meta property="article:tag" content="stomp" data-next-head=""/><meta property="article:tag" content="pub-sub" data-next-head=""/><meta property="article:tag" content="system design" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns" data-next-head=""/><meta name="twitter:description" content="Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns","description":"Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-05-04","dateModified":"2025-05-04","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/websocket-sse-real-time/"},"keywords":"websocket, sse, real-time, spring boot, redis, stomp, pub-sub, system design","articleSection":"System Design"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">System Design</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>May 4, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->websocket</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->sse</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->real-time</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->spring boot</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->redis</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->stomp</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->pub-sub</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->system design</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Real-time features â€” live notifications, collaborative editing, live dashboards, streaming data â€” require pushing data from server to client without the client repeatedly polling. HTTP polling wastes resources and adds latency. WebSocket and Server-Sent Events (SSE) solve this differently, and choosing the wrong protocol for your use case leads to unnecessary complexity.</p>
<h2>WebSocket vs. SSE: Choosing the Right Protocol</h2>
<pre><code>WebSocket:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  HTTP Upgrade   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ Server â”‚
â”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚
â”‚         â”‚    TCP socket    â”‚        â”‚
â”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  (bidirectional)
â”‚         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SSE (Server-Sent Events):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  HTTP GET       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ Server â”‚
â”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event1
â”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event2  (one-directional)
â”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event3
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<table>
<thead>
<tr>
<th>Factor</th>
<th>WebSocket</th>
<th>SSE</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direction</td>
<td>Bidirectional</td>
<td>Server â†’ Client only</td>
</tr>
<tr>
<td>Protocol</td>
<td>ws:// (TCP upgrade)</td>
<td>HTTP (text/event-stream)</td>
</tr>
<tr>
<td>Reconnection</td>
<td>Manual</td>
<td>Automatic (browser handles)</td>
</tr>
<tr>
<td>Load balancer support</td>
<td>Complex (sticky sessions)</td>
<td>Standard HTTP</td>
</tr>
<tr>
<td>CDN/proxy compatible</td>
<td>Rarely</td>
<td>Yes</td>
</tr>
<tr>
<td>Max connections/server</td>
<td>~50,000</td>
<td>~50,000</td>
</tr>
<tr>
<td>Browser support</td>
<td>All</td>
<td>All (no IE)</td>
</tr>
</tbody>
</table>
<p><strong>Use WebSocket when:</strong> bidirectional communication is required (chat, collaborative editing, multiplayer games).</p>
<p><strong>Use SSE when:</strong> server pushes updates, client only reads (live dashboards, notifications, activity feeds, progress updates). SSE is simpler, works through standard HTTP infrastructure, and handles reconnection automatically.</p>
<h2>SSE Implementation</h2>
<p>SSE is the often-overlooked simpler alternative. For one-directional streaming, it's almost always the right choice:</p>
<pre><code class="language-java">// Spring Boot SSE endpoint:
@RestController
@RequestMapping("/api/notifications")
public class NotificationController {

    @Autowired
    private SseEmitterRegistry emitterRegistry;

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter streamNotifications(@AuthenticationPrincipal Jwt jwt) {
        String userId = jwt.getSubject();

        // SseEmitter with 5-minute timeout (reconnect handles longer sessions):
        SseEmitter emitter = new SseEmitter(5 * 60 * 1000L);

        // Register emitter so other parts of the system can push to this user:
        emitterRegistry.register(userId, emitter);

        // Cleanup on connection close:
        emitter.onCompletion(() -> emitterRegistry.remove(userId, emitter));
        emitter.onTimeout(() -> emitterRegistry.remove(userId, emitter));
        emitter.onError(ex -> emitterRegistry.remove(userId, emitter));

        // Send initial state (so client doesn't wait for first event):
        try {
            emitter.send(SseEmitter.event()
                .name("connected")
                .data("{\"status\":\"connected\",\"userId\":\"" + userId + "\"}")
                .id("0")
            );
        } catch (IOException e) {
            emitter.completeWithError(e);
        }

        return emitter;
    }
}

// Registry of active SSE connections:
@Component
public class SseEmitterRegistry {

    // CopyOnWriteArrayList: multiple emitters per user (same user, multiple tabs)
    private final Map&#x3C;String, CopyOnWriteArrayList&#x3C;SseEmitter>> userEmitters =
        new ConcurrentHashMap&#x3C;>();

    public void register(String userId, SseEmitter emitter) {
        userEmitters.computeIfAbsent(userId, k -> new CopyOnWriteArrayList&#x3C;>()).add(emitter);
    }

    public void remove(String userId, SseEmitter emitter) {
        CopyOnWriteArrayList&#x3C;SseEmitter> emitters = userEmitters.get(userId);
        if (emitters != null) {
            emitters.remove(emitter);
            if (emitters.isEmpty()) {
                userEmitters.remove(userId);
            }
        }
    }

    public void sendToUser(String userId, String eventName, Object data) {
        CopyOnWriteArrayList&#x3C;SseEmitter> emitters = userEmitters.get(userId);
        if (emitters == null || emitters.isEmpty()) return;

        String json = objectMapper.writeValueAsString(data);
        List&#x3C;SseEmitter> dead = new ArrayList&#x3C;>();

        for (SseEmitter emitter : emitters) {
            try {
                emitter.send(SseEmitter.event()
                    .name(eventName)
                    .data(json)
                    .id(String.valueOf(System.currentTimeMillis()))
                );
            } catch (IOException e) {
                dead.add(emitter);  // Connection is dead
            }
        }

        dead.forEach(e -> remove(userId, e));
    }
}
</code></pre>
<p><strong>Client-side SSE (automatic reconnection built in):</strong></p>
<pre><code class="language-javascript">const eventSource = new EventSource('/api/notifications/stream', {
  withCredentials: true  // Send cookies for authentication
});

eventSource.addEventListener('order-update', (event) => {
  const update = JSON.parse(event.data);
  updateOrderStatus(update.orderId, update.status);
});

eventSource.addEventListener('notification', (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification.message);
});

// Browser automatically reconnects on disconnect
// The Last-Event-ID header is sent on reconnect â€” server can replay missed events
eventSource.onerror = (error) => {
  console.log('SSE error:', error);
  // Browser will retry automatically â€” exponential backoff
};
</code></pre>
<h2>WebSocket with STOMP (Spring Boot)</h2>
<p>STOMP (Simple Text Oriented Messaging Protocol) adds message routing over WebSocket â€” subscribe to topics, send to specific users:</p>
<pre><code class="language-java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Use built-in simple broker for topics and queues:
        config.enableSimpleBroker("/topic", "/queue");
        // Or use external broker (RabbitMQ/ActiveMQ) for production:
        // config.enableStompBrokerRelay("/topic", "/queue")
        //     .setRelayHost("rabbitmq.internal")
        //     .setRelayPort(61613);

        // Application destination prefix (for @MessageMapping):
        config.setApplicationDestinationPrefixes("/app");

        // User-specific destination prefix (for SimpMessagingTemplate.convertAndSendToUser):
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
            .setAllowedOrigins("https://app.example.com")  // CORS
            .withSockJS();  // SockJS fallback for environments blocking WebSocket
    }
}

// Controller: handle messages FROM client:
@Controller
public class ChatController {

    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    // Client sends to /app/chat.sendMessage â†’ broadcast to /topic/chat
    @MessageMapping("/chat.sendMessage")
    @SendTo("/topic/chat")  // Broadcast to all subscribers
    public ChatMessage sendMessage(@Payload ChatMessage message,
                                   Principal principal) {
        message.setSender(principal.getName());
        message.setTimestamp(Instant.now());
        return message;
    }

    // Send to specific user's private queue:
    public void sendPrivateMessage(String userId, Notification notification) {
        // Client subscribes to /user/queue/notifications
        // This sends to THAT specific user's queue:
        messagingTemplate.convertAndSendToUser(
            userId,
            "/queue/notifications",
            notification
        );
    }
}
</code></pre>
<p><strong>WebSocket authentication (often overlooked):</strong></p>
<pre><code class="language-java">@Component
public class WebSocketAuthInterceptor implements ChannelInterceptor {

    @Autowired
    private JwtService jwtService;

    @Override
    public Message&#x3C;?> preSend(Message&#x3C;?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(
            message, StompHeaderAccessor.class);

        if (accessor != null &#x26;&#x26; StompCommand.CONNECT.equals(accessor.getCommand())) {
            // Extract JWT from Authorization header in CONNECT frame:
            String authHeader = accessor.getFirstNativeHeader("Authorization");
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                throw new MessagingException("Missing or invalid Authorization header");
            }

            String token = authHeader.substring(7);
            Authentication auth = jwtService.validateAndGetAuth(token);

            // Set the authenticated principal on the WebSocket session:
            accessor.setUser(auth);
        }

        return message;
    }
}
</code></pre>
<h2>Horizontal Scaling: The Core Problem</h2>
<p>Each server instance maintains its own in-memory set of WebSocket/SSE connections. When an event occurs (e.g., "order shipped"), it needs to reach the user's connection â€” which may be on a different server instance.</p>
<pre><code>Without Redis pub/sub (BROKEN at scale):

User connects â†’ Server A (SSE connection stored here)
Order ships   â†’ Event processed by Server B
Server B sends SSE â†’ Nobody receives it (connection is on Server A)

With Redis pub/sub (CORRECT):

User connects â†’ Server A (SSE stored)
Order ships   â†’ Server B publishes to Redis: channel="user:{userId}", msg=event
Redis broadcasts â†’ Server A receives it (subscribed to all user channels)
Server A sends SSE â†’ User receives event âœ“
</code></pre>
<pre><code class="language-java">// Redis pub/sub for cross-instance SSE delivery:
@Service
public class NotificationPublisher {

    @Autowired
    private RedisTemplate&#x3C;String, String> redisTemplate;

    public void publishToUser(String userId, NotificationEvent event) {
        String channel = "user-notifications:" + userId;
        String payload = objectMapper.writeValueAsString(event);
        redisTemplate.convertAndSend(channel, payload);
    }
}

@Service
public class NotificationSubscriber implements MessageListener {

    @Autowired
    private SseEmitterRegistry emitterRegistry;

    @Autowired
    private RedisMessageListenerContainer container;

    @PostConstruct
    public void subscribeToAllUsers() {
        // Subscribe to all user notification channels:
        container.addMessageListener(this,
            new PatternTopic("user-notifications:*"));
    }

    @Override
    public void onMessage(Message message, byte[] pattern) {
        String channel = new String(message.getChannel());
        String userId = channel.replace("user-notifications:", "");
        String payload = new String(message.getBody());

        // Push to local SSE connection (if user is connected to this instance):
        emitterRegistry.sendToUser(userId, "notification", payload);
    }
}
</code></pre>
<h2>Backpressure and Slow Clients</h2>
<p>A client that consumes events slowly creates backpressure. The server must not buffer unboundedly:</p>
<pre><code class="language-java">// Bounded SSE with overflow handling:
public class BoundedSseEmitter {

    private final SseEmitter emitter;
    private final BlockingQueue&#x3C;SseEvent> queue = new LinkedBlockingQueue&#x3C;>(100);
    private final AtomicBoolean running = new AtomicBoolean(true);

    public BoundedSseEmitter(SseEmitter emitter) {
        this.emitter = emitter;
        // Background thread drains queue to emitter:
        Thread.ofVirtual().start(this::drain);
    }

    public boolean offer(SseEvent event) {
        boolean accepted = queue.offer(event);  // Returns false if queue full
        if (!accepted) {
            log.warn("SSE queue full for connection â€” dropping event");
            // Or: disconnect slow client
        }
        return accepted;
    }

    private void drain() {
        while (running.get()) {
            try {
                SseEvent event = queue.poll(1, TimeUnit.SECONDS);
                if (event != null) {
                    emitter.send(event);
                }
            } catch (Exception e) {
                running.set(false);
            }
        }
    }
}
</code></pre>
<p>Real-time features are rarely the hardest part of a system â€” they feel complex because HTTP's request-response model is the mental default. Once you internalize that SSE is just a long-lived HTTP response that trickles data, and WebSocket is a bidirectional TCP channel negotiated via HTTP, the implementation patterns become straightforward. The operational complexity (scaling with Redis pub/sub, handling reconnections, managing connection counts) is where production experience matters.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">System Design Interview â€” Alex Xu</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Step-by-step guide to ace system design interviews with real-world examples.</p></div><a href="https://amzn.to/3TqsPRp" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Grokking System Design on Educative</span></div><p class="text-xs text-gray-600">Interactive course teaching system design with visual diagrams and practice problems.</p></div><a href="https://www.educative.io/courses/grokking-the-system-design-interview" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span></div><p class="text-xs text-gray-600">Martin Kleppmann&#x27;s book is essential reading for any system design role.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=WebSocket%20and%20SSE%20for%20Real-Time%20Systems%3A%20Architecture%20and%20Production%20Patterns&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fwebsocket-sse-real-time%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fwebsocket-sse-real-time%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#websocket-vs-sse-choosing-the-right-protocol" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">WebSocket vs. SSE: Choosing the Right Protocol</a></li><li class=""><a href="#sse-implementation" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">SSE Implementation</a></li><li class=""><a href="#websocket-with-stomp-spring-boot" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">WebSocket with STOMP (Spring Boot)</a></li><li class=""><a href="#horizontal-scaling-the-core-problem" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Horizontal Scaling: The Core Problem</a></li><li class=""><a href="#backpressure-and-slow-clients" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Backpressure and Slow Clients</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/observability-opentelemetry-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Building Production Observability with OpenTelemetry and Grafana Stack</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>6 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->observability</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->opentelemetry</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->prometheus</span></div></article></a><a href="/blog/event-sourcing-cqrs-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Event Sourcing and CQRS in Production: Beyond the Theory</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 23, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->event sourcing</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cqrs</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->system design</span></div></article></a><a href="/blog/grpc-vs-rest-vs-graphql/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">gRPC vs REST vs GraphQL: Choosing the Right API Protocol</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->grpc</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->rest</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->graphql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns","description":"Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure.","date":"2025-05-04","category":"System Design","tags":["websocket","sse","real-time","spring boot","redis","stomp","pub-sub","system design"],"featured":false,"affiliateSection":"system-design-courses","slug":"websocket-sse-real-time","readingTime":"7 min read","excerpt":"Real-time features â€” live notifications, collaborative editing, live dashboards, streaming data â€” require pushing data from server to client without the client repeatedly polling. HTTP polling wastes resources and adds lâ€¦","contentHtml":"\u003cp\u003eReal-time features â€” live notifications, collaborative editing, live dashboards, streaming data â€” require pushing data from server to client without the client repeatedly polling. HTTP polling wastes resources and adds latency. WebSocket and Server-Sent Events (SSE) solve this differently, and choosing the wrong protocol for your use case leads to unnecessary complexity.\u003c/p\u003e\n\u003ch2\u003eWebSocket vs. SSE: Choosing the Right Protocol\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eWebSocket:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  HTTP Upgrade   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ Server â”‚\nâ”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚\nâ”‚         â”‚    TCP socket    â”‚        â”‚\nâ”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  (bidirectional)\nâ”‚         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSSE (Server-Sent Events):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  HTTP GET       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ Server â”‚\nâ”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event1\nâ”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event2  (one-directional)\nâ”‚         â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚        â”‚  data: event3\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eFactor\u003c/th\u003e\n\u003cth\u003eWebSocket\u003c/th\u003e\n\u003cth\u003eSSE\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eDirection\u003c/td\u003e\n\u003ctd\u003eBidirectional\u003c/td\u003e\n\u003ctd\u003eServer â†’ Client only\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eProtocol\u003c/td\u003e\n\u003ctd\u003ews:// (TCP upgrade)\u003c/td\u003e\n\u003ctd\u003eHTTP (text/event-stream)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eReconnection\u003c/td\u003e\n\u003ctd\u003eManual\u003c/td\u003e\n\u003ctd\u003eAutomatic (browser handles)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLoad balancer support\u003c/td\u003e\n\u003ctd\u003eComplex (sticky sessions)\u003c/td\u003e\n\u003ctd\u003eStandard HTTP\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCDN/proxy compatible\u003c/td\u003e\n\u003ctd\u003eRarely\u003c/td\u003e\n\u003ctd\u003eYes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMax connections/server\u003c/td\u003e\n\u003ctd\u003e~50,000\u003c/td\u003e\n\u003ctd\u003e~50,000\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBrowser support\u003c/td\u003e\n\u003ctd\u003eAll\u003c/td\u003e\n\u003ctd\u003eAll (no IE)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eUse WebSocket when:\u003c/strong\u003e bidirectional communication is required (chat, collaborative editing, multiplayer games).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUse SSE when:\u003c/strong\u003e server pushes updates, client only reads (live dashboards, notifications, activity feeds, progress updates). SSE is simpler, works through standard HTTP infrastructure, and handles reconnection automatically.\u003c/p\u003e\n\u003ch2\u003eSSE Implementation\u003c/h2\u003e\n\u003cp\u003eSSE is the often-overlooked simpler alternative. For one-directional streaming, it's almost always the right choice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Spring Boot SSE endpoint:\n@RestController\n@RequestMapping(\"/api/notifications\")\npublic class NotificationController {\n\n    @Autowired\n    private SseEmitterRegistry emitterRegistry;\n\n    @GetMapping(value = \"/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n    public SseEmitter streamNotifications(@AuthenticationPrincipal Jwt jwt) {\n        String userId = jwt.getSubject();\n\n        // SseEmitter with 5-minute timeout (reconnect handles longer sessions):\n        SseEmitter emitter = new SseEmitter(5 * 60 * 1000L);\n\n        // Register emitter so other parts of the system can push to this user:\n        emitterRegistry.register(userId, emitter);\n\n        // Cleanup on connection close:\n        emitter.onCompletion(() -\u003e emitterRegistry.remove(userId, emitter));\n        emitter.onTimeout(() -\u003e emitterRegistry.remove(userId, emitter));\n        emitter.onError(ex -\u003e emitterRegistry.remove(userId, emitter));\n\n        // Send initial state (so client doesn't wait for first event):\n        try {\n            emitter.send(SseEmitter.event()\n                .name(\"connected\")\n                .data(\"{\\\"status\\\":\\\"connected\\\",\\\"userId\\\":\\\"\" + userId + \"\\\"}\")\n                .id(\"0\")\n            );\n        } catch (IOException e) {\n            emitter.completeWithError(e);\n        }\n\n        return emitter;\n    }\n}\n\n// Registry of active SSE connections:\n@Component\npublic class SseEmitterRegistry {\n\n    // CopyOnWriteArrayList: multiple emitters per user (same user, multiple tabs)\n    private final Map\u0026#x3C;String, CopyOnWriteArrayList\u0026#x3C;SseEmitter\u003e\u003e userEmitters =\n        new ConcurrentHashMap\u0026#x3C;\u003e();\n\n    public void register(String userId, SseEmitter emitter) {\n        userEmitters.computeIfAbsent(userId, k -\u003e new CopyOnWriteArrayList\u0026#x3C;\u003e()).add(emitter);\n    }\n\n    public void remove(String userId, SseEmitter emitter) {\n        CopyOnWriteArrayList\u0026#x3C;SseEmitter\u003e emitters = userEmitters.get(userId);\n        if (emitters != null) {\n            emitters.remove(emitter);\n            if (emitters.isEmpty()) {\n                userEmitters.remove(userId);\n            }\n        }\n    }\n\n    public void sendToUser(String userId, String eventName, Object data) {\n        CopyOnWriteArrayList\u0026#x3C;SseEmitter\u003e emitters = userEmitters.get(userId);\n        if (emitters == null || emitters.isEmpty()) return;\n\n        String json = objectMapper.writeValueAsString(data);\n        List\u0026#x3C;SseEmitter\u003e dead = new ArrayList\u0026#x3C;\u003e();\n\n        for (SseEmitter emitter : emitters) {\n            try {\n                emitter.send(SseEmitter.event()\n                    .name(eventName)\n                    .data(json)\n                    .id(String.valueOf(System.currentTimeMillis()))\n                );\n            } catch (IOException e) {\n                dead.add(emitter);  // Connection is dead\n            }\n        }\n\n        dead.forEach(e -\u003e remove(userId, e));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eClient-side SSE (automatic reconnection built in):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst eventSource = new EventSource('/api/notifications/stream', {\n  withCredentials: true  // Send cookies for authentication\n});\n\neventSource.addEventListener('order-update', (event) =\u003e {\n  const update = JSON.parse(event.data);\n  updateOrderStatus(update.orderId, update.status);\n});\n\neventSource.addEventListener('notification', (event) =\u003e {\n  const notification = JSON.parse(event.data);\n  showNotification(notification.message);\n});\n\n// Browser automatically reconnects on disconnect\n// The Last-Event-ID header is sent on reconnect â€” server can replay missed events\neventSource.onerror = (error) =\u003e {\n  console.log('SSE error:', error);\n  // Browser will retry automatically â€” exponential backoff\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eWebSocket with STOMP (Spring Boot)\u003c/h2\u003e\n\u003cp\u003eSTOMP (Simple Text Oriented Messaging Protocol) adds message routing over WebSocket â€” subscribe to topics, send to specific users:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        // Use built-in simple broker for topics and queues:\n        config.enableSimpleBroker(\"/topic\", \"/queue\");\n        // Or use external broker (RabbitMQ/ActiveMQ) for production:\n        // config.enableStompBrokerRelay(\"/topic\", \"/queue\")\n        //     .setRelayHost(\"rabbitmq.internal\")\n        //     .setRelayPort(61613);\n\n        // Application destination prefix (for @MessageMapping):\n        config.setApplicationDestinationPrefixes(\"/app\");\n\n        // User-specific destination prefix (for SimpMessagingTemplate.convertAndSendToUser):\n        config.setUserDestinationPrefix(\"/user\");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\")\n            .setAllowedOrigins(\"https://app.example.com\")  // CORS\n            .withSockJS();  // SockJS fallback for environments blocking WebSocket\n    }\n}\n\n// Controller: handle messages FROM client:\n@Controller\npublic class ChatController {\n\n    @Autowired\n    private SimpMessagingTemplate messagingTemplate;\n\n    // Client sends to /app/chat.sendMessage â†’ broadcast to /topic/chat\n    @MessageMapping(\"/chat.sendMessage\")\n    @SendTo(\"/topic/chat\")  // Broadcast to all subscribers\n    public ChatMessage sendMessage(@Payload ChatMessage message,\n                                   Principal principal) {\n        message.setSender(principal.getName());\n        message.setTimestamp(Instant.now());\n        return message;\n    }\n\n    // Send to specific user's private queue:\n    public void sendPrivateMessage(String userId, Notification notification) {\n        // Client subscribes to /user/queue/notifications\n        // This sends to THAT specific user's queue:\n        messagingTemplate.convertAndSendToUser(\n            userId,\n            \"/queue/notifications\",\n            notification\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWebSocket authentication (often overlooked):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class WebSocketAuthInterceptor implements ChannelInterceptor {\n\n    @Autowired\n    private JwtService jwtService;\n\n    @Override\n    public Message\u0026#x3C;?\u003e preSend(Message\u0026#x3C;?\u003e message, MessageChannel channel) {\n        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(\n            message, StompHeaderAccessor.class);\n\n        if (accessor != null \u0026#x26;\u0026#x26; StompCommand.CONNECT.equals(accessor.getCommand())) {\n            // Extract JWT from Authorization header in CONNECT frame:\n            String authHeader = accessor.getFirstNativeHeader(\"Authorization\");\n            if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n                throw new MessagingException(\"Missing or invalid Authorization header\");\n            }\n\n            String token = authHeader.substring(7);\n            Authentication auth = jwtService.validateAndGetAuth(token);\n\n            // Set the authenticated principal on the WebSocket session:\n            accessor.setUser(auth);\n        }\n\n        return message;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHorizontal Scaling: The Core Problem\u003c/h2\u003e\n\u003cp\u003eEach server instance maintains its own in-memory set of WebSocket/SSE connections. When an event occurs (e.g., \"order shipped\"), it needs to reach the user's connection â€” which may be on a different server instance.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWithout Redis pub/sub (BROKEN at scale):\n\nUser connects â†’ Server A (SSE connection stored here)\nOrder ships   â†’ Event processed by Server B\nServer B sends SSE â†’ Nobody receives it (connection is on Server A)\n\nWith Redis pub/sub (CORRECT):\n\nUser connects â†’ Server A (SSE stored)\nOrder ships   â†’ Server B publishes to Redis: channel=\"user:{userId}\", msg=event\nRedis broadcasts â†’ Server A receives it (subscribed to all user channels)\nServer A sends SSE â†’ User receives event âœ“\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Redis pub/sub for cross-instance SSE delivery:\n@Service\npublic class NotificationPublisher {\n\n    @Autowired\n    private RedisTemplate\u0026#x3C;String, String\u003e redisTemplate;\n\n    public void publishToUser(String userId, NotificationEvent event) {\n        String channel = \"user-notifications:\" + userId;\n        String payload = objectMapper.writeValueAsString(event);\n        redisTemplate.convertAndSend(channel, payload);\n    }\n}\n\n@Service\npublic class NotificationSubscriber implements MessageListener {\n\n    @Autowired\n    private SseEmitterRegistry emitterRegistry;\n\n    @Autowired\n    private RedisMessageListenerContainer container;\n\n    @PostConstruct\n    public void subscribeToAllUsers() {\n        // Subscribe to all user notification channels:\n        container.addMessageListener(this,\n            new PatternTopic(\"user-notifications:*\"));\n    }\n\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        String channel = new String(message.getChannel());\n        String userId = channel.replace(\"user-notifications:\", \"\");\n        String payload = new String(message.getBody());\n\n        // Push to local SSE connection (if user is connected to this instance):\n        emitterRegistry.sendToUser(userId, \"notification\", payload);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eBackpressure and Slow Clients\u003c/h2\u003e\n\u003cp\u003eA client that consumes events slowly creates backpressure. The server must not buffer unboundedly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Bounded SSE with overflow handling:\npublic class BoundedSseEmitter {\n\n    private final SseEmitter emitter;\n    private final BlockingQueue\u0026#x3C;SseEvent\u003e queue = new LinkedBlockingQueue\u0026#x3C;\u003e(100);\n    private final AtomicBoolean running = new AtomicBoolean(true);\n\n    public BoundedSseEmitter(SseEmitter emitter) {\n        this.emitter = emitter;\n        // Background thread drains queue to emitter:\n        Thread.ofVirtual().start(this::drain);\n    }\n\n    public boolean offer(SseEvent event) {\n        boolean accepted = queue.offer(event);  // Returns false if queue full\n        if (!accepted) {\n            log.warn(\"SSE queue full for connection â€” dropping event\");\n            // Or: disconnect slow client\n        }\n        return accepted;\n    }\n\n    private void drain() {\n        while (running.get()) {\n            try {\n                SseEvent event = queue.poll(1, TimeUnit.SECONDS);\n                if (event != null) {\n                    emitter.send(event);\n                }\n            } catch (Exception e) {\n                running.set(false);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReal-time features are rarely the hardest part of a system â€” they feel complex because HTTP's request-response model is the mental default. Once you internalize that SSE is just a long-lived HTTP response that trickles data, and WebSocket is a bidirectional TCP channel negotiated via HTTP, the implementation patterns become straightforward. The operational complexity (scaling with Redis pub/sub, handling reconnections, managing connection counts) is where production experience matters.\u003c/p\u003e\n","tableOfContents":[{"id":"websocket-vs-sse-choosing-the-right-protocol","text":"WebSocket vs. SSE: Choosing the Right Protocol","level":2},{"id":"sse-implementation","text":"SSE Implementation","level":2},{"id":"websocket-with-stomp-spring-boot","text":"WebSocket with STOMP (Spring Boot)","level":2},{"id":"horizontal-scaling-the-core-problem","text":"Horizontal Scaling: The Core Problem","level":2},{"id":"backpressure-and-slow-clients","text":"Backpressure and Slow Clients","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"websocket-sse-real-time"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>