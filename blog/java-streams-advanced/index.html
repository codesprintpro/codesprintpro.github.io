<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Java Streams API: Advanced Patterns and Performance<!-- --> | CodeSprintPro</title><meta name="description" content="Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/java-streams-advanced/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Java Streams API: Advanced Patterns and Performance" data-next-head=""/><meta property="og:description" content="Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/java-streams-advanced/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-03-21" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="streams" data-next-head=""/><meta property="article:tag" content="functional programming" data-next-head=""/><meta property="article:tag" content="collections" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Java Streams API: Advanced Patterns and Performance" data-next-head=""/><meta name="twitter:description" content="Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Streams API: Advanced Patterns and Performance","description":"Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-03-21","dateModified":"2025-03-21","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/java-streams-advanced/"},"keywords":"java, streams, functional programming, collections, performance","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Java Streams API: Advanced Patterns and Performance</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Java Streams API: Advanced Patterns and Performance</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>March 21, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->streams</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->functional programming</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->collections</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Most engineers use Java Streams for map/filter/collect and stop there. The full Streams API is significantly more powerful: custom collectors that aggregate in a single pass, flatMap for flattening nested structures, parallel streams that scale across CPU cores, and collector combinators that compose complex aggregations. This article covers the patterns that separate proficient from expert Java developers.</p>
<h2>FlatMap: Working with Nested Structures</h2>
<p><code>flatMap</code> transforms each element into a stream and merges all those streams. Think of it as a two-step operation: first map each element to a stream, then flatten all those streams into one. This is the correct tool whenever you have a collection of collections and need to work with the inner elements directly.</p>
<pre><code class="language-java">// Problem: List of orders, each with List of items ‚Äî get all items
List&#x3C;Order> orders = getOrders();

// Wrong (returns Stream&#x3C;List&#x3C;OrderItem>>):
Stream&#x3C;List&#x3C;OrderItem>> wrong = orders.stream().map(Order::getItems);

// Correct (returns Stream&#x3C;OrderItem>):
Stream&#x3C;OrderItem> allItems = orders.stream()
    .flatMap(order -> order.getItems().stream());

// Practical: find all unique product IDs ordered by a customer
Set&#x3C;String> productIds = orders.stream()
    .flatMap(order -> order.getItems().stream())
    .map(OrderItem::getProductId)
    .collect(Collectors.toSet());

// Chain: orders with items above threshold
List&#x3C;OrderItem> expensiveItems = orders.stream()
    .flatMap(order -> order.getItems().stream()
        .filter(item -> item.getPrice().compareTo(BigDecimal.valueOf(100)) > 0)
        .map(item -> item.withOrderId(order.getId()))  // Add context from outer
    )
    .collect(Collectors.toList());

// Optional flatMap: chain of optional operations
Optional&#x3C;String> customerEmail = findOrder("order-123")
    .flatMap(order -> findCustomer(order.getCustomerId()))
    .flatMap(customer -> Optional.ofNullable(customer.getEmail()));
// Returns empty if any step is empty ‚Äî clean Optional chaining
</code></pre>
<p>The <code>Optional.flatMap</code> usage at the end is a particularly useful pattern: it lets you chain a sequence of operations where any step might produce an empty result, without nested null checks or <code>if</code> statements.</p>
<h2>Collectors: Beyond toList()</h2>
<p>The real power of the Streams API lies in its collectors. While <code>toList()</code> handles the common case, <code>Collectors</code> includes a rich set of aggregation operations that can replace what would otherwise be multiple passes over the data or complex imperative loops. The key insight is that collectors are composable ‚Äî you can nest them to express sophisticated aggregations in a single, readable pipeline:</p>
<pre><code class="language-java">// groupingBy: most powerful collector
Map&#x3C;String, List&#x3C;Order>> ordersByStatus = orders.stream()
    .collect(Collectors.groupingBy(Order::getStatus));

// groupingBy with downstream collector
Map&#x3C;String, Long> countByStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getStatus,
        Collectors.counting()
    ));

// Multi-level grouping
Map&#x3C;String, Map&#x3C;String, BigDecimal>> totalByCustomerAndStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getCustomerId,
        Collectors.groupingBy(
            Order::getStatus,
            Collectors.reducing(
                BigDecimal.ZERO,
                Order::getTotal,
                BigDecimal::add
            )
        )
    ));

// partitioningBy: split into true/false
Map&#x3C;Boolean, List&#x3C;Order>> activeVsCancelled = orders.stream()
    .collect(Collectors.partitioningBy(
        order -> !order.getStatus().equals("CANCELLED")
    ));
List&#x3C;Order> activeOrders = activeVsCancelled.get(true);

// toMap with merge function (handles duplicate keys)
Map&#x3C;String, BigDecimal> totalByCustomer = orders.stream()
    .collect(Collectors.toMap(
        Order::getCustomerId,
        Order::getTotal,
        BigDecimal::add  // Merge: add totals for same customer
    ));

// Statistics
IntSummaryStatistics priceStats = products.stream()
    .mapToInt(Product::getPriceCents)
    .summaryStatistics();
System.out.printf("Min: %d, Max: %d, Avg: %.2f, Count: %d%n",
    priceStats.getMin(), priceStats.getMax(),
    priceStats.getAverage(), priceStats.getCount());
</code></pre>
<h2>Custom Collectors</h2>
<p>When built-in collectors don't fit, build your own. A custom collector is composed of four functions: a supplier that creates the mutable accumulator, an accumulator that folds each element into it, a combiner that merges two accumulators (needed for parallel streams), and a finisher that converts the accumulator to the final result. This structure might seem verbose at first, but it gives you complete control over how the aggregation behaves:</p>
<pre><code class="language-java">// Custom collector: find top N elements by a comparator in a single pass
// (more efficient than sorting all then taking first N)
public static &#x3C;T> Collector&#x3C;T, ?, List&#x3C;T>> topN(int n, Comparator&#x3C;T> comparator) {
    return Collector.of(
        () -> new PriorityQueue&#x3C;>(n + 1, comparator),  // Supplier: create accumulator
        (queue, element) -> {                            // Accumulator: add element
            queue.offer(element);
            if (queue.size() > n) queue.poll();         // Keep only top N
        },
        (q1, q2) -> {                                   // Combiner: merge two accumulators (parallel)
            q2.forEach(q1::offer);
            while (q1.size() > n) q1.poll();
            return q1;
        },
        queue -> {                                       // Finisher: convert to result
            List&#x3C;T> result = new ArrayList&#x3C;>(queue);
            result.sort(comparator.reversed());
            return result;
        }
    );
}

// Usage: top 5 most expensive products in a single pass
List&#x3C;Product> top5 = products.stream()
    .collect(topN(5, Comparator.comparing(Product::getPriceCents)));

// Another useful custom collector: running total
public static Collector&#x3C;BigDecimal, ?, List&#x3C;BigDecimal>> runningTotal() {
    return Collector.of(
        () -> new ArrayList&#x3C;BigDecimal>() {{ add(BigDecimal.ZERO); }},
        (list, amount) -> list.add(list.get(list.size() - 1).add(amount)),
        (list1, list2) -> {  // Not meaningful for parallel, but required
            BigDecimal lastTotal = list1.get(list1.size() - 1);
            list2.stream().skip(1).forEach(d -> list1.add(lastTotal.add(d)));
            return list1;
        },
        list -> list.subList(1, list.size())  // Remove initial zero
    );
}

// Running total of daily revenue
List&#x3C;BigDecimal> cumulativeRevenue = dailyRevenue.stream()
    .collect(runningTotal());
</code></pre>
<p>The <code>topN</code> collector is more efficient than the naive <code>sorted().limit(n)</code> approach because it maintains a bounded priority queue of size <code>n</code> ‚Äî it never needs to sort the entire input, making it O(n log k) instead of O(n log n).</p>
<h2>teeing: Combine Two Collectors</h2>
<p>Now that you have a feel for how collectors compose, Java 12's <code>Collectors.teeing</code> takes composability one step further by letting you apply two collectors to the same stream simultaneously and combine their results. This eliminates the need to iterate over the data twice when you need two independent aggregations:</p>
<pre><code class="language-java">// Get count AND total in one pass
record OrderStats(long count, BigDecimal total) {}

OrderStats stats = orders.stream()
    .collect(Collectors.teeing(
        Collectors.counting(),
        Collectors.reducing(BigDecimal.ZERO, Order::getTotal, BigDecimal::add),
        OrderStats::new
    ));

System.out.printf("Count: %d, Total: %s%n", stats.count(), stats.total());

// Split stream into two lists in one pass (more efficient than two filter calls)
record ActiveAndCancelled(List&#x3C;Order> active, List&#x3C;Order> cancelled) {}

ActiveAndCancelled split = orders.stream()
    .collect(Collectors.teeing(
        Collectors.filtering(o -> !o.isCancelled(), Collectors.toList()),
        Collectors.filtering(Order::isCancelled, Collectors.toList()),
        ActiveAndCancelled::new
    ));
</code></pre>
<p>The single-pass guarantee is what makes <code>teeing</code> valuable at scale ‚Äî when your input is a large stream from a database or file, avoiding a second pass over the data has a meaningful impact on both time and memory.</p>
<h2>Parallel Streams: When and How</h2>
<p>With single-threaded streams well understood, it's tempting to reach for <code>parallelStream()</code> everywhere. Resist that urge. Parallel streams split the stream across <code>ForkJoinPool.commonPool()</code> threads and have measurable overhead ‚Äî they help only when the per-element work is expensive enough to outweigh the cost of splitting and merging:</p>
<pre><code class="language-java">// When parallel streams help:
// - Large data sets (> 100K elements)
// - CPU-intensive operations per element
// - Stateless, independent operations
// - Ordered output doesn't matter (order = merge cost)

// Good candidate: CPU-intensive transformation of large list
List&#x3C;ProcessedReport> reports = rawReports.parallelStream()
    .map(r -> processReport(r))          // CPU-intensive
    .filter(r -> r.isSignificant())
    .collect(Collectors.toList());       // Order doesn't matter

// Benchmark: this MIGHT be 4x faster on 4 cores

// When parallel is SLOWER:
// Small data: thread overhead > computation benefit (&#x3C; 1000 elements)
List&#x3C;String> small = Arrays.asList("a", "b", "c");
small.parallelStream().map(String::toUpperCase).collect(Collectors.toList());
// Slower than sequential: creating ForkJoin tasks has 20Œºs overhead

// Stateful operations (bad for parallel):
List&#x3C;Integer> result = new ArrayList&#x3C;>();  // NOT thread-safe!
numbers.parallelStream()
    .filter(n -> n > 0)
    .forEach(result::add);  // RACE CONDITION ‚Äî don't do this
// Correct: use collectors, not forEach with external state

// IO-bound operations (no benefit from parallel):
List&#x3C;String> fetched = urls.parallelStream()
    .map(url -> fetchUrl(url))  // Blocked on I/O, not CPU
    .collect(Collectors.toList());
// Use virtual threads or CompletableFuture instead

// Custom thread pool for parallel streams:
ForkJoinPool customPool = new ForkJoinPool(8);
List&#x3C;Result> results = customPool.submit(() ->
    items.parallelStream()
        .map(this::expensiveOperation)
        .collect(Collectors.toList())
).get();
</code></pre>
<p>Using a custom <code>ForkJoinPool</code> as shown at the end is an important technique when you need to isolate parallel stream work from the JVM's shared common pool ‚Äî for example, when your application also uses other libraries that rely on <code>ForkJoinPool.commonPool()</code> and you do not want them to compete for threads.</p>
<h2>Stream Performance Pitfalls</h2>
<p>Even sequential streams have performance traps worth knowing. These pitfalls are easy to miss during code review because the code looks idiomatic, but each one introduces unnecessary overhead that compounds at scale:</p>
<pre><code class="language-java">// Pitfall 1: Unboxing overhead with boxed streams
// BAD: Integer stream (boxing/unboxing overhead)
int sum = numbers.stream()
    .map(Integer::intValue)    // unnecessary
    .reduce(0, Integer::sum);  // boxes again

// GOOD: Use primitive streams (IntStream, LongStream, DoubleStream)
int sum = numbers.stream()
    .mapToInt(Integer::intValue)  // Returns IntStream (unboxed)
    .sum();                        // No boxing

// Pitfall 2: Collecting to list then re-streaming
// BAD: Creates intermediate list
List&#x3C;String> intermediate = products.stream()
    .filter(p -> p.getPrice() > 100)
    .map(Product::getName)
    .collect(Collectors.toList());  // Materialized here

long count = intermediate.stream().count();  // Re-stream just to count!

// GOOD: Chain in one pipeline
long count = products.stream()
    .filter(p -> p.getPrice() > 100)
    .count();  // Terminal operation ‚Äî no intermediate list

// Pitfall 3: sorted() on large streams
// Sorting requires all elements ‚Üí breaks laziness
// Only sort when the result actually needs ordering

// Pitfall 4: distinct() with expensive equals/hashCode
// distinct() maintains a HashSet internally ‚Äî expensive for complex objects
// Consider: sort first, then deduplicate (more cache-friendly)

// Pitfall 5: findFirst() vs findAny() in parallel
numbers.parallelStream().filter(n -> n > 100).findFirst(); // Must find first ‚Äî expensive ordering
numbers.parallelStream().filter(n -> n > 100).findAny();   // Any match ‚Äî much faster parallel
</code></pre>
<p>The <code>findFirst()</code> vs <code>findAny()</code> distinction in parallel streams is particularly counter-intuitive: <code>findFirst()</code> looks like it should be faster because it stops early, but in a parallel context it forces the JVM to coordinate across threads to guarantee the encounter-order result, which is significantly more expensive than <code>findAny()</code>.</p>
<h2>Real-World Data Processing Patterns</h2>
<p>The previous sections covered individual features in isolation. This final example brings them together into a realistic reporting pipeline that you might encounter in a production analytics service. Notice how it uses nested <code>teeing</code> inside <code>groupingBy</code> to compute two aggregates per group in a single pass, then transforms the map into a sorted, limited result set:</p>
<pre><code class="language-java">// Pattern: Transform order data for reporting
record ReportLine(String customerId, String customerName,
                  long orderCount, BigDecimal totalRevenue) {}

List&#x3C;ReportLine> report = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getCustomerId,
        Collectors.teeing(
            Collectors.counting(),
            Collectors.reducing(BigDecimal.ZERO, Order::getTotal, BigDecimal::add),
            (count, total) -> new Object[]{count, total}  // Temp holder
        )
    ))
    .entrySet().stream()
    .map(entry -> {
        String customerId = entry.getKey();
        Object[] stats = (Object[]) entry.getValue();
        Customer customer = customerCache.get(customerId);
        return new ReportLine(
            customerId,
            customer.getName(),
            (Long) stats[0],
            (BigDecimal) stats[1]
        );
    })
    .sorted(Comparator.comparing(ReportLine::totalRevenue).reversed())
    .limit(100)  // Top 100 customers
    .collect(Collectors.toList());
</code></pre>
<p>The Streams API is functional programming applied to Java. The core insight: describe what you want (filter active orders, group by customer, sum totals), not how to do it (loop, if, accumulate, sort). Once you internalize this declarative style, you write code that's shorter, more readable, and easier to parallelize. The advanced pieces ‚Äî custom collectors, teeing, flatMap ‚Äî handle the 20% of use cases that map/filter/collect can't cover.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass ‚Äî Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Java%20Streams%20API%3A%20Advanced%20Patterns%20and%20Performance&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-streams-advanced%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-streams-advanced%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#flatmap-working-with-nested-structures" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">FlatMap: Working with Nested Structures</a></li><li class=""><a href="#collectors-beyond-tolist" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Collectors: Beyond toList()</a></li><li class=""><a href="#custom-collectors" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Custom Collectors</a></li><li class=""><a href="#teeing-combine-two-collectors" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">teeing: Combine Two Collectors</a></li><li class=""><a href="#parallel-streams-when-and-how" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Parallel Streams: When and How</a></li><li class=""><a href="#stream-performance-pitfalls" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Stream Performance Pitfalls</a></li><li class=""><a href="#real-world-data-processing-patterns" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Real-World Data Processing Patterns</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-concurrency-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era&#x27;s patterns still exist in production codebases. Understanding all th‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->concurrency</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->completablefuture</span></div></article></a><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java Streams API: Advanced Patterns and Performance","description":"Go beyond map/filter/collect. Master Java Streams API with flatMap, collectors, parallel streams, custom collectors, and performance considerations for production code.","date":"2025-03-21","category":"Java","tags":["java","streams","functional programming","collections","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-streams-advanced","readingTime":"9 min read","excerpt":"Most engineers use Java Streams for map/filter/collect and stop there. The full Streams API is significantly more powerful: custom collectors that aggregate in a single pass, flatMap for flattening nested structures, par‚Ä¶","contentHtml":"\u003cp\u003eMost engineers use Java Streams for map/filter/collect and stop there. The full Streams API is significantly more powerful: custom collectors that aggregate in a single pass, flatMap for flattening nested structures, parallel streams that scale across CPU cores, and collector combinators that compose complex aggregations. This article covers the patterns that separate proficient from expert Java developers.\u003c/p\u003e\n\u003ch2\u003eFlatMap: Working with Nested Structures\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eflatMap\u003c/code\u003e transforms each element into a stream and merges all those streams. Think of it as a two-step operation: first map each element to a stream, then flatten all those streams into one. This is the correct tool whenever you have a collection of collections and need to work with the inner elements directly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Problem: List of orders, each with List of items ‚Äî get all items\nList\u0026#x3C;Order\u003e orders = getOrders();\n\n// Wrong (returns Stream\u0026#x3C;List\u0026#x3C;OrderItem\u003e\u003e):\nStream\u0026#x3C;List\u0026#x3C;OrderItem\u003e\u003e wrong = orders.stream().map(Order::getItems);\n\n// Correct (returns Stream\u0026#x3C;OrderItem\u003e):\nStream\u0026#x3C;OrderItem\u003e allItems = orders.stream()\n    .flatMap(order -\u003e order.getItems().stream());\n\n// Practical: find all unique product IDs ordered by a customer\nSet\u0026#x3C;String\u003e productIds = orders.stream()\n    .flatMap(order -\u003e order.getItems().stream())\n    .map(OrderItem::getProductId)\n    .collect(Collectors.toSet());\n\n// Chain: orders with items above threshold\nList\u0026#x3C;OrderItem\u003e expensiveItems = orders.stream()\n    .flatMap(order -\u003e order.getItems().stream()\n        .filter(item -\u003e item.getPrice().compareTo(BigDecimal.valueOf(100)) \u003e 0)\n        .map(item -\u003e item.withOrderId(order.getId()))  // Add context from outer\n    )\n    .collect(Collectors.toList());\n\n// Optional flatMap: chain of optional operations\nOptional\u0026#x3C;String\u003e customerEmail = findOrder(\"order-123\")\n    .flatMap(order -\u003e findCustomer(order.getCustomerId()))\n    .flatMap(customer -\u003e Optional.ofNullable(customer.getEmail()));\n// Returns empty if any step is empty ‚Äî clean Optional chaining\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eOptional.flatMap\u003c/code\u003e usage at the end is a particularly useful pattern: it lets you chain a sequence of operations where any step might produce an empty result, without nested null checks or \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003ch2\u003eCollectors: Beyond toList()\u003c/h2\u003e\n\u003cp\u003eThe real power of the Streams API lies in its collectors. While \u003ccode\u003etoList()\u003c/code\u003e handles the common case, \u003ccode\u003eCollectors\u003c/code\u003e includes a rich set of aggregation operations that can replace what would otherwise be multiple passes over the data or complex imperative loops. The key insight is that collectors are composable ‚Äî you can nest them to express sophisticated aggregations in a single, readable pipeline:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// groupingBy: most powerful collector\nMap\u0026#x3C;String, List\u0026#x3C;Order\u003e\u003e ordersByStatus = orders.stream()\n    .collect(Collectors.groupingBy(Order::getStatus));\n\n// groupingBy with downstream collector\nMap\u0026#x3C;String, Long\u003e countByStatus = orders.stream()\n    .collect(Collectors.groupingBy(\n        Order::getStatus,\n        Collectors.counting()\n    ));\n\n// Multi-level grouping\nMap\u0026#x3C;String, Map\u0026#x3C;String, BigDecimal\u003e\u003e totalByCustomerAndStatus = orders.stream()\n    .collect(Collectors.groupingBy(\n        Order::getCustomerId,\n        Collectors.groupingBy(\n            Order::getStatus,\n            Collectors.reducing(\n                BigDecimal.ZERO,\n                Order::getTotal,\n                BigDecimal::add\n            )\n        )\n    ));\n\n// partitioningBy: split into true/false\nMap\u0026#x3C;Boolean, List\u0026#x3C;Order\u003e\u003e activeVsCancelled = orders.stream()\n    .collect(Collectors.partitioningBy(\n        order -\u003e !order.getStatus().equals(\"CANCELLED\")\n    ));\nList\u0026#x3C;Order\u003e activeOrders = activeVsCancelled.get(true);\n\n// toMap with merge function (handles duplicate keys)\nMap\u0026#x3C;String, BigDecimal\u003e totalByCustomer = orders.stream()\n    .collect(Collectors.toMap(\n        Order::getCustomerId,\n        Order::getTotal,\n        BigDecimal::add  // Merge: add totals for same customer\n    ));\n\n// Statistics\nIntSummaryStatistics priceStats = products.stream()\n    .mapToInt(Product::getPriceCents)\n    .summaryStatistics();\nSystem.out.printf(\"Min: %d, Max: %d, Avg: %.2f, Count: %d%n\",\n    priceStats.getMin(), priceStats.getMax(),\n    priceStats.getAverage(), priceStats.getCount());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCustom Collectors\u003c/h2\u003e\n\u003cp\u003eWhen built-in collectors don't fit, build your own. A custom collector is composed of four functions: a supplier that creates the mutable accumulator, an accumulator that folds each element into it, a combiner that merges two accumulators (needed for parallel streams), and a finisher that converts the accumulator to the final result. This structure might seem verbose at first, but it gives you complete control over how the aggregation behaves:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Custom collector: find top N elements by a comparator in a single pass\n// (more efficient than sorting all then taking first N)\npublic static \u0026#x3C;T\u003e Collector\u0026#x3C;T, ?, List\u0026#x3C;T\u003e\u003e topN(int n, Comparator\u0026#x3C;T\u003e comparator) {\n    return Collector.of(\n        () -\u003e new PriorityQueue\u0026#x3C;\u003e(n + 1, comparator),  // Supplier: create accumulator\n        (queue, element) -\u003e {                            // Accumulator: add element\n            queue.offer(element);\n            if (queue.size() \u003e n) queue.poll();         // Keep only top N\n        },\n        (q1, q2) -\u003e {                                   // Combiner: merge two accumulators (parallel)\n            q2.forEach(q1::offer);\n            while (q1.size() \u003e n) q1.poll();\n            return q1;\n        },\n        queue -\u003e {                                       // Finisher: convert to result\n            List\u0026#x3C;T\u003e result = new ArrayList\u0026#x3C;\u003e(queue);\n            result.sort(comparator.reversed());\n            return result;\n        }\n    );\n}\n\n// Usage: top 5 most expensive products in a single pass\nList\u0026#x3C;Product\u003e top5 = products.stream()\n    .collect(topN(5, Comparator.comparing(Product::getPriceCents)));\n\n// Another useful custom collector: running total\npublic static Collector\u0026#x3C;BigDecimal, ?, List\u0026#x3C;BigDecimal\u003e\u003e runningTotal() {\n    return Collector.of(\n        () -\u003e new ArrayList\u0026#x3C;BigDecimal\u003e() {{ add(BigDecimal.ZERO); }},\n        (list, amount) -\u003e list.add(list.get(list.size() - 1).add(amount)),\n        (list1, list2) -\u003e {  // Not meaningful for parallel, but required\n            BigDecimal lastTotal = list1.get(list1.size() - 1);\n            list2.stream().skip(1).forEach(d -\u003e list1.add(lastTotal.add(d)));\n            return list1;\n        },\n        list -\u003e list.subList(1, list.size())  // Remove initial zero\n    );\n}\n\n// Running total of daily revenue\nList\u0026#x3C;BigDecimal\u003e cumulativeRevenue = dailyRevenue.stream()\n    .collect(runningTotal());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003etopN\u003c/code\u003e collector is more efficient than the naive \u003ccode\u003esorted().limit(n)\u003c/code\u003e approach because it maintains a bounded priority queue of size \u003ccode\u003en\u003c/code\u003e ‚Äî it never needs to sort the entire input, making it O(n log k) instead of O(n log n).\u003c/p\u003e\n\u003ch2\u003eteeing: Combine Two Collectors\u003c/h2\u003e\n\u003cp\u003eNow that you have a feel for how collectors compose, Java 12's \u003ccode\u003eCollectors.teeing\u003c/code\u003e takes composability one step further by letting you apply two collectors to the same stream simultaneously and combine their results. This eliminates the need to iterate over the data twice when you need two independent aggregations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Get count AND total in one pass\nrecord OrderStats(long count, BigDecimal total) {}\n\nOrderStats stats = orders.stream()\n    .collect(Collectors.teeing(\n        Collectors.counting(),\n        Collectors.reducing(BigDecimal.ZERO, Order::getTotal, BigDecimal::add),\n        OrderStats::new\n    ));\n\nSystem.out.printf(\"Count: %d, Total: %s%n\", stats.count(), stats.total());\n\n// Split stream into two lists in one pass (more efficient than two filter calls)\nrecord ActiveAndCancelled(List\u0026#x3C;Order\u003e active, List\u0026#x3C;Order\u003e cancelled) {}\n\nActiveAndCancelled split = orders.stream()\n    .collect(Collectors.teeing(\n        Collectors.filtering(o -\u003e !o.isCancelled(), Collectors.toList()),\n        Collectors.filtering(Order::isCancelled, Collectors.toList()),\n        ActiveAndCancelled::new\n    ));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe single-pass guarantee is what makes \u003ccode\u003eteeing\u003c/code\u003e valuable at scale ‚Äî when your input is a large stream from a database or file, avoiding a second pass over the data has a meaningful impact on both time and memory.\u003c/p\u003e\n\u003ch2\u003eParallel Streams: When and How\u003c/h2\u003e\n\u003cp\u003eWith single-threaded streams well understood, it's tempting to reach for \u003ccode\u003eparallelStream()\u003c/code\u003e everywhere. Resist that urge. Parallel streams split the stream across \u003ccode\u003eForkJoinPool.commonPool()\u003c/code\u003e threads and have measurable overhead ‚Äî they help only when the per-element work is expensive enough to outweigh the cost of splitting and merging:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// When parallel streams help:\n// - Large data sets (\u003e 100K elements)\n// - CPU-intensive operations per element\n// - Stateless, independent operations\n// - Ordered output doesn't matter (order = merge cost)\n\n// Good candidate: CPU-intensive transformation of large list\nList\u0026#x3C;ProcessedReport\u003e reports = rawReports.parallelStream()\n    .map(r -\u003e processReport(r))          // CPU-intensive\n    .filter(r -\u003e r.isSignificant())\n    .collect(Collectors.toList());       // Order doesn't matter\n\n// Benchmark: this MIGHT be 4x faster on 4 cores\n\n// When parallel is SLOWER:\n// Small data: thread overhead \u003e computation benefit (\u0026#x3C; 1000 elements)\nList\u0026#x3C;String\u003e small = Arrays.asList(\"a\", \"b\", \"c\");\nsmall.parallelStream().map(String::toUpperCase).collect(Collectors.toList());\n// Slower than sequential: creating ForkJoin tasks has 20Œºs overhead\n\n// Stateful operations (bad for parallel):\nList\u0026#x3C;Integer\u003e result = new ArrayList\u0026#x3C;\u003e();  // NOT thread-safe!\nnumbers.parallelStream()\n    .filter(n -\u003e n \u003e 0)\n    .forEach(result::add);  // RACE CONDITION ‚Äî don't do this\n// Correct: use collectors, not forEach with external state\n\n// IO-bound operations (no benefit from parallel):\nList\u0026#x3C;String\u003e fetched = urls.parallelStream()\n    .map(url -\u003e fetchUrl(url))  // Blocked on I/O, not CPU\n    .collect(Collectors.toList());\n// Use virtual threads or CompletableFuture instead\n\n// Custom thread pool for parallel streams:\nForkJoinPool customPool = new ForkJoinPool(8);\nList\u0026#x3C;Result\u003e results = customPool.submit(() -\u003e\n    items.parallelStream()\n        .map(this::expensiveOperation)\n        .collect(Collectors.toList())\n).get();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing a custom \u003ccode\u003eForkJoinPool\u003c/code\u003e as shown at the end is an important technique when you need to isolate parallel stream work from the JVM's shared common pool ‚Äî for example, when your application also uses other libraries that rely on \u003ccode\u003eForkJoinPool.commonPool()\u003c/code\u003e and you do not want them to compete for threads.\u003c/p\u003e\n\u003ch2\u003eStream Performance Pitfalls\u003c/h2\u003e\n\u003cp\u003eEven sequential streams have performance traps worth knowing. These pitfalls are easy to miss during code review because the code looks idiomatic, but each one introduces unnecessary overhead that compounds at scale:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Pitfall 1: Unboxing overhead with boxed streams\n// BAD: Integer stream (boxing/unboxing overhead)\nint sum = numbers.stream()\n    .map(Integer::intValue)    // unnecessary\n    .reduce(0, Integer::sum);  // boxes again\n\n// GOOD: Use primitive streams (IntStream, LongStream, DoubleStream)\nint sum = numbers.stream()\n    .mapToInt(Integer::intValue)  // Returns IntStream (unboxed)\n    .sum();                        // No boxing\n\n// Pitfall 2: Collecting to list then re-streaming\n// BAD: Creates intermediate list\nList\u0026#x3C;String\u003e intermediate = products.stream()\n    .filter(p -\u003e p.getPrice() \u003e 100)\n    .map(Product::getName)\n    .collect(Collectors.toList());  // Materialized here\n\nlong count = intermediate.stream().count();  // Re-stream just to count!\n\n// GOOD: Chain in one pipeline\nlong count = products.stream()\n    .filter(p -\u003e p.getPrice() \u003e 100)\n    .count();  // Terminal operation ‚Äî no intermediate list\n\n// Pitfall 3: sorted() on large streams\n// Sorting requires all elements ‚Üí breaks laziness\n// Only sort when the result actually needs ordering\n\n// Pitfall 4: distinct() with expensive equals/hashCode\n// distinct() maintains a HashSet internally ‚Äî expensive for complex objects\n// Consider: sort first, then deduplicate (more cache-friendly)\n\n// Pitfall 5: findFirst() vs findAny() in parallel\nnumbers.parallelStream().filter(n -\u003e n \u003e 100).findFirst(); // Must find first ‚Äî expensive ordering\nnumbers.parallelStream().filter(n -\u003e n \u003e 100).findAny();   // Any match ‚Äî much faster parallel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003efindFirst()\u003c/code\u003e vs \u003ccode\u003efindAny()\u003c/code\u003e distinction in parallel streams is particularly counter-intuitive: \u003ccode\u003efindFirst()\u003c/code\u003e looks like it should be faster because it stops early, but in a parallel context it forces the JVM to coordinate across threads to guarantee the encounter-order result, which is significantly more expensive than \u003ccode\u003efindAny()\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eReal-World Data Processing Patterns\u003c/h2\u003e\n\u003cp\u003eThe previous sections covered individual features in isolation. This final example brings them together into a realistic reporting pipeline that you might encounter in a production analytics service. Notice how it uses nested \u003ccode\u003eteeing\u003c/code\u003e inside \u003ccode\u003egroupingBy\u003c/code\u003e to compute two aggregates per group in a single pass, then transforms the map into a sorted, limited result set:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Pattern: Transform order data for reporting\nrecord ReportLine(String customerId, String customerName,\n                  long orderCount, BigDecimal totalRevenue) {}\n\nList\u0026#x3C;ReportLine\u003e report = orders.stream()\n    .collect(Collectors.groupingBy(\n        Order::getCustomerId,\n        Collectors.teeing(\n            Collectors.counting(),\n            Collectors.reducing(BigDecimal.ZERO, Order::getTotal, BigDecimal::add),\n            (count, total) -\u003e new Object[]{count, total}  // Temp holder\n        )\n    ))\n    .entrySet().stream()\n    .map(entry -\u003e {\n        String customerId = entry.getKey();\n        Object[] stats = (Object[]) entry.getValue();\n        Customer customer = customerCache.get(customerId);\n        return new ReportLine(\n            customerId,\n            customer.getName(),\n            (Long) stats[0],\n            (BigDecimal) stats[1]\n        );\n    })\n    .sorted(Comparator.comparing(ReportLine::totalRevenue).reversed())\n    .limit(100)  // Top 100 customers\n    .collect(Collectors.toList());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Streams API is functional programming applied to Java. The core insight: describe what you want (filter active orders, group by customer, sum totals), not how to do it (loop, if, accumulate, sort). Once you internalize this declarative style, you write code that's shorter, more readable, and easier to parallelize. The advanced pieces ‚Äî custom collectors, teeing, flatMap ‚Äî handle the 20% of use cases that map/filter/collect can't cover.\u003c/p\u003e\n","tableOfContents":[{"id":"flatmap-working-with-nested-structures","text":"FlatMap: Working with Nested Structures","level":2},{"id":"collectors-beyond-tolist","text":"Collectors: Beyond toList()","level":2},{"id":"custom-collectors","text":"Custom Collectors","level":2},{"id":"teeing-combine-two-collectors","text":"teeing: Combine Two Collectors","level":2},{"id":"parallel-streams-when-and-how","text":"Parallel Streams: When and How","level":2},{"id":"stream-performance-pitfalls","text":"Stream Performance Pitfalls","level":2},{"id":"real-world-data-processing-patterns","text":"Real-World Data Processing Patterns","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th‚Ä¶"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-streams-advanced"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>