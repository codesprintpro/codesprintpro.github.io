<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">API Design: REST vs GraphQL vs gRPC â€” When to Use Each<!-- --> | CodeSprintPro</title><meta name="description" content="Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/api-design-rest-graphql-grpc/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="API Design: REST vs GraphQL vs gRPC â€” When to Use Each" data-next-head=""/><meta property="og:description" content="Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/api-design-rest-graphql-grpc/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-03-01" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="System Design" data-next-head=""/><meta property="article:tag" content="api" data-next-head=""/><meta property="article:tag" content="rest" data-next-head=""/><meta property="article:tag" content="graphql" data-next-head=""/><meta property="article:tag" content="grpc" data-next-head=""/><meta property="article:tag" content="system design" data-next-head=""/><meta property="article:tag" content="microservices" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="API Design: REST vs GraphQL vs gRPC â€” When to Use Each" data-next-head=""/><meta name="twitter:description" content="Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"API Design: REST vs GraphQL vs gRPC â€” When to Use Each","description":"Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-03-01","dateModified":"2025-03-01","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/api-design-rest-graphql-grpc/"},"keywords":"api, rest, graphql, grpc, system design, microservices","articleSection":"System Design"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">API Design: REST vs GraphQL vs gRPC â€” When to Use Each</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">System Design</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">API Design: REST vs GraphQL vs gRPC â€” When to Use Each</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>March 1, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>13 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->api</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->rest</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->graphql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->grpc</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->system design</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->microservices</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Every microservices architecture makes an implicit bet on an API protocol. REST is familiar but verbose. GraphQL is flexible but complex. gRPC is fast but opinionated. Choosing wrong costs you months of refactoring. This article gives you the mental model to choose right the first time.</p>
<h2>The Core Trade-off</h2>
<p>Before diving into code, it helps to internalize the fundamental personality of each protocol. Think of them as different tools in a workshop â€” a hammer, a screwdriver, and a wrench each solve problems the others can't. The table below is the mental shortcut you'll return to whenever you're evaluating a new API surface.</p>
<pre><code>REST:     Standard, cacheable, human-readable. Overfetching is the enemy.
GraphQL:  Client-defined queries. Solves overfetching. Adds query complexity.
gRPC:     Binary protocol, bidirectional streaming, 10x faster than REST.
          Requires Protobuf contracts. Not browser-native.
</code></pre>
<h2>REST: The Default Choice</h2>
<p>REST (Representational State Transfer) models your API around <strong>resources</strong> and <strong>HTTP verbs</strong>.</p>
<p>REST maps your domain objects to URLs and uses standard HTTP methods to express what you want to do with them. This uniformity is REST's superpower â€” any developer who has used an HTTP API before can guess how your API works without reading the docs. The example below shows the URL structure and verb mapping you should follow for a standard resource.</p>
<pre><code>Resource: /orders/{id}
GET    /orders/123         â†’ Retrieve order 123
POST   /orders             â†’ Create new order
PUT    /orders/123         â†’ Replace order 123
PATCH  /orders/123         â†’ Partial update order 123
DELETE /orders/123         â†’ Delete order 123

Nested resources:
GET    /orders/123/items   â†’ Items of order 123
POST   /orders/123/items   â†’ Add item to order 123
</code></pre>
<h3>REST API Design â€” Getting It Right</h3>
<p>Good REST goes beyond just using the right HTTP verb â€” it uses HTTP's semantics correctly, including response codes and headers. The controller below demonstrates several REST best practices: sparse fieldsets to reduce overfetching, the <code>201 Created</code> status with a <code>Location</code> header on creation, and a dedicated PATCH endpoint for partial updates.</p>
<pre><code class="language-java">@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {

    @GetMapping("/{id}")
    public ResponseEntity&#x3C;OrderResponse> getOrder(
            @PathVariable String id,
            @RequestParam(required = false) Set&#x3C;String> fields) {  // Sparse fieldsets
        Order order = orderService.findById(id)
            .orElseThrow(() -> new OrderNotFoundException(id));
        return ResponseEntity.ok(OrderResponse.from(order, fields));
    }

    @PostMapping
    public ResponseEntity&#x3C;OrderResponse> createOrder(
            @Valid @RequestBody CreateOrderRequest request,
            UriComponentsBuilder uriBuilder) {
        Order order = orderService.create(request);
        URI location = uriBuilder.path("/api/v1/orders/{id}")
            .buildAndExpand(order.getId()).toUri();
        // Return 201 Created with Location header â€” this is correct REST
        return ResponseEntity.created(location).body(OrderResponse.from(order));
    }

    @PatchMapping("/{id}/status")
    public ResponseEntity&#x3C;OrderResponse> updateStatus(
            @PathVariable String id,
            @Valid @RequestBody UpdateStatusRequest request) {
        Order order = orderService.updateStatus(id, request.getStatus());
        return ResponseEntity.ok(OrderResponse.from(order));
    }
}
</code></pre>
<p>The <code>Location</code> header in the <code>201 Created</code> response is something many APIs skip, but it's essential for good REST design â€” it tells the client exactly where the newly created resource lives without requiring a separate lookup.</p>
<h3>REST Error Response Standard</h3>
<p>Error handling is where many REST APIs diverge and create friction for API consumers. RFC 7807 (Problem Details) defines a standard error envelope that any HTTP client can parse consistently. Using this format means your error responses are as predictable as your success responses.</p>
<pre><code class="language-java">// Problem Details (RFC 7807) â€” the standardized error format
@ExceptionHandler(OrderNotFoundException.class)
public ResponseEntity&#x3C;ProblemDetail> handleNotFound(OrderNotFoundException ex) {
    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        HttpStatus.NOT_FOUND,
        "Order " + ex.getId() + " not found"
    );
    problem.setTitle("Order Not Found");
    problem.setInstance(URI.create("/api/v1/orders/" + ex.getId()));
    problem.setProperty("orderId", ex.getId());
    return ResponseEntity.status(404).body(problem);
}

// Response:
// {
//   "type": "about:blank",
//   "title": "Order Not Found",
//   "status": 404,
//   "detail": "Order abc-123 not found",
//   "instance": "/api/v1/orders/abc-123",
//   "orderId": "abc-123"
// }
</code></pre>
<h3>REST Pagination</h3>
<p>Pagination is a problem every list endpoint must solve, and the choice of strategy affects scalability significantly. Offset-based pagination (<code>?page=2&#x26;size=20</code>) is intuitive but breaks when records are inserted between pages. Cursor-based pagination is stable regardless of concurrent writes and is what you should use for any dataset that changes frequently.</p>
<pre><code class="language-java">// Cursor-based pagination (preferred for large/changing datasets)
@GetMapping
public ResponseEntity&#x3C;PagedResponse&#x3C;OrderSummary>> listOrders(
        @RequestParam(required = false) String cursor,     // Opaque cursor (base64 encoded)
        @RequestParam(defaultValue = "20") int limit) {

    OrderPage page = orderService.findPage(cursor, Math.min(limit, 100));

    return ResponseEntity.ok(PagedResponse.&#x3C;OrderSummary>builder()
        .data(page.getItems())
        .nextCursor(page.getNextCursor())          // null if last page
        .hasMore(page.hasMore())
        .totalCount(page.getTotalCount())
        .build());
}

// Client follows: GET /orders?cursor=eyJpZCI6IjEyMyJ9&#x26;limit=20
</code></pre>
<p>The cursor is opaque to the client (base64-encoded), which means you can change the internal pagination implementation â€” switching from ID-based to timestamp-based, for example â€” without breaking any clients.</p>
<p><strong>REST sweet spot:</strong> Public APIs, CRUD services, when HTTP caching matters, mobile clients where you control bandwidth.</p>
<p><strong>REST problems:</strong> Overfetching (getting 30 fields when you need 3), underfetching (N+1 â€” getting orders then making N calls for each order's customer).</p>
<hr>
<h2>GraphQL: Client-Defined Queries</h2>
<p>GraphQL lets clients request exactly the data they need â€” no more, no less. One endpoint (<code>/graphql</code>) handles everything.</p>
<p>The core idea behind GraphQL is inverting the control of data shaping: instead of the server deciding what fields to return, the client declares exactly what it needs. This is especially powerful when you have multiple clients â€” a mobile app, a web dashboard, and a partner integration â€” all with different data requirements hitting the same backend. The schema below defines what the server can provide; the query below it shows how a client selects a precise subset.</p>
<pre><code class="language-graphql"># Schema (server defines capabilities)
type Query {
  order(id: ID!): Order
  orders(filter: OrderFilter, limit: Int, cursor: String): OrderConnection!
  me: User!
}

type Order {
  id: ID!
  status: OrderStatus!
  total: Float!
  customer: Customer!         # Nested object â€” no extra round trip
  items: [OrderItem!]!
  createdAt: DateTime!
}

type Customer {
  id: ID!
  name: String!
  email: String!
}

# Client query â€” requests exactly what it needs
query GetOrderWithCustomer($orderId: ID!) {
  order(id: $orderId) {
    id
    status
    total
    customer {
      name        # Only name â€” not email, address, etc.
    }
    items {
      productName
      quantity
      price
    }
  }
}
</code></pre>
<p>Notice that the client requests <code>customer.name</code> but not <code>customer.email</code> â€” the server only fetches and returns what was requested. This is in direct contrast to REST, where you'd get the entire customer object whether you needed it or not.</p>
<h3>Spring Boot GraphQL Implementation</h3>
<p>The Spring GraphQL implementation maps GraphQL query fields to Java methods through annotations. The critical piece here is the <code>DataLoader</code> for the <code>customer</code> field â€” without it, loading 10 orders would trigger 10 separate customer queries (the GraphQL equivalent of the N+1 problem you saw in the REST section).</p>
<pre><code class="language-java">// build.gradle
// implementation 'org.springframework.boot:spring-boot-starter-graphql'

@Controller
public class OrderGraphQLController {

    @QueryMapping
    public Order order(@Argument String id) {
        return orderService.findById(id)
            .orElseThrow(() -> new GraphQLException("Order not found: " + id));
    }

    @QueryMapping
    public Connection&#x3C;Order> orders(@Argument OrderFilter filter,
                                    @Argument int limit,
                                    @Argument String cursor) {
        return orderService.findPage(filter, limit, cursor);
    }

    // DataLoader: batch-load customers to avoid N+1
    @SchemaMapping(typeName = "Order", field = "customer")
    public CompletableFuture&#x3C;Customer> customer(Order order,
                                                 DataLoader&#x3C;String, Customer> customerLoader) {
        return customerLoader.load(order.getCustomerId());
        // All customer loads within one request are batched into a single DB query
    }
}

// DataLoader registration (batches N customer loads into 1 DB query)
@Bean
public BatchLoaderRegistry batchLoaderRegistry() {
    BatchLoaderRegistry registry = new DefaultBatchLoaderRegistry();
    registry.forTypePair(String.class, Customer.class)
        .withName("customerLoader")
        .registerBatchLoader((ids, env) ->
            Mono.fromCallable(() -> customerService.findAllByIds(ids))
        );
    return registry;
}
</code></pre>
<p>The <code>BatchLoaderRegistry</code> is where the magic happens: instead of loading each customer immediately, it collects all customer IDs from a single request and fires one batched database query. This is a non-negotiable pattern â€” GraphQL without DataLoaders at scale is a performance disaster.</p>
<h3>GraphQL Mutations</h3>
<p>While queries read data, mutations modify it. GraphQL mutations differ from REST POST/PUT in one important way: they return a payload type that can contain both the result and business-level errors as data, rather than relying on HTTP status codes to signal what went wrong.</p>
<pre><code class="language-graphql">type Mutation {
  createOrder(input: CreateOrderInput!): CreateOrderPayload!
  updateOrderStatus(id: ID!, status: OrderStatus!): Order!
}

input CreateOrderInput {
  customerId: ID!
  items: [OrderItemInput!]!
  shippingAddress: AddressInput!
}

type CreateOrderPayload {
  order: Order            # The created order
  errors: [UserError!]    # Business errors (not HTTP 4xx)
}

type UserError {
  field: String
  message: String!
}
</code></pre>
<pre><code class="language-java">@MutationMapping
public CreateOrderPayload createOrder(@Argument CreateOrderInput input) {
    try {
        Order order = orderService.create(input);
        return CreateOrderPayload.success(order);
    } catch (ValidationException e) {
        return CreateOrderPayload.error(e.getField(), e.getMessage());
    }
}
</code></pre>
<p>Returning business errors in the payload (rather than throwing HTTP 422 errors) is a deliberate GraphQL convention â€” it means the GraphQL response always has HTTP 200, and clients handle business logic errors through the <code>errors</code> field in the response body. This keeps your error handling consistent regardless of the operation.</p>
<p><strong>GraphQL sweet spot:</strong> Mobile apps (bandwidth-sensitive), complex dashboards with many different data shapes, BFF (Backend For Frontend) pattern, when you have multiple clients needing different views of the same data.</p>
<p><strong>GraphQL problems:</strong> Query complexity attacks (clients can request deeply nested data), N+1 problem (requires DataLoader), caching is harder (no HTTP GET caching), learning curve.</p>
<hr>
<h2>gRPC: High-Performance Service Communication</h2>
<p>gRPC uses HTTP/2 and Protocol Buffers (binary serialization). It's 5-10x faster than REST/JSON for inter-service communication.</p>
<p>Where REST uses human-readable JSON over HTTP/1.1, gRPC uses compact binary encoding over HTTP/2. Think of the difference between sending a hand-written letter and sending a compressed file â€” both carry information, but one is far more efficient to transmit and parse. The Protobuf schema below is the contract that both sides of a gRPC call agree on; it generates type-safe client and server code in any supported language.</p>
<pre><code class="language-protobuf">// order_service.proto
syntax = "proto3";

package order.v1;

service OrderService {
  rpc GetOrder (GetOrderRequest) returns (Order);
  rpc CreateOrder (CreateOrderRequest) returns (Order);
  rpc UpdateOrderStatus (UpdateStatusRequest) returns (Order);

  // Server streaming: stream order updates to client
  rpc WatchOrder (WatchOrderRequest) returns (stream OrderEvent);

  // Client streaming: bulk upload orders
  rpc BulkCreateOrders (stream CreateOrderRequest) returns (BulkCreateResponse);

  // Bidirectional streaming: real-time order management
  rpc ManageOrders (stream OrderCommand) returns (stream OrderEvent);
}

message Order {
  string id = 1;
  string customer_id = 2;
  OrderStatus status = 3;
  repeated OrderItem items = 4;
  int64 total_cents = 5;           // Avoid floats for money
  google.protobuf.Timestamp created_at = 6;
}

enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0;   // Proto3: always define 0 case
  ORDER_STATUS_PENDING = 1;
  ORDER_STATUS_CONFIRMED = 2;
  ORDER_STATUS_SHIPPED = 3;
  ORDER_STATUS_DELIVERED = 4;
  ORDER_STATUS_CANCELLED = 5;
}

message GetOrderRequest {
  string id = 1;
}
</code></pre>
<p>Notice that <code>total_cents</code> stores money as an integer instead of a float â€” this is a deliberate choice to avoid floating-point precision errors when dealing with currency. The streaming RPCs (<code>WatchOrder</code>, <code>BulkCreateOrders</code>, <code>ManageOrders</code>) are capabilities that REST simply cannot match cleanly. The Java server implementation maps directly to these proto definitions.</p>
<pre><code class="language-java">// Server implementation
@GrpcService
public class OrderGrpcService extends OrderServiceGrpc.OrderServiceImplBase {

    @Override
    public void getOrder(GetOrderRequest request, StreamObserver&#x3C;Order> responseObserver) {
        try {
            com.example.Order order = orderService.findById(request.getId())
                .orElseThrow(() -> Status.NOT_FOUND
                    .withDescription("Order not found: " + request.getId())
                    .asRuntimeException());

            responseObserver.onNext(toProto(order));
            responseObserver.onCompleted();
        } catch (StatusRuntimeException e) {
            responseObserver.onError(e);
        }
    }

    @Override
    public void watchOrder(WatchOrderRequest request,
                           StreamObserver&#x3C;OrderEvent> responseObserver) {
        // Server streaming: push updates as order progresses
        String orderId = request.getOrderId();
        orderEventService.subscribe(orderId, event -> {
            if (!responseObserver.isReady()) return;
            responseObserver.onNext(toProto(event));
            if (event.isFinal()) responseObserver.onCompleted();
        });
    }
}

// Client (another service calling OrderService)
@Service
public class PaymentService {

    private final OrderServiceGrpc.OrderServiceBlockingStub orderStub;

    public void processPayment(String orderId) {
        // Unary call with deadline
        Order order = orderStub
            .withDeadlineAfter(500, TimeUnit.MILLISECONDS)
            .getOrder(GetOrderRequest.newBuilder().setId(orderId).build());

        // order is type-safe â€” proto-generated class
    }
}
</code></pre>
<p>The <code>.withDeadlineAfter(500, TimeUnit.MILLISECONDS)</code> call on the client stub is critical for production resilience â€” without deadlines, a slow upstream service can hold your threads indefinitely and cascade into a timeout storm across your entire service mesh. Always set deadlines on outbound gRPC calls.</p>
<h3>gRPC Performance Numbers</h3>
<p>The performance gap between gRPC and REST isn't theoretical â€” here are concrete numbers from a representative benchmark. The two main drivers are binary serialization (Protobuf vs JSON) and HTTP/2 multiplexing, which eliminates head-of-line blocking and reduces connection overhead.</p>
<pre><code>Benchmark: 10,000 requests/sec, 1KB payload, same machine

REST/JSON (Spring MVC):
  p50 latency: 8ms
  p99 latency: 45ms
  CPU: 65%

gRPC/Protobuf (same logic):
  p50 latency: 1.2ms     â† 6.7x faster
  p99 latency: 7ms       â† 6.4x faster
  CPU: 28%               â† 2.3x less CPU

Why: Binary serialization + HTTP/2 multiplexing + header compression
</code></pre>
<p>The CPU reduction is especially important in microservice architectures â€” every percentage point of CPU saved at 10,000 RPS translates directly to infrastructure cost. For internal service calls that happen millions of times per day, this difference is significant.</p>
<p><strong>gRPC sweet spot:</strong> Internal microservice-to-microservice communication, streaming use cases, polyglot environments (Go, Java, Python talking to each other), when you need maximum throughput and minimum latency.</p>
<p><strong>gRPC problems:</strong> No browser support natively (needs gRPC-Web proxy), harder to debug (binary protocol), requires Protobuf toolchain, contract management.</p>
<hr>
<h2>The Decision Framework</h2>
<p>With all three protocols understood in depth, you need a practical way to make the call for a new API surface. The two questions below cut through most of the deliberation: who is calling your API, and what shape does your data have?</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Who are your clients?                         â”‚
â”‚                                                                   â”‚
â”‚  External/Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º REST           â”‚
â”‚  (browsers, third-party, mobile)                                  â”‚
â”‚                                                                   â”‚
â”‚  Internal service-to-service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º gRPC           â”‚
â”‚  (no browser, max performance)                                    â”‚
â”‚                                                                   â”‚
â”‚  Multiple clients, different data needs â”€â”€â”€â”€â”€â”€â”€â–º GraphQL        â”‚
â”‚  (mobile + web, BFF pattern)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    What's your data shape?                        â”‚
â”‚                                                                   â”‚
â”‚  Simple CRUD, well-defined resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º REST           â”‚
â”‚  Deeply nested, relationship-heavy data â”€â”€â”€â”€â”€â”€â”€â–º GraphQL        â”‚
â”‚  Streaming, real-time, bidirectional â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º gRPC           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<table>
<thead>
<tr>
<th>Factor</th>
<th>REST</th>
<th>GraphQL</th>
<th>gRPC</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Browser support</strong></td>
<td>Native</td>
<td>Native</td>
<td>Needs proxy</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Excellent (HTTP cache)</td>
<td>Hard</td>
<td>Manual</td>
</tr>
<tr>
<td><strong>Overfetching</strong></td>
<td>Common problem</td>
<td>Solved</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>Streaming</strong></td>
<td>Limited (SSE)</td>
<td>Subscriptions</td>
<td>Native</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Good</td>
<td>Good</td>
<td>Excellent</td>
</tr>
<tr>
<td><strong>Learning curve</strong></td>
<td>Low</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Tooling/ecosystem</strong></td>
<td>Excellent</td>
<td>Good</td>
<td>Good</td>
</tr>
<tr>
<td><strong>Contract-first</strong></td>
<td>Optional (OpenAPI)</td>
<td>Schema required</td>
<td>Protobuf required</td>
</tr>
<tr>
<td><strong>Best for</strong></td>
<td>Public APIs</td>
<td>Complex clients</td>
<td>Internal services</td>
</tr>
</tbody>
</table>
<h2>Real-World Architecture: Use All Three</h2>
<p>In practice, mature production systems don't pick one protocol and force it everywhere â€” they use each protocol where it excels. The architecture below is representative of how companies like Uber and Netflix structure their API layers. REST faces the public; gRPC connects internal services for speed; GraphQL serves as a flexible aggregation layer for complex client needs.</p>
<pre><code>External clients (browser, mobile)
    â”‚
    â–¼
API Gateway (REST)      â† Public-facing, cacheable, familiar
    â”‚
    â”œâ”€â”€â–º User Service â”€â”€â”€â”€â”€â”€â”€â”€ gRPC â”€â”€â–º Auth Service
    â”‚                                       â”‚
    â”œâ”€â”€â–º Product Service â”€â”€â”€â”€ gRPC â”€â”€â–º Inventory Service
    â”‚                                       â”‚
    â”œâ”€â”€â–º BFF Service â”€â”€â”€â”€â”€â”€ GraphQL â”€â”€â–º (aggregates Product + User)
    â”‚         â”‚                          (serves mobile app)
    â””â”€â”€â–º Order Service â”€â”€â”€â”€â”€ gRPC â”€â”€â–º Payment Service
                                         â”‚
                                     Notification Service
                                     (gRPC streaming)
</code></pre>
<p>The gateway is REST. Internal hop is gRPC. The mobile BFF is GraphQL. This isn't over-engineering â€” each protocol does one thing well.</p>
<p>The worst outcome is picking one protocol for ideological reasons and forcing it everywhere. REST for streaming is painful. gRPC for public APIs is hostile to users. GraphQL for simple CRUD is overengineered. Let the use case choose the protocol.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">System Design Interview â€” Alex Xu</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Step-by-step guide to ace system design interviews with real-world examples.</p></div><a href="https://amzn.to/3TqsPRp" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Grokking System Design on Educative</span></div><p class="text-xs text-gray-600">Interactive course teaching system design with visual diagrams and practice problems.</p></div><a href="https://www.educative.io/courses/grokking-the-system-design-interview" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span></div><p class="text-xs text-gray-600">Martin Kleppmann&#x27;s book is essential reading for any system design role.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=API%20Design%3A%20REST%20vs%20GraphQL%20vs%20gRPC%20%E2%80%94%20When%20to%20Use%20Each&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fapi-design-rest-graphql-grpc%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fapi-design-rest-graphql-grpc%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-core-trade-off" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Core Trade-off</a></li><li class=""><a href="#rest-the-default-choice" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">REST: The Default Choice</a></li><li class="ml-4"><a href="#rest-api-design-getting-it-right" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">REST API Design â€” Getting It Right</a></li><li class="ml-4"><a href="#rest-error-response-standard" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">REST Error Response Standard</a></li><li class="ml-4"><a href="#rest-pagination" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">REST Pagination</a></li><li class=""><a href="#graphql-client-defined-queries" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">GraphQL: Client-Defined Queries</a></li><li class="ml-4"><a href="#spring-boot-graphql-implementation" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Spring Boot GraphQL Implementation</a></li><li class="ml-4"><a href="#graphql-mutations" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">GraphQL Mutations</a></li><li class=""><a href="#grpc-high-performance-service-communication" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">gRPC: High-Performance Service Communication</a></li><li class="ml-4"><a href="#grpc-performance-numbers" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">gRPC Performance Numbers</a></li><li class=""><a href="#the-decision-framework" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Decision Framework</a></li><li class=""><a href="#real-world-architecture-use-all-three" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Real-World Architecture: Use All Three</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/observability-opentelemetry-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Building Production Observability with OpenTelemetry and Grafana Stack</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>6 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->observability</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->opentelemetry</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->prometheus</span></div></article></a><a href="/blog/event-sourcing-cqrs-production/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Event Sourcing and CQRS in Production: Beyond the Theory</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 23, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->event sourcing</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cqrs</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->system design</span></div></article></a><a href="/blog/grpc-vs-rest-vs-graphql/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-blue-100 text-blue-700">System Design</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">gRPC vs REST vs GraphQL: Choosing the Right API Protocol</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->grpc</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->rest</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->graphql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"API Design: REST vs GraphQL vs gRPC â€” When to Use Each","description":"Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system.","date":"2025-03-01","category":"System Design","tags":["api","rest","graphql","grpc","system design","microservices"],"featured":false,"affiliateSection":"system-design-courses","slug":"api-design-rest-graphql-grpc","readingTime":"13 min read","excerpt":"Every microservices architecture makes an implicit bet on an API protocol. REST is familiar but verbose. GraphQL is flexible but complex. gRPC is fast but opinionated. Choosing wrong costs you months of refactoring. Thisâ€¦","contentHtml":"\u003cp\u003eEvery microservices architecture makes an implicit bet on an API protocol. REST is familiar but verbose. GraphQL is flexible but complex. gRPC is fast but opinionated. Choosing wrong costs you months of refactoring. This article gives you the mental model to choose right the first time.\u003c/p\u003e\n\u003ch2\u003eThe Core Trade-off\u003c/h2\u003e\n\u003cp\u003eBefore diving into code, it helps to internalize the fundamental personality of each protocol. Think of them as different tools in a workshop â€” a hammer, a screwdriver, and a wrench each solve problems the others can't. The table below is the mental shortcut you'll return to whenever you're evaluating a new API surface.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eREST:     Standard, cacheable, human-readable. Overfetching is the enemy.\nGraphQL:  Client-defined queries. Solves overfetching. Adds query complexity.\ngRPC:     Binary protocol, bidirectional streaming, 10x faster than REST.\n          Requires Protobuf contracts. Not browser-native.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eREST: The Default Choice\u003c/h2\u003e\n\u003cp\u003eREST (Representational State Transfer) models your API around \u003cstrong\u003eresources\u003c/strong\u003e and \u003cstrong\u003eHTTP verbs\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eREST maps your domain objects to URLs and uses standard HTTP methods to express what you want to do with them. This uniformity is REST's superpower â€” any developer who has used an HTTP API before can guess how your API works without reading the docs. The example below shows the URL structure and verb mapping you should follow for a standard resource.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eResource: /orders/{id}\nGET    /orders/123         â†’ Retrieve order 123\nPOST   /orders             â†’ Create new order\nPUT    /orders/123         â†’ Replace order 123\nPATCH  /orders/123         â†’ Partial update order 123\nDELETE /orders/123         â†’ Delete order 123\n\nNested resources:\nGET    /orders/123/items   â†’ Items of order 123\nPOST   /orders/123/items   â†’ Add item to order 123\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eREST API Design â€” Getting It Right\u003c/h3\u003e\n\u003cp\u003eGood REST goes beyond just using the right HTTP verb â€” it uses HTTP's semantics correctly, including response codes and headers. The controller below demonstrates several REST best practices: sparse fieldsets to reduce overfetching, the \u003ccode\u003e201 Created\u003c/code\u003e status with a \u003ccode\u003eLocation\u003c/code\u003e header on creation, and a dedicated PATCH endpoint for partial updates.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RestController\n@RequestMapping(\"/api/v1/orders\")\npublic class OrderController {\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity\u0026#x3C;OrderResponse\u003e getOrder(\n            @PathVariable String id,\n            @RequestParam(required = false) Set\u0026#x3C;String\u003e fields) {  // Sparse fieldsets\n        Order order = orderService.findById(id)\n            .orElseThrow(() -\u003e new OrderNotFoundException(id));\n        return ResponseEntity.ok(OrderResponse.from(order, fields));\n    }\n\n    @PostMapping\n    public ResponseEntity\u0026#x3C;OrderResponse\u003e createOrder(\n            @Valid @RequestBody CreateOrderRequest request,\n            UriComponentsBuilder uriBuilder) {\n        Order order = orderService.create(request);\n        URI location = uriBuilder.path(\"/api/v1/orders/{id}\")\n            .buildAndExpand(order.getId()).toUri();\n        // Return 201 Created with Location header â€” this is correct REST\n        return ResponseEntity.created(location).body(OrderResponse.from(order));\n    }\n\n    @PatchMapping(\"/{id}/status\")\n    public ResponseEntity\u0026#x3C;OrderResponse\u003e updateStatus(\n            @PathVariable String id,\n            @Valid @RequestBody UpdateStatusRequest request) {\n        Order order = orderService.updateStatus(id, request.getStatus());\n        return ResponseEntity.ok(OrderResponse.from(order));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eLocation\u003c/code\u003e header in the \u003ccode\u003e201 Created\u003c/code\u003e response is something many APIs skip, but it's essential for good REST design â€” it tells the client exactly where the newly created resource lives without requiring a separate lookup.\u003c/p\u003e\n\u003ch3\u003eREST Error Response Standard\u003c/h3\u003e\n\u003cp\u003eError handling is where many REST APIs diverge and create friction for API consumers. RFC 7807 (Problem Details) defines a standard error envelope that any HTTP client can parse consistently. Using this format means your error responses are as predictable as your success responses.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Problem Details (RFC 7807) â€” the standardized error format\n@ExceptionHandler(OrderNotFoundException.class)\npublic ResponseEntity\u0026#x3C;ProblemDetail\u003e handleNotFound(OrderNotFoundException ex) {\n    ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n        HttpStatus.NOT_FOUND,\n        \"Order \" + ex.getId() + \" not found\"\n    );\n    problem.setTitle(\"Order Not Found\");\n    problem.setInstance(URI.create(\"/api/v1/orders/\" + ex.getId()));\n    problem.setProperty(\"orderId\", ex.getId());\n    return ResponseEntity.status(404).body(problem);\n}\n\n// Response:\n// {\n//   \"type\": \"about:blank\",\n//   \"title\": \"Order Not Found\",\n//   \"status\": 404,\n//   \"detail\": \"Order abc-123 not found\",\n//   \"instance\": \"/api/v1/orders/abc-123\",\n//   \"orderId\": \"abc-123\"\n// }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eREST Pagination\u003c/h3\u003e\n\u003cp\u003ePagination is a problem every list endpoint must solve, and the choice of strategy affects scalability significantly. Offset-based pagination (\u003ccode\u003e?page=2\u0026#x26;size=20\u003c/code\u003e) is intuitive but breaks when records are inserted between pages. Cursor-based pagination is stable regardless of concurrent writes and is what you should use for any dataset that changes frequently.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Cursor-based pagination (preferred for large/changing datasets)\n@GetMapping\npublic ResponseEntity\u0026#x3C;PagedResponse\u0026#x3C;OrderSummary\u003e\u003e listOrders(\n        @RequestParam(required = false) String cursor,     // Opaque cursor (base64 encoded)\n        @RequestParam(defaultValue = \"20\") int limit) {\n\n    OrderPage page = orderService.findPage(cursor, Math.min(limit, 100));\n\n    return ResponseEntity.ok(PagedResponse.\u0026#x3C;OrderSummary\u003ebuilder()\n        .data(page.getItems())\n        .nextCursor(page.getNextCursor())          // null if last page\n        .hasMore(page.hasMore())\n        .totalCount(page.getTotalCount())\n        .build());\n}\n\n// Client follows: GET /orders?cursor=eyJpZCI6IjEyMyJ9\u0026#x26;limit=20\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe cursor is opaque to the client (base64-encoded), which means you can change the internal pagination implementation â€” switching from ID-based to timestamp-based, for example â€” without breaking any clients.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eREST sweet spot:\u003c/strong\u003e Public APIs, CRUD services, when HTTP caching matters, mobile clients where you control bandwidth.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eREST problems:\u003c/strong\u003e Overfetching (getting 30 fields when you need 3), underfetching (N+1 â€” getting orders then making N calls for each order's customer).\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eGraphQL: Client-Defined Queries\u003c/h2\u003e\n\u003cp\u003eGraphQL lets clients request exactly the data they need â€” no more, no less. One endpoint (\u003ccode\u003e/graphql\u003c/code\u003e) handles everything.\u003c/p\u003e\n\u003cp\u003eThe core idea behind GraphQL is inverting the control of data shaping: instead of the server deciding what fields to return, the client declares exactly what it needs. This is especially powerful when you have multiple clients â€” a mobile app, a web dashboard, and a partner integration â€” all with different data requirements hitting the same backend. The schema below defines what the server can provide; the query below it shows how a client selects a precise subset.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-graphql\"\u003e# Schema (server defines capabilities)\ntype Query {\n  order(id: ID!): Order\n  orders(filter: OrderFilter, limit: Int, cursor: String): OrderConnection!\n  me: User!\n}\n\ntype Order {\n  id: ID!\n  status: OrderStatus!\n  total: Float!\n  customer: Customer!         # Nested object â€” no extra round trip\n  items: [OrderItem!]!\n  createdAt: DateTime!\n}\n\ntype Customer {\n  id: ID!\n  name: String!\n  email: String!\n}\n\n# Client query â€” requests exactly what it needs\nquery GetOrderWithCustomer($orderId: ID!) {\n  order(id: $orderId) {\n    id\n    status\n    total\n    customer {\n      name        # Only name â€” not email, address, etc.\n    }\n    items {\n      productName\n      quantity\n      price\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the client requests \u003ccode\u003ecustomer.name\u003c/code\u003e but not \u003ccode\u003ecustomer.email\u003c/code\u003e â€” the server only fetches and returns what was requested. This is in direct contrast to REST, where you'd get the entire customer object whether you needed it or not.\u003c/p\u003e\n\u003ch3\u003eSpring Boot GraphQL Implementation\u003c/h3\u003e\n\u003cp\u003eThe Spring GraphQL implementation maps GraphQL query fields to Java methods through annotations. The critical piece here is the \u003ccode\u003eDataLoader\u003c/code\u003e for the \u003ccode\u003ecustomer\u003c/code\u003e field â€” without it, loading 10 orders would trigger 10 separate customer queries (the GraphQL equivalent of the N+1 problem you saw in the REST section).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// build.gradle\n// implementation 'org.springframework.boot:spring-boot-starter-graphql'\n\n@Controller\npublic class OrderGraphQLController {\n\n    @QueryMapping\n    public Order order(@Argument String id) {\n        return orderService.findById(id)\n            .orElseThrow(() -\u003e new GraphQLException(\"Order not found: \" + id));\n    }\n\n    @QueryMapping\n    public Connection\u0026#x3C;Order\u003e orders(@Argument OrderFilter filter,\n                                    @Argument int limit,\n                                    @Argument String cursor) {\n        return orderService.findPage(filter, limit, cursor);\n    }\n\n    // DataLoader: batch-load customers to avoid N+1\n    @SchemaMapping(typeName = \"Order\", field = \"customer\")\n    public CompletableFuture\u0026#x3C;Customer\u003e customer(Order order,\n                                                 DataLoader\u0026#x3C;String, Customer\u003e customerLoader) {\n        return customerLoader.load(order.getCustomerId());\n        // All customer loads within one request are batched into a single DB query\n    }\n}\n\n// DataLoader registration (batches N customer loads into 1 DB query)\n@Bean\npublic BatchLoaderRegistry batchLoaderRegistry() {\n    BatchLoaderRegistry registry = new DefaultBatchLoaderRegistry();\n    registry.forTypePair(String.class, Customer.class)\n        .withName(\"customerLoader\")\n        .registerBatchLoader((ids, env) -\u003e\n            Mono.fromCallable(() -\u003e customerService.findAllByIds(ids))\n        );\n    return registry;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eBatchLoaderRegistry\u003c/code\u003e is where the magic happens: instead of loading each customer immediately, it collects all customer IDs from a single request and fires one batched database query. This is a non-negotiable pattern â€” GraphQL without DataLoaders at scale is a performance disaster.\u003c/p\u003e\n\u003ch3\u003eGraphQL Mutations\u003c/h3\u003e\n\u003cp\u003eWhile queries read data, mutations modify it. GraphQL mutations differ from REST POST/PUT in one important way: they return a payload type that can contain both the result and business-level errors as data, rather than relying on HTTP status codes to signal what went wrong.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-graphql\"\u003etype Mutation {\n  createOrder(input: CreateOrderInput!): CreateOrderPayload!\n  updateOrderStatus(id: ID!, status: OrderStatus!): Order!\n}\n\ninput CreateOrderInput {\n  customerId: ID!\n  items: [OrderItemInput!]!\n  shippingAddress: AddressInput!\n}\n\ntype CreateOrderPayload {\n  order: Order            # The created order\n  errors: [UserError!]    # Business errors (not HTTP 4xx)\n}\n\ntype UserError {\n  field: String\n  message: String!\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@MutationMapping\npublic CreateOrderPayload createOrder(@Argument CreateOrderInput input) {\n    try {\n        Order order = orderService.create(input);\n        return CreateOrderPayload.success(order);\n    } catch (ValidationException e) {\n        return CreateOrderPayload.error(e.getField(), e.getMessage());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReturning business errors in the payload (rather than throwing HTTP 422 errors) is a deliberate GraphQL convention â€” it means the GraphQL response always has HTTP 200, and clients handle business logic errors through the \u003ccode\u003eerrors\u003c/code\u003e field in the response body. This keeps your error handling consistent regardless of the operation.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGraphQL sweet spot:\u003c/strong\u003e Mobile apps (bandwidth-sensitive), complex dashboards with many different data shapes, BFF (Backend For Frontend) pattern, when you have multiple clients needing different views of the same data.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGraphQL problems:\u003c/strong\u003e Query complexity attacks (clients can request deeply nested data), N+1 problem (requires DataLoader), caching is harder (no HTTP GET caching), learning curve.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003egRPC: High-Performance Service Communication\u003c/h2\u003e\n\u003cp\u003egRPC uses HTTP/2 and Protocol Buffers (binary serialization). It's 5-10x faster than REST/JSON for inter-service communication.\u003c/p\u003e\n\u003cp\u003eWhere REST uses human-readable JSON over HTTP/1.1, gRPC uses compact binary encoding over HTTP/2. Think of the difference between sending a hand-written letter and sending a compressed file â€” both carry information, but one is far more efficient to transmit and parse. The Protobuf schema below is the contract that both sides of a gRPC call agree on; it generates type-safe client and server code in any supported language.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-protobuf\"\u003e// order_service.proto\nsyntax = \"proto3\";\n\npackage order.v1;\n\nservice OrderService {\n  rpc GetOrder (GetOrderRequest) returns (Order);\n  rpc CreateOrder (CreateOrderRequest) returns (Order);\n  rpc UpdateOrderStatus (UpdateStatusRequest) returns (Order);\n\n  // Server streaming: stream order updates to client\n  rpc WatchOrder (WatchOrderRequest) returns (stream OrderEvent);\n\n  // Client streaming: bulk upload orders\n  rpc BulkCreateOrders (stream CreateOrderRequest) returns (BulkCreateResponse);\n\n  // Bidirectional streaming: real-time order management\n  rpc ManageOrders (stream OrderCommand) returns (stream OrderEvent);\n}\n\nmessage Order {\n  string id = 1;\n  string customer_id = 2;\n  OrderStatus status = 3;\n  repeated OrderItem items = 4;\n  int64 total_cents = 5;           // Avoid floats for money\n  google.protobuf.Timestamp created_at = 6;\n}\n\nenum OrderStatus {\n  ORDER_STATUS_UNSPECIFIED = 0;   // Proto3: always define 0 case\n  ORDER_STATUS_PENDING = 1;\n  ORDER_STATUS_CONFIRMED = 2;\n  ORDER_STATUS_SHIPPED = 3;\n  ORDER_STATUS_DELIVERED = 4;\n  ORDER_STATUS_CANCELLED = 5;\n}\n\nmessage GetOrderRequest {\n  string id = 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that \u003ccode\u003etotal_cents\u003c/code\u003e stores money as an integer instead of a float â€” this is a deliberate choice to avoid floating-point precision errors when dealing with currency. The streaming RPCs (\u003ccode\u003eWatchOrder\u003c/code\u003e, \u003ccode\u003eBulkCreateOrders\u003c/code\u003e, \u003ccode\u003eManageOrders\u003c/code\u003e) are capabilities that REST simply cannot match cleanly. The Java server implementation maps directly to these proto definitions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Server implementation\n@GrpcService\npublic class OrderGrpcService extends OrderServiceGrpc.OrderServiceImplBase {\n\n    @Override\n    public void getOrder(GetOrderRequest request, StreamObserver\u0026#x3C;Order\u003e responseObserver) {\n        try {\n            com.example.Order order = orderService.findById(request.getId())\n                .orElseThrow(() -\u003e Status.NOT_FOUND\n                    .withDescription(\"Order not found: \" + request.getId())\n                    .asRuntimeException());\n\n            responseObserver.onNext(toProto(order));\n            responseObserver.onCompleted();\n        } catch (StatusRuntimeException e) {\n            responseObserver.onError(e);\n        }\n    }\n\n    @Override\n    public void watchOrder(WatchOrderRequest request,\n                           StreamObserver\u0026#x3C;OrderEvent\u003e responseObserver) {\n        // Server streaming: push updates as order progresses\n        String orderId = request.getOrderId();\n        orderEventService.subscribe(orderId, event -\u003e {\n            if (!responseObserver.isReady()) return;\n            responseObserver.onNext(toProto(event));\n            if (event.isFinal()) responseObserver.onCompleted();\n        });\n    }\n}\n\n// Client (another service calling OrderService)\n@Service\npublic class PaymentService {\n\n    private final OrderServiceGrpc.OrderServiceBlockingStub orderStub;\n\n    public void processPayment(String orderId) {\n        // Unary call with deadline\n        Order order = orderStub\n            .withDeadlineAfter(500, TimeUnit.MILLISECONDS)\n            .getOrder(GetOrderRequest.newBuilder().setId(orderId).build());\n\n        // order is type-safe â€” proto-generated class\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e.withDeadlineAfter(500, TimeUnit.MILLISECONDS)\u003c/code\u003e call on the client stub is critical for production resilience â€” without deadlines, a slow upstream service can hold your threads indefinitely and cascade into a timeout storm across your entire service mesh. Always set deadlines on outbound gRPC calls.\u003c/p\u003e\n\u003ch3\u003egRPC Performance Numbers\u003c/h3\u003e\n\u003cp\u003eThe performance gap between gRPC and REST isn't theoretical â€” here are concrete numbers from a representative benchmark. The two main drivers are binary serialization (Protobuf vs JSON) and HTTP/2 multiplexing, which eliminates head-of-line blocking and reduces connection overhead.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBenchmark: 10,000 requests/sec, 1KB payload, same machine\n\nREST/JSON (Spring MVC):\n  p50 latency: 8ms\n  p99 latency: 45ms\n  CPU: 65%\n\ngRPC/Protobuf (same logic):\n  p50 latency: 1.2ms     â† 6.7x faster\n  p99 latency: 7ms       â† 6.4x faster\n  CPU: 28%               â† 2.3x less CPU\n\nWhy: Binary serialization + HTTP/2 multiplexing + header compression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe CPU reduction is especially important in microservice architectures â€” every percentage point of CPU saved at 10,000 RPS translates directly to infrastructure cost. For internal service calls that happen millions of times per day, this difference is significant.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003egRPC sweet spot:\u003c/strong\u003e Internal microservice-to-microservice communication, streaming use cases, polyglot environments (Go, Java, Python talking to each other), when you need maximum throughput and minimum latency.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003egRPC problems:\u003c/strong\u003e No browser support natively (needs gRPC-Web proxy), harder to debug (binary protocol), requires Protobuf toolchain, contract management.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eThe Decision Framework\u003c/h2\u003e\n\u003cp\u003eWith all three protocols understood in depth, you need a practical way to make the call for a new API surface. The two questions below cut through most of the deliberation: who is calling your API, and what shape does your data have?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Who are your clients?                         â”‚\nâ”‚                                                                   â”‚\nâ”‚  External/Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º REST           â”‚\nâ”‚  (browsers, third-party, mobile)                                  â”‚\nâ”‚                                                                   â”‚\nâ”‚  Internal service-to-service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º gRPC           â”‚\nâ”‚  (no browser, max performance)                                    â”‚\nâ”‚                                                                   â”‚\nâ”‚  Multiple clients, different data needs â”€â”€â”€â”€â”€â”€â”€â–º GraphQL        â”‚\nâ”‚  (mobile + web, BFF pattern)                                      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    What's your data shape?                        â”‚\nâ”‚                                                                   â”‚\nâ”‚  Simple CRUD, well-defined resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º REST           â”‚\nâ”‚  Deeply nested, relationship-heavy data â”€â”€â”€â”€â”€â”€â”€â–º GraphQL        â”‚\nâ”‚  Streaming, real-time, bidirectional â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º gRPC           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eFactor\u003c/th\u003e\n\u003cth\u003eREST\u003c/th\u003e\n\u003cth\u003eGraphQL\u003c/th\u003e\n\u003cth\u003egRPC\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBrowser support\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eNative\u003c/td\u003e\n\u003ctd\u003eNative\u003c/td\u003e\n\u003ctd\u003eNeeds proxy\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCaching\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eExcellent (HTTP cache)\u003c/td\u003e\n\u003ctd\u003eHard\u003c/td\u003e\n\u003ctd\u003eManual\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOverfetching\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eCommon problem\u003c/td\u003e\n\u003ctd\u003eSolved\u003c/td\u003e\n\u003ctd\u003eN/A\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eStreaming\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eLimited (SSE)\u003c/td\u003e\n\u003ctd\u003eSubscriptions\u003c/td\u003e\n\u003ctd\u003eNative\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eGood\u003c/td\u003e\n\u003ctd\u003eGood\u003c/td\u003e\n\u003ctd\u003eExcellent\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eLearning curve\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eLow\u003c/td\u003e\n\u003ctd\u003eMedium\u003c/td\u003e\n\u003ctd\u003eMedium\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eTooling/ecosystem\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eExcellent\u003c/td\u003e\n\u003ctd\u003eGood\u003c/td\u003e\n\u003ctd\u003eGood\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eContract-first\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eOptional (OpenAPI)\u003c/td\u003e\n\u003ctd\u003eSchema required\u003c/td\u003e\n\u003ctd\u003eProtobuf required\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBest for\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003ePublic APIs\u003c/td\u003e\n\u003ctd\u003eComplex clients\u003c/td\u003e\n\u003ctd\u003eInternal services\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003eReal-World Architecture: Use All Three\u003c/h2\u003e\n\u003cp\u003eIn practice, mature production systems don't pick one protocol and force it everywhere â€” they use each protocol where it excels. The architecture below is representative of how companies like Uber and Netflix structure their API layers. REST faces the public; gRPC connects internal services for speed; GraphQL serves as a flexible aggregation layer for complex client needs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExternal clients (browser, mobile)\n    â”‚\n    â–¼\nAPI Gateway (REST)      â† Public-facing, cacheable, familiar\n    â”‚\n    â”œâ”€â”€â–º User Service â”€â”€â”€â”€â”€â”€â”€â”€ gRPC â”€â”€â–º Auth Service\n    â”‚                                       â”‚\n    â”œâ”€â”€â–º Product Service â”€â”€â”€â”€ gRPC â”€â”€â–º Inventory Service\n    â”‚                                       â”‚\n    â”œâ”€â”€â–º BFF Service â”€â”€â”€â”€â”€â”€ GraphQL â”€â”€â–º (aggregates Product + User)\n    â”‚         â”‚                          (serves mobile app)\n    â””â”€â”€â–º Order Service â”€â”€â”€â”€â”€ gRPC â”€â”€â–º Payment Service\n                                         â”‚\n                                     Notification Service\n                                     (gRPC streaming)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe gateway is REST. Internal hop is gRPC. The mobile BFF is GraphQL. This isn't over-engineering â€” each protocol does one thing well.\u003c/p\u003e\n\u003cp\u003eThe worst outcome is picking one protocol for ideological reasons and forcing it everywhere. REST for streaming is painful. gRPC for public APIs is hostile to users. GraphQL for simple CRUD is overengineered. Let the use case choose the protocol.\u003c/p\u003e\n","tableOfContents":[{"id":"the-core-trade-off","text":"The Core Trade-off","level":2},{"id":"rest-the-default-choice","text":"REST: The Default Choice","level":2},{"id":"rest-api-design-getting-it-right","text":"REST API Design â€” Getting It Right","level":3},{"id":"rest-error-response-standard","text":"REST Error Response Standard","level":3},{"id":"rest-pagination","text":"REST Pagination","level":3},{"id":"graphql-client-defined-queries","text":"GraphQL: Client-Defined Queries","level":2},{"id":"spring-boot-graphql-implementation","text":"Spring Boot GraphQL Implementation","level":3},{"id":"graphql-mutations","text":"GraphQL Mutations","level":3},{"id":"grpc-high-performance-service-communication","text":"gRPC: High-Performance Service Communication","level":2},{"id":"grpc-performance-numbers","text":"gRPC Performance Numbers","level":3},{"id":"the-decision-framework","text":"The Decision Framework","level":2},{"id":"real-world-architecture-use-all-three","text":"Real-World Architecture: Use All Three","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why â€” by exploring system state through metrics, traces, and logs without needing to know in advanceâ€¦"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory â€” store events instead of state, derive state by replaying events â€” is souâ€¦"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to tâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"api-design-rest-graphql-grpc"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>