<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">DynamoDB Advanced Patterns: Single-Table Design and Beyond<!-- --> | CodeSprintPro</title><meta name="description" content="Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/dynamodb-advanced-patterns/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="DynamoDB Advanced Patterns: Single-Table Design and Beyond" data-next-head=""/><meta property="og:description" content="Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/dynamodb-advanced-patterns/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-06-13" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="dynamodb" data-next-head=""/><meta property="article:tag" content="aws" data-next-head=""/><meta property="article:tag" content="nosql" data-next-head=""/><meta property="article:tag" content="single-table design" data-next-head=""/><meta property="article:tag" content="gsi" data-next-head=""/><meta property="article:tag" content="dynamodb streams" data-next-head=""/><meta property="article:tag" content="serverless" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="DynamoDB Advanced Patterns: Single-Table Design and Beyond" data-next-head=""/><meta name="twitter:description" content="Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-06-13","dateModified":"2025-06-13","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/dynamodb-advanced-patterns/"},"keywords":"dynamodb, aws, nosql, single-table design, gsi, dynamodb streams, serverless","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">DynamoDB Advanced Patterns: Single-Table Design and Beyond</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>June 13, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->dynamodb</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->aws</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->nosql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->single-table design</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->gsi</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->dynamodb streams</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->serverless</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you build your schema, because the schema directly encodes those patterns. The engineers who learn DynamoDB from relational habits write inefficient schemas. The engineers who internalize its data model write schemas that scale to billions of rows with consistent latency.</p>
<h2>DynamoDB's Data Model</h2>
<p>Every DynamoDB table has a primary key â€” either a partition key (simple) or a partition key + sort key (composite). Unlike Cassandra, there's no concept of clustering order across the whole table â€” ordering is local to a partition key.</p>
<pre><code>Table: Orders
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PK (pk)    â”‚  SK (sk)         â”‚  Attributes         â”‚  Notes        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ORDER#1001  â”‚ ORDER#1001       â”‚ status, total, date â”‚ Order entity  â”‚
â”‚ ORDER#1001  â”‚ ITEM#prod-001    â”‚ qty, price, name    â”‚ Order item    â”‚
â”‚ ORDER#1001  â”‚ ITEM#prod-002    â”‚ qty, price, name    â”‚ Order item    â”‚
â”‚ ORDER#1001  â”‚ STATUS#shipped   â”‚ carrier, tracking   â”‚ Status event  â”‚
â”‚ CUSTOMER#42 â”‚ CUSTOMER#42      â”‚ name, email, tier   â”‚ Customer      â”‚
â”‚ CUSTOMER#42 â”‚ ORDER#1001       â”‚ date, status, total â”‚ Cust â†’ Order  â”‚
â”‚ CUSTOMER#42 â”‚ ORDER#1005       â”‚ date, status, total â”‚ Cust â†’ Order  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>This is single-table design â€” multiple entity types co-exist in one table, distinguished by the format of their PK/SK values.</p>
<h2>Single-Table Design: The Core Principle</h2>
<p>In relational databases, one entity = one table. In DynamoDB, one access pattern group = one table. Single-table design collapses your entities into one table, enabling:</p>
<ol>
<li><strong>Transactional writes</strong> across related entities (DynamoDB transactions require items to be in the same table)</li>
<li><strong>Query efficiency</strong> â€” fetching an order with all its items in one request using <code>Query</code></li>
<li><strong>Cost efficiency</strong> â€” fewer requests = fewer RCUs consumed</li>
</ol>
<p><strong>Access pattern mapping (do this before writing a line of code):</strong></p>
<table>
<thead>
<tr>
<th>Access Pattern</th>
<th>Operation</th>
<th>Key Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get order by ID</td>
<td>GetItem</td>
<td>PK=ORDER#id, SK=ORDER#id</td>
</tr>
<tr>
<td>Get all items in order</td>
<td>Query</td>
<td>PK=ORDER#id, SK begins_with ITEM#</td>
</tr>
<tr>
<td>Get all orders for customer</td>
<td>Query</td>
<td>PK=CUSTOMER#id, SK begins_with ORDER#</td>
</tr>
<tr>
<td>Get customer profile</td>
<td>GetItem</td>
<td>PK=CUSTOMER#id, SK=CUSTOMER#id</td>
</tr>
<tr>
<td>Get order status history</td>
<td>Query</td>
<td>PK=ORDER#id, SK begins_with STATUS#</td>
</tr>
</tbody>
</table>
<p>Each row in this table drives a direct DynamoDB operation. If you can't express a query as a <code>GetItem</code> or <code>Query</code> on your primary key structure, you need a GSI.</p>
<h2>Global Secondary Indexes: Overloading and Sparse Indexes</h2>
<p><strong>GSI basics:</strong> A GSI is a separate index with a different partition key (and optional sort key). DynamoDB automatically maintains it. You can query on GSI keys the same way you query the main table.</p>
<p><strong>GSI overloading</strong> â€” one GSI serves multiple access patterns:</p>
<pre><code>GSI: GSI1 (gsi1pk, gsi1sk)

Item type    | gsi1pk                 | gsi1sk          | Access pattern
-------------|------------------------|-----------------|------------------------
Order        | STATUS#pending         | ORDER#2025-01-15| All pending orders by date
Customer     | TIER#gold              | CUSTOMER#name   | All gold tier customers
Product      | CATEGORY#electronics  | PRODUCT#name    | All electronics products
</code></pre>
<p>One GSI answers three different queries â€” "all pending orders", "gold tier customers", "electronics products" â€” by using a generic <code>gsi1pk</code>/<code>gsi1sk</code> attribute name that different entity types populate with different values.</p>
<pre><code class="language-javascript">// DynamoDB SDK v3 (JavaScript/TypeScript):

// All pending orders (most recent first):
const pendingOrders = await client.send(new QueryCommand({
  TableName: 'Orders',
  IndexName: 'GSI1',
  KeyConditionExpression: 'gsi1pk = :status',
  ExpressionAttributeValues: {
    ':status': 'STATUS#pending'
  },
  ScanIndexForward: false  // DESC order
}));

// Gold tier customers:
const goldCustomers = await client.send(new QueryCommand({
  TableName: 'Orders',
  IndexName: 'GSI1',
  KeyConditionExpression: 'gsi1pk = :tier',
  ExpressionAttributeValues: {
    ':tier': 'TIER#gold'
  }
}));
</code></pre>
<p><strong>Sparse indexes</strong> â€” GSIs only include items that have the GSI key attribute. This creates naturally filtered indexes:</p>
<pre><code class="language-javascript">// Only active sessions have a TTL and gsi1pk='SESSION#active'
// Expired sessions have no gsi1pk â†’ not in GSI
// Result: GSI contains only active sessions â€” no filter needed

const activeSessions = await client.send(new QueryCommand({
  TableName: 'Table',
  IndexName: 'GSI1',
  KeyConditionExpression: 'gsi1pk = :active',
  ExpressionAttributeValues: { ':active': 'SESSION#active' }
}));
</code></pre>
<h2>Adjacency List Pattern: Graph Relationships</h2>
<p>For many-to-many relationships (e.g., users follow other users, products in multiple categories):</p>
<pre><code>Following relationship (Twitter-like):
PK              | SK              | type     | gsi1pk          | gsi1sk
----------------|-----------------|----------|-----------------|----------------
USER#alice      | USER#alice      | USER     | â€”               | â€”
USER#alice      | FOLLOWS#bob     | FOLLOW   | FOLLOWED_BY#bob | USER#alice
USER#alice      | FOLLOWS#carol   | FOLLOW   | FOLLOWED_BY#carol| USER#alice
USER#bob        | USER#bob        | USER     | â€”               | â€”
USER#bob        | FOLLOWS#alice   | FOLLOW   | FOLLOWED_BY#alice| USER#bob

Access patterns:
1. "Who does Alice follow?"     â†’ Query PK=USER#alice, SK begins_with FOLLOWS#
2. "Who follows Bob?"          â†’ Query GSI1 gsi1pk=FOLLOWED_BY#bob
3. "Does Alice follow Bob?"    â†’ GetItem PK=USER#alice, SK=FOLLOWS#bob
</code></pre>
<p>The adjacency list stores the relationship in both directions â€” direct on the main table (PK of follower), inverted via GSI (queried by followee). No join table needed.</p>
<h2>DynamoDB Streams and Event-Driven Patterns</h2>
<p>DynamoDB Streams capture every write (INSERT, MODIFY, REMOVE) as an ordered record per partition. Combine with Lambda for event-driven architectures:</p>
<pre><code>DynamoDB Streams Architecture:

Write â†’ DynamoDB Table â†’ Stream (ordered per partition)
                              â†“
                         Lambda trigger
                         (128 shards max)
                              â†“
                    Event processing:
                    - Fan-out notifications
                    - Update search index (Elasticsearch)
                    - Replicate to analytics (Kinesis â†’ S3)
                    - Invalidate cache (ElastiCache)
                    - Cross-region replication
</code></pre>
<pre><code class="language-javascript">// Lambda handler for DynamoDB Stream:
export const handler = async (event: DynamoDBStreamEvent) => {
  for (const record of event.Records) {
    if (record.eventName === 'INSERT') {
      const newItem = unmarshall(record.dynamodb!.NewImage!);

      if (newItem.pk?.startsWith('ORDER#')) {
        // New order created â€” send confirmation email
        await emailService.sendOrderConfirmation(newItem);
        // Update search index
        await searchService.indexOrder(newItem);
      }
    }

    if (record.eventName === 'MODIFY') {
      const oldItem = unmarshall(record.dynamodb!.OldImage!);
      const newItem = unmarshall(record.dynamodb!.NewImage!);

      if (oldItem.status !== newItem.status) {
        // Status changed â€” trigger downstream workflow
        await workflowService.onStatusChange(newItem.pk, oldItem.status, newItem.status);
      }
    }
  }
};
</code></pre>
<p><strong>Stream delivery guarantees:</strong></p>
<ul>
<li>Each record delivered at least once (exactly-once semantics not guaranteed)</li>
<li>Records delivered in order per partition key</li>
<li>Lambda processes shards concurrently â€” different partition keys may process in parallel</li>
</ul>
<p>Design your handlers to be idempotent (safe to call multiple times with the same record).</p>
<h2>Transactions: ACID Across Multiple Items</h2>
<p>DynamoDB supports ACID transactions for up to 100 items per transaction:</p>
<pre><code class="language-javascript">// Transfer funds between accounts (atomic debit + credit):
const transferFunds = async (fromAccountId: string, toAccountId: string, amount: number) => {
  await client.send(new TransactWriteCommand({
    TransactItems: [
      {
        // Debit source account (with condition: sufficient funds)
        Update: {
          TableName: 'Accounts',
          Key: { pk: `ACCOUNT#${fromAccountId}`, sk: `ACCOUNT#${fromAccountId}` },
          UpdateExpression: 'SET balance = balance - :amount',
          ConditionExpression: 'balance >= :amount',
          ExpressionAttributeValues: { ':amount': amount }
        }
      },
      {
        // Credit destination account
        Update: {
          TableName: 'Accounts',
          Key: { pk: `ACCOUNT#${toAccountId}`, sk: `ACCOUNT#${toAccountId}` },
          UpdateExpression: 'SET balance = balance + :amount',
          ExpressionAttributeValues: { ':amount': amount }
        }
      },
      {
        // Write transaction record
        Put: {
          TableName: 'Accounts',
          Item: {
            pk: `TRANSFER#${uuid()}`,
            sk: `TRANSFER#${uuid()}`,
            fromAccount: fromAccountId,
            toAccount: toAccountId,
            amount,
            createdAt: new Date().toISOString()
          }
        }
      }
    ]
  }));
};
</code></pre>
<p>Transactions use OCC (optimistic concurrency control). If any condition fails, the entire transaction is rolled back. Cost: 2Ã— read/write capacity units compared to non-transactional operations.</p>
<h2>Capacity Planning: Avoiding Bill Shock</h2>
<p>DynamoDB pricing is based on Read Capacity Units (RCUs) and Write Capacity Units (WCUs):</p>
<pre><code>1 RCU = 1 strongly consistent read of up to 4KB
      = 2 eventually consistent reads of up to 4KB
      = 0.5 transactional reads of up to 4KB

1 WCU = 1 write of up to 1KB
      = 0.5 transactional writes of up to 1KB

On-demand pricing (us-east-1):
$0.25 per million read request units
$1.25 per million write request units

Provisioned capacity pricing:
$0.00013 per RCU-hour ($0.0065 per RCU-day)
$0.00065 per WCU-hour ($0.0325 per WCU-day)
</code></pre>
<p><strong>Example calculation:</strong></p>
<p>E-commerce site: 1,000 orders/hour, each order writes 5 items (order + 3 items + customer update) of ~500 bytes each.</p>
<pre><code>Writes:
1,000 orders/hour Ã— 5 items Ã— 1 WCU (500 bytes &#x3C; 1KB)
= 5,000 WCUs/hour for orders

If using transactions (2Ã— cost):
= 10,000 WCUs/hour

Monthly cost (on-demand):
10,000 WCUs/hour Ã— 720 hours Ã— $1.25/million
= 7.2M WCUs Ã— $1.25/million = $9/month for writes

Reads (query order + items = 1 RCU per request):
Assume 5Ã— read:write ratio = 25,000 RCUs/hour
Monthly cost: 18M RCUs Ã— $0.25/million = $4.50/month

Total: ~$13.50/month for 720,000 orders
</code></pre>
<p>At this scale, on-demand is fine. At 10M orders/month, provisioned capacity with auto-scaling is 70-80% cheaper.</p>
<p><strong>Hot partition detection:</strong></p>
<pre><code>CloudWatch metric to monitor:
- ConsumedWriteCapacityUnits (per-partition) â€” not exposed directly
- ThrottledRequests > 0 â€” always indicates a problem
- SystemErrors â€” usually indicates hot partitions causing timeouts

In AWS Console: DynamoDB â†’ Metrics â†’ ConsumedWriteCapacityUnits
Look for spikes indicating one partition getting disproportionate traffic
</code></pre>
<p>Signs of a hot partition:</p>
<ul>
<li>Throttling on specific items even though provisioned capacity isn't exhausted globally</li>
<li>One product/user getting orders of magnitude more traffic than others</li>
</ul>
<p>Fix: Add jitter to partition keys (e.g., append a random 0-9 suffix, query all 10 suffixes and merge client-side).</p>
<h2>TTL: Automatic Data Expiration</h2>
<p>DynamoDB TTL automatically deletes items past their expiration timestamp â€” at no cost:</p>
<pre><code class="language-javascript">// Setting TTL:
const expirationTime = Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60); // 30 days

await client.send(new PutItemCommand({
  TableName: 'Sessions',
  Item: {
    pk: { S: `SESSION#${sessionId}` },
    sk: { S: `SESSION#${sessionId}` },
    userId: { S: userId },
    ttl: { N: expirationTime.toString() }  // Unix epoch seconds
  }
}));

// DynamoDB automatically deletes items when ttl &#x3C; current epoch
// Deletion happens within 48 hours of expiration
// Deleted items appear in DynamoDB Streams as REMOVE events (useful for audit)
</code></pre>
<p>TTL is the correct pattern for session data, temporary caches, and compliance-driven data retention. Never run a Lambda to purge old data â€” TTL does it free.</p>
<h2>When DynamoDB Is Wrong</h2>
<p>DynamoDB excels at:</p>
<ul>
<li>Known, stable access patterns (OLTP workloads)</li>
<li>Key-value lookups at massive scale</li>
<li>Event sourcing and time-series data</li>
<li>Serverless architectures (pay-per-request, zero management)</li>
</ul>
<p>DynamoDB is the wrong choice for:</p>
<ul>
<li>Ad-hoc analytics (use Athena on S3 exports or Redshift)</li>
<li>Complex queries with multiple filter conditions on non-indexed attributes</li>
<li>Flexible schema requirements that change frequently (schema changes in single-table design are painful)</li>
<li>Teams without DynamoDB expertise (the learning curve is steep and mistakes are expensive)</li>
</ul>
<p>The difference between DynamoDB experts and beginners: experts define all access patterns on a whiteboard before writing any code. Every GSI, every overloaded attribute, every entity prefix is a deliberate decision made against a list of queries the application must support. The schema follows the queries â€” not the other way around.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB â€” The Complete Developer&#x27;s Guide â€” Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=DynamoDB%20Advanced%20Patterns%3A%20Single-Table%20Design%20and%20Beyond&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fdynamodb-advanced-patterns%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fdynamodb-advanced-patterns%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#dynamodbs-data-model" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">DynamoDB&#x27;s Data Model</a></li><li class=""><a href="#single-table-design-the-core-principle" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Single-Table Design: The Core Principle</a></li><li class=""><a href="#global-secondary-indexes-overloading-and-sparse-indexes" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Global Secondary Indexes: Overloading and Sparse Indexes</a></li><li class=""><a href="#adjacency-list-pattern-graph-relationships" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Adjacency List Pattern: Graph Relationships</a></li><li class=""><a href="#dynamodb-streams-and-event-driven-patterns" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">DynamoDB Streams and Event-Driven Patterns</a></li><li class=""><a href="#transactions-acid-across-multiple-items" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Transactions: ACID Across Multiple Items</a></li><li class=""><a href="#capacity-planning-avoiding-bill-shock" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Capacity Planning: Avoiding Bill Shock</a></li><li class=""><a href="#ttl-automatic-data-expiration" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">TTL: Automatic Data Expiration</a></li><li class=""><a href="#when-dynamodb-is-wrong" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">When DynamoDB Is Wrong</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring â€” every node is equal, there&#x27;s no primary, and data placement is determined by partitâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible â€” rollback a bad deploy and your code is back to the previous version. Database schema changes are stâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a><a href="/blog/postgresql-performance-tuning/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem â€” they&#x27;re a query design problem that Postâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->databases</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->performance</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before youâ€¦","contentHtml":"\u003cp\u003eDynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you build your schema, because the schema directly encodes those patterns. The engineers who learn DynamoDB from relational habits write inefficient schemas. The engineers who internalize its data model write schemas that scale to billions of rows with consistent latency.\u003c/p\u003e\n\u003ch2\u003eDynamoDB's Data Model\u003c/h2\u003e\n\u003cp\u003eEvery DynamoDB table has a primary key â€” either a partition key (simple) or a partition key + sort key (composite). Unlike Cassandra, there's no concept of clustering order across the whole table â€” ordering is local to a partition key.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTable: Orders\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  PK (pk)    â”‚  SK (sk)         â”‚  Attributes         â”‚  Notes        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ ORDER#1001  â”‚ ORDER#1001       â”‚ status, total, date â”‚ Order entity  â”‚\nâ”‚ ORDER#1001  â”‚ ITEM#prod-001    â”‚ qty, price, name    â”‚ Order item    â”‚\nâ”‚ ORDER#1001  â”‚ ITEM#prod-002    â”‚ qty, price, name    â”‚ Order item    â”‚\nâ”‚ ORDER#1001  â”‚ STATUS#shipped   â”‚ carrier, tracking   â”‚ Status event  â”‚\nâ”‚ CUSTOMER#42 â”‚ CUSTOMER#42      â”‚ name, email, tier   â”‚ Customer      â”‚\nâ”‚ CUSTOMER#42 â”‚ ORDER#1001       â”‚ date, status, total â”‚ Cust â†’ Order  â”‚\nâ”‚ CUSTOMER#42 â”‚ ORDER#1005       â”‚ date, status, total â”‚ Cust â†’ Order  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is single-table design â€” multiple entity types co-exist in one table, distinguished by the format of their PK/SK values.\u003c/p\u003e\n\u003ch2\u003eSingle-Table Design: The Core Principle\u003c/h2\u003e\n\u003cp\u003eIn relational databases, one entity = one table. In DynamoDB, one access pattern group = one table. Single-table design collapses your entities into one table, enabling:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eTransactional writes\u003c/strong\u003e across related entities (DynamoDB transactions require items to be in the same table)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQuery efficiency\u003c/strong\u003e â€” fetching an order with all its items in one request using \u003ccode\u003eQuery\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCost efficiency\u003c/strong\u003e â€” fewer requests = fewer RCUs consumed\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eAccess pattern mapping (do this before writing a line of code):\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eAccess Pattern\u003c/th\u003e\n\u003cth\u003eOperation\u003c/th\u003e\n\u003cth\u003eKey Condition\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eGet order by ID\u003c/td\u003e\n\u003ctd\u003eGetItem\u003c/td\u003e\n\u003ctd\u003ePK=ORDER#id, SK=ORDER#id\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGet all items in order\u003c/td\u003e\n\u003ctd\u003eQuery\u003c/td\u003e\n\u003ctd\u003ePK=ORDER#id, SK begins_with ITEM#\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGet all orders for customer\u003c/td\u003e\n\u003ctd\u003eQuery\u003c/td\u003e\n\u003ctd\u003ePK=CUSTOMER#id, SK begins_with ORDER#\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGet customer profile\u003c/td\u003e\n\u003ctd\u003eGetItem\u003c/td\u003e\n\u003ctd\u003ePK=CUSTOMER#id, SK=CUSTOMER#id\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGet order status history\u003c/td\u003e\n\u003ctd\u003eQuery\u003c/td\u003e\n\u003ctd\u003ePK=ORDER#id, SK begins_with STATUS#\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eEach row in this table drives a direct DynamoDB operation. If you can't express a query as a \u003ccode\u003eGetItem\u003c/code\u003e or \u003ccode\u003eQuery\u003c/code\u003e on your primary key structure, you need a GSI.\u003c/p\u003e\n\u003ch2\u003eGlobal Secondary Indexes: Overloading and Sparse Indexes\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eGSI basics:\u003c/strong\u003e A GSI is a separate index with a different partition key (and optional sort key). DynamoDB automatically maintains it. You can query on GSI keys the same way you query the main table.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGSI overloading\u003c/strong\u003e â€” one GSI serves multiple access patterns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGSI: GSI1 (gsi1pk, gsi1sk)\n\nItem type    | gsi1pk                 | gsi1sk          | Access pattern\n-------------|------------------------|-----------------|------------------------\nOrder        | STATUS#pending         | ORDER#2025-01-15| All pending orders by date\nCustomer     | TIER#gold              | CUSTOMER#name   | All gold tier customers\nProduct      | CATEGORY#electronics  | PRODUCT#name    | All electronics products\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne GSI answers three different queries â€” \"all pending orders\", \"gold tier customers\", \"electronics products\" â€” by using a generic \u003ccode\u003egsi1pk\u003c/code\u003e/\u003ccode\u003egsi1sk\u003c/code\u003e attribute name that different entity types populate with different values.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// DynamoDB SDK v3 (JavaScript/TypeScript):\n\n// All pending orders (most recent first):\nconst pendingOrders = await client.send(new QueryCommand({\n  TableName: 'Orders',\n  IndexName: 'GSI1',\n  KeyConditionExpression: 'gsi1pk = :status',\n  ExpressionAttributeValues: {\n    ':status': 'STATUS#pending'\n  },\n  ScanIndexForward: false  // DESC order\n}));\n\n// Gold tier customers:\nconst goldCustomers = await client.send(new QueryCommand({\n  TableName: 'Orders',\n  IndexName: 'GSI1',\n  KeyConditionExpression: 'gsi1pk = :tier',\n  ExpressionAttributeValues: {\n    ':tier': 'TIER#gold'\n  }\n}));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSparse indexes\u003c/strong\u003e â€” GSIs only include items that have the GSI key attribute. This creates naturally filtered indexes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Only active sessions have a TTL and gsi1pk='SESSION#active'\n// Expired sessions have no gsi1pk â†’ not in GSI\n// Result: GSI contains only active sessions â€” no filter needed\n\nconst activeSessions = await client.send(new QueryCommand({\n  TableName: 'Table',\n  IndexName: 'GSI1',\n  KeyConditionExpression: 'gsi1pk = :active',\n  ExpressionAttributeValues: { ':active': 'SESSION#active' }\n}));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAdjacency List Pattern: Graph Relationships\u003c/h2\u003e\n\u003cp\u003eFor many-to-many relationships (e.g., users follow other users, products in multiple categories):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFollowing relationship (Twitter-like):\nPK              | SK              | type     | gsi1pk          | gsi1sk\n----------------|-----------------|----------|-----------------|----------------\nUSER#alice      | USER#alice      | USER     | â€”               | â€”\nUSER#alice      | FOLLOWS#bob     | FOLLOW   | FOLLOWED_BY#bob | USER#alice\nUSER#alice      | FOLLOWS#carol   | FOLLOW   | FOLLOWED_BY#carol| USER#alice\nUSER#bob        | USER#bob        | USER     | â€”               | â€”\nUSER#bob        | FOLLOWS#alice   | FOLLOW   | FOLLOWED_BY#alice| USER#bob\n\nAccess patterns:\n1. \"Who does Alice follow?\"     â†’ Query PK=USER#alice, SK begins_with FOLLOWS#\n2. \"Who follows Bob?\"          â†’ Query GSI1 gsi1pk=FOLLOWED_BY#bob\n3. \"Does Alice follow Bob?\"    â†’ GetItem PK=USER#alice, SK=FOLLOWS#bob\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe adjacency list stores the relationship in both directions â€” direct on the main table (PK of follower), inverted via GSI (queried by followee). No join table needed.\u003c/p\u003e\n\u003ch2\u003eDynamoDB Streams and Event-Driven Patterns\u003c/h2\u003e\n\u003cp\u003eDynamoDB Streams capture every write (INSERT, MODIFY, REMOVE) as an ordered record per partition. Combine with Lambda for event-driven architectures:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDynamoDB Streams Architecture:\n\nWrite â†’ DynamoDB Table â†’ Stream (ordered per partition)\n                              â†“\n                         Lambda trigger\n                         (128 shards max)\n                              â†“\n                    Event processing:\n                    - Fan-out notifications\n                    - Update search index (Elasticsearch)\n                    - Replicate to analytics (Kinesis â†’ S3)\n                    - Invalidate cache (ElastiCache)\n                    - Cross-region replication\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Lambda handler for DynamoDB Stream:\nexport const handler = async (event: DynamoDBStreamEvent) =\u003e {\n  for (const record of event.Records) {\n    if (record.eventName === 'INSERT') {\n      const newItem = unmarshall(record.dynamodb!.NewImage!);\n\n      if (newItem.pk?.startsWith('ORDER#')) {\n        // New order created â€” send confirmation email\n        await emailService.sendOrderConfirmation(newItem);\n        // Update search index\n        await searchService.indexOrder(newItem);\n      }\n    }\n\n    if (record.eventName === 'MODIFY') {\n      const oldItem = unmarshall(record.dynamodb!.OldImage!);\n      const newItem = unmarshall(record.dynamodb!.NewImage!);\n\n      if (oldItem.status !== newItem.status) {\n        // Status changed â€” trigger downstream workflow\n        await workflowService.onStatusChange(newItem.pk, oldItem.status, newItem.status);\n      }\n    }\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eStream delivery guarantees:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEach record delivered at least once (exactly-once semantics not guaranteed)\u003c/li\u003e\n\u003cli\u003eRecords delivered in order per partition key\u003c/li\u003e\n\u003cli\u003eLambda processes shards concurrently â€” different partition keys may process in parallel\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDesign your handlers to be idempotent (safe to call multiple times with the same record).\u003c/p\u003e\n\u003ch2\u003eTransactions: ACID Across Multiple Items\u003c/h2\u003e\n\u003cp\u003eDynamoDB supports ACID transactions for up to 100 items per transaction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Transfer funds between accounts (atomic debit + credit):\nconst transferFunds = async (fromAccountId: string, toAccountId: string, amount: number) =\u003e {\n  await client.send(new TransactWriteCommand({\n    TransactItems: [\n      {\n        // Debit source account (with condition: sufficient funds)\n        Update: {\n          TableName: 'Accounts',\n          Key: { pk: `ACCOUNT#${fromAccountId}`, sk: `ACCOUNT#${fromAccountId}` },\n          UpdateExpression: 'SET balance = balance - :amount',\n          ConditionExpression: 'balance \u003e= :amount',\n          ExpressionAttributeValues: { ':amount': amount }\n        }\n      },\n      {\n        // Credit destination account\n        Update: {\n          TableName: 'Accounts',\n          Key: { pk: `ACCOUNT#${toAccountId}`, sk: `ACCOUNT#${toAccountId}` },\n          UpdateExpression: 'SET balance = balance + :amount',\n          ExpressionAttributeValues: { ':amount': amount }\n        }\n      },\n      {\n        // Write transaction record\n        Put: {\n          TableName: 'Accounts',\n          Item: {\n            pk: `TRANSFER#${uuid()}`,\n            sk: `TRANSFER#${uuid()}`,\n            fromAccount: fromAccountId,\n            toAccount: toAccountId,\n            amount,\n            createdAt: new Date().toISOString()\n          }\n        }\n      }\n    ]\n  }));\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTransactions use OCC (optimistic concurrency control). If any condition fails, the entire transaction is rolled back. Cost: 2Ã— read/write capacity units compared to non-transactional operations.\u003c/p\u003e\n\u003ch2\u003eCapacity Planning: Avoiding Bill Shock\u003c/h2\u003e\n\u003cp\u003eDynamoDB pricing is based on Read Capacity Units (RCUs) and Write Capacity Units (WCUs):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1 RCU = 1 strongly consistent read of up to 4KB\n      = 2 eventually consistent reads of up to 4KB\n      = 0.5 transactional reads of up to 4KB\n\n1 WCU = 1 write of up to 1KB\n      = 0.5 transactional writes of up to 1KB\n\nOn-demand pricing (us-east-1):\n$0.25 per million read request units\n$1.25 per million write request units\n\nProvisioned capacity pricing:\n$0.00013 per RCU-hour ($0.0065 per RCU-day)\n$0.00065 per WCU-hour ($0.0325 per WCU-day)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eExample calculation:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eE-commerce site: 1,000 orders/hour, each order writes 5 items (order + 3 items + customer update) of ~500 bytes each.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWrites:\n1,000 orders/hour Ã— 5 items Ã— 1 WCU (500 bytes \u0026#x3C; 1KB)\n= 5,000 WCUs/hour for orders\n\nIf using transactions (2Ã— cost):\n= 10,000 WCUs/hour\n\nMonthly cost (on-demand):\n10,000 WCUs/hour Ã— 720 hours Ã— $1.25/million\n= 7.2M WCUs Ã— $1.25/million = $9/month for writes\n\nReads (query order + items = 1 RCU per request):\nAssume 5Ã— read:write ratio = 25,000 RCUs/hour\nMonthly cost: 18M RCUs Ã— $0.25/million = $4.50/month\n\nTotal: ~$13.50/month for 720,000 orders\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this scale, on-demand is fine. At 10M orders/month, provisioned capacity with auto-scaling is 70-80% cheaper.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHot partition detection:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCloudWatch metric to monitor:\n- ConsumedWriteCapacityUnits (per-partition) â€” not exposed directly\n- ThrottledRequests \u003e 0 â€” always indicates a problem\n- SystemErrors â€” usually indicates hot partitions causing timeouts\n\nIn AWS Console: DynamoDB â†’ Metrics â†’ ConsumedWriteCapacityUnits\nLook for spikes indicating one partition getting disproportionate traffic\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSigns of a hot partition:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThrottling on specific items even though provisioned capacity isn't exhausted globally\u003c/li\u003e\n\u003cli\u003eOne product/user getting orders of magnitude more traffic than others\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFix: Add jitter to partition keys (e.g., append a random 0-9 suffix, query all 10 suffixes and merge client-side).\u003c/p\u003e\n\u003ch2\u003eTTL: Automatic Data Expiration\u003c/h2\u003e\n\u003cp\u003eDynamoDB TTL automatically deletes items past their expiration timestamp â€” at no cost:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Setting TTL:\nconst expirationTime = Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60); // 30 days\n\nawait client.send(new PutItemCommand({\n  TableName: 'Sessions',\n  Item: {\n    pk: { S: `SESSION#${sessionId}` },\n    sk: { S: `SESSION#${sessionId}` },\n    userId: { S: userId },\n    ttl: { N: expirationTime.toString() }  // Unix epoch seconds\n  }\n}));\n\n// DynamoDB automatically deletes items when ttl \u0026#x3C; current epoch\n// Deletion happens within 48 hours of expiration\n// Deleted items appear in DynamoDB Streams as REMOVE events (useful for audit)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTTL is the correct pattern for session data, temporary caches, and compliance-driven data retention. Never run a Lambda to purge old data â€” TTL does it free.\u003c/p\u003e\n\u003ch2\u003eWhen DynamoDB Is Wrong\u003c/h2\u003e\n\u003cp\u003eDynamoDB excels at:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKnown, stable access patterns (OLTP workloads)\u003c/li\u003e\n\u003cli\u003eKey-value lookups at massive scale\u003c/li\u003e\n\u003cli\u003eEvent sourcing and time-series data\u003c/li\u003e\n\u003cli\u003eServerless architectures (pay-per-request, zero management)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDynamoDB is the wrong choice for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAd-hoc analytics (use Athena on S3 exports or Redshift)\u003c/li\u003e\n\u003cli\u003eComplex queries with multiple filter conditions on non-indexed attributes\u003c/li\u003e\n\u003cli\u003eFlexible schema requirements that change frequently (schema changes in single-table design are painful)\u003c/li\u003e\n\u003cli\u003eTeams without DynamoDB expertise (the learning curve is steep and mistakes are expensive)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe difference between DynamoDB experts and beginners: experts define all access patterns on a whiteboard before writing any code. Every GSI, every overloaded attribute, every entity prefix is a deliberate decision made against a list of queries the application must support. The schema follows the queries â€” not the other way around.\u003c/p\u003e\n","tableOfContents":[{"id":"dynamodbs-data-model","text":"DynamoDB's Data Model","level":2},{"id":"single-table-design-the-core-principle","text":"Single-Table Design: The Core Principle","level":2},{"id":"global-secondary-indexes-overloading-and-sparse-indexes","text":"Global Secondary Indexes: Overloading and Sparse Indexes","level":2},{"id":"adjacency-list-pattern-graph-relationships","text":"Adjacency List Pattern: Graph Relationships","level":2},{"id":"dynamodb-streams-and-event-driven-patterns","text":"DynamoDB Streams and Event-Driven Patterns","level":2},{"id":"transactions-acid-across-multiple-items","text":"Transactions: ACID Across Multiple Items","level":2},{"id":"capacity-planning-avoiding-bill-shock","text":"Capacity Planning: Avoiding Bill Shock","level":2},{"id":"ttl-automatic-data-expiration","text":"TTL: Automatic Data Expiration","level":2},{"id":"when-dynamodb-is-wrong","text":"When DynamoDB Is Wrong","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring â€” every node is equal, there's no primary, and data placement is determined by partitâ€¦"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible â€” rollback a bad deploy and your code is back to the previous version. Database schema changes are stâ€¦"},{"title":"PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads","description":"A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.","date":"2025-06-03","category":"Databases","tags":["postgresql","databases","performance","sql","indexing","query optimization"],"featured":false,"affiliateSection":"database-resources","slug":"postgresql-performance-tuning","readingTime":"9 min read","excerpt":"PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem â€” they're a query design problem that Postâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"dynamodb-advanced-patterns"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>