<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes<!-- --> | CodeSprintPro</title><meta name="description" content="Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/java-gc-tuning/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes" data-next-head=""/><meta property="og:description" content="Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/java-gc-tuning/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-02-22" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="gc" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta property="article:tag" content="jvm" data-next-head=""/><meta property="article:tag" content="g1gc" data-next-head=""/><meta property="article:tag" content="zgc" data-next-head=""/><meta property="article:tag" content="tuning" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes" data-next-head=""/><meta name="twitter:description" content="Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes","description":"Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-02-22","dateModified":"2025-02-22","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/java-gc-tuning/"},"keywords":"java, gc, performance, jvm, g1gc, zgc, tuning","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>February 22, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>10 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->gc</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->jvm</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->g1gc</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->zgc</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->tuning</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Garbage collection pauses are the invisible killer of Java application latency. A service with p99 latency of 20ms can suddenly spike to 500ms because GC paused all threads for a full collection. Understanding GC internals â€” not just tuning flags â€” is what separates engineers who eliminate GC pauses from those who keep adding heap and hoping.</p>
<h2>The Generational Hypothesis</h2>
<p>All production JVM GCs exploit the <strong>generational hypothesis</strong>: most objects die young. A freshly allocated <code>HttpRequest</code> object, a <code>StringBuilder</code> built for one response, a DTO for one API call â€” these live for milliseconds. To see why this insight is so powerful, consider the typical shape of object lifetimes in a real Java web service:</p>
<pre><code>Object lifetime distribution (typical Java web service):

 Count
   â”‚
   â–ˆ
   â–ˆ â–ˆ
   â–ˆ â–ˆ â–ˆ
   â–ˆ â–ˆ â–ˆ â–ˆ                    Â·
   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ                Â· Â· Â·
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Age
   &#x3C;1ms           &#x3C;1s            Long-lived

99% of objects die in the first few milliseconds.
~1% survive to become long-lived (caches, thread pools, connection pools).
</code></pre>
<p>The steep drop-off in that chart is what makes generational collection efficient: the JVM can reclaim the vast majority of memory by scanning only the small, recently-allocated portion of the heap. This is why JVMs divide the heap into generations:</p>
<ul>
<li><strong>Young Generation (Eden + Survivor spaces)</strong>: New objects allocated here. Minor GC runs frequently (~seconds) and is fast (~10ms)</li>
<li><strong>Old Generation (Tenured)</strong>: Objects that survive enough minor GCs are promoted here. Major/Full GC runs rarely but can pause for seconds</li>
</ul>
<h2>G1GC: The Default Since Java 9</h2>
<p>G1 (Garbage First) divides the heap into equal-sized regions (~2MB each) rather than fixed young/old spaces. It predicts which regions have the most garbage and collects those first â€” hence "Garbage First." The diagram below shows how regions are dynamically assigned roles, which lets G1 balance collection work without requiring you to manually size each generation:</p>
<pre><code>G1 Heap Layout:
  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
  â”‚ E â”‚ E â”‚ S â”‚ S â”‚ O â”‚ O â”‚ O â”‚ H â”‚  E=Eden, S=Survivor
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤  O=Old, H=Humongous
  â”‚ E â”‚ O â”‚ O â”‚ E â”‚ O â”‚ S â”‚ H â”‚ E â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
  â”‚ O â”‚ O â”‚ E â”‚ E â”‚ O â”‚ O â”‚ O â”‚ O â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

G1 collects whichever regions have highest garbage ratio first.
Regions dynamically reassigned as young/old based on need.
</code></pre>
<h3>Key G1 JVM Flags</h3>
<p>The following flags give you a solid starting configuration for G1 on a production service. The most important one to understand is <code>MaxGCPauseMillis</code> â€” it is a <em>soft target</em>, meaning G1 uses it as a goal when deciding how much work to do per cycle, but it cannot always guarantee it will be met under extreme heap pressure:</p>
<pre><code class="language-bash"># Target: pause &#x3C; 200ms, heap = 8GB
-XX:+UseG1GC                          # Default since Java 9 â€” usually don't need to specify
-Xms8g -Xmx8g                         # Set min = max to avoid resize pauses
-XX:MaxGCPauseMillis=200              # G1 soft target (not guaranteed)
-XX:G1HeapRegionSize=16m              # Larger regions for large heaps (up to 32MB)
-XX:G1NewSizePercent=20               # Min young gen = 20% of heap
-XX:G1MaxNewSizePercent=40            # Max young gen = 40% of heap
-XX:G1MixedGCCountTarget=8           # Number of mixed GC cycles
-XX:G1HeapWastePercent=5             # Don't collect if less than 5% is reclaimable
-XX:InitiatingHeapOccupancyPercent=45 # Start concurrent marking at 45% heap usage
-XX:+G1UseAdaptiveIHOP               # Adaptive IHOP (Java 9+)
</code></pre>
<h3>Reading GC Logs</h3>
<p>Flags alone won't help you if you can't observe what GC is actually doing. Always enable GC logging in production â€” the overhead is negligible and the diagnostic value is enormous:</p>
<pre><code class="language-bash">-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m
</code></pre>
<p>Sample output:</p>
<pre><code>[2025-02-20T10:15:32.045+0000][2.345s][info][gc] GC(42) Pause Young (Normal) (G1 Evacuation Pause) 2048M->512M(8192M) 45.234ms
[2025-02-20T10:15:35.891+0000][5.191s][info][gc] GC(43) Pause Young (Normal) (G1 Evacuation Pause) 1536M->400M(8192M) 38.102ms
[2025-02-20T10:15:50.123+0000][19.423s][warning][gc] GC(44) To-space exhausted
[2025-02-20T10:15:50.234+0000][19.534s][info][gc] GC(44) Pause Full (G1 Compaction Pause) 7800M->2100M(8192M) 4523.891ms
</code></pre>
<p>The <code>4523.891ms</code> Full GC in the last line is a 4.5-second stop-the-world pause â€” the kind of spike that will blow through any reasonable latency SLA. Learning to recognize the warning signs before that happens is the key skill.</p>
<p><strong>Red flags in GC logs:</strong></p>
<ul>
<li><code>To-space exhausted</code> â†’ Survivor spaces too small, objects forced to Old Gen prematurely</li>
<li><code>Pause Full</code> â†’ Full GC triggered â€” expensive, caused by heap exhaustion or humongous object allocation failure</li>
<li><code>Evacuation Failure</code> â†’ GC couldn't evacuate young gen â†’ heap pressure</li>
<li>Pause time consistently > <code>MaxGCPauseMillis</code> target â†’ Heap too small or mixed GC tuning needed</li>
</ul>
<h3>Common G1 Issues and Fixes</h3>
<p>Once you know how to read the logs, the next step is mapping the symptoms you see to the right corrective action. Each of the three scenarios below has a distinct cause and a specific set of flags or code changes that address it:</p>
<pre><code>Issue: Humongous Object Allocation
  Objects > 50% of region size (>8MB for 16MB regions) are allocated directly in Old Gen.
  If short-lived, they skip Young Gen and pollute Old Gen.

Fix:
  1. Increase G1HeapRegionSize to make more objects "normal" size
  2. Identify culprits: -XX:+G1PrintRegionRememberedSetInfo (Java 11+)
  3. Refactor: stream large byte arrays instead of materializing them

Issue: Old Gen fills up â†’ Full GC
  Mixed GC isn't reclaiming Old Gen fast enough.

Fix:
  -XX:G1MixedGCCountTarget=4          # More frequent mixed GC
  -XX:G1HeapWastePercent=1            # Collect more aggressively
  -XX:InitiatingHeapOccupancyPercent=35 # Start concurrent marking earlier

Issue: Long Young GC pauses
  Too many live objects in Young Gen â†’ evacuation takes long.

Fix:
  -XX:G1NewSizePercent=10             # Smaller young gen = faster minor GC
  -XX:MaxTenuringThreshold=3          # Promote to Old Gen sooner
</code></pre>
<h2>ZGC: Sub-Millisecond Pauses (Java 15+)</h2>
<p>If G1 tuning still leaves you with pauses that violate your latency requirements, ZGC offers a fundamentally different trade-off. ZGC is a concurrent collector â€” it does almost all work while application threads run. Stop-the-world pauses are limited to root scanning and reference processing, typically <strong>&#x3C; 1ms</strong> even on 100GB+ heaps. The trade-off is that it requires more heap headroom and uses more CPU for its background collection work. Here is a recommended baseline configuration:</p>
<pre><code class="language-bash"># ZGC configuration
-XX:+UseZGC                     # Enable ZGC
-Xms16g -Xmx16g                 # ZGC needs generous heap headroom (~2-3x live set)
-XX:SoftMaxHeapSize=14g         # Soft limit: ZGC starts collecting harder above this
-XX:ZCollectionInterval=0       # 0 = adaptive (recommended)
-XX:ConcGCThreads=4             # Concurrent GC threads (increase for large heaps)
-XX:+ZGenerational              # Java 21+: Generational ZGC (much better throughput)
</code></pre>
<p>The <code>ZGenerational</code> flag (Java 21+) is particularly important: it adds generational awareness to ZGC, dramatically improving throughput without sacrificing the sub-millisecond pause times that make ZGC appealing in the first place.</p>
<p><strong>ZGC tradeoffs:</strong></p>
<ul>
<li>Pause times: &#x3C; 1ms âœ“</li>
<li>Throughput: 5-10% lower than G1 (concurrent work has CPU cost)</li>
<li>Memory overhead: Higher (needs extra heap headroom ~2x)</li>
<li>Best for: Latency-sensitive services (trading, real-time APIs) with large heaps</li>
</ul>
<h3>G1 vs ZGC vs Shenandoah</h3>
<p>Choosing between collectors comes down to understanding your own latency requirements and heap size. Use this table as a quick reference when deciding which collector is appropriate for a given service:</p>
<table>
<thead>
<tr>
<th></th>
<th>G1GC</th>
<th>ZGC (Java 21 Gen)</th>
<th>Shenandoah</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pause time</td>
<td>50-500ms</td>
<td>&#x3C; 1ms</td>
<td>&#x3C; 10ms</td>
</tr>
<tr>
<td>Throughput</td>
<td>Excellent</td>
<td>Good (-5%)</td>
<td>Good (-5%)</td>
</tr>
<tr>
<td>Heap size</td>
<td>Any</td>
<td>Large (> 4GB benefits most)</td>
<td>Any</td>
</tr>
<tr>
<td>Memory overhead</td>
<td>Low</td>
<td>High (2x)</td>
<td>Medium</td>
</tr>
<tr>
<td>Java version</td>
<td>9+</td>
<td>11+, Gen in 21+</td>
<td>12+</td>
</tr>
<tr>
<td>Best for</td>
<td>Default choice</td>
<td>Latency-critical</td>
<td>Latency-sensitive</td>
</tr>
</tbody>
</table>
<h2>Diagnosing GC Problems in Production</h2>
<p>Knowing which collector to use is only half the battle. When a GC problem surfaces in production, you need a repeatable diagnostic process to find the root cause without guessing. Follow these steps in order â€” measuring first prevents you from applying the wrong fix.</p>
<h3>Step 1: Measure before tuning</h3>
<p>Start by quantifying how much of your CPU time is consumed by GC and which areas of the heap are under pressure. This gives you a baseline to compare against after any change you make:</p>
<pre><code class="language-bash"># GC overhead: what % of CPU time is GC?
# Rule of thumb: > 5% GC CPU â†’ GC is a problem
jstat -gcutil &#x3C;pid> 1000 10
# Output: S0  S1  E   O   M   CCS  YGC  YGCT  FGC  FGCT  CGC  CGCT  GCT
#           0  50  80  45  95   90   42  0.845    0     0    3   0.234  1.079
# YGC=42 young GCs in measurement period, YGCT=total young GC time

# Heap histogram: what's consuming heap?
jmap -histo:live &#x3C;pid> | head -30
# Lists: #instances, bytes, class name
# Look for: unexpected retention of Request/Response objects, large byte arrays
</code></pre>
<h3>Step 2: Heap dump analysis</h3>
<p>If <code>jstat</code> shows high Old Gen occupancy or frequent Full GCs, the next step is a heap dump. A heap dump lets you see exactly which objects are being retained and why â€” this is how you find memory leaks:</p>
<pre><code class="language-bash"># Trigger heap dump (OOM or manual)
jmap -dump:format=b,file=/tmp/heap.hprof &#x3C;pid>

# Or configure JVM to dump on OOM
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/app/

# Analyze with Eclipse MAT or VisualVM
# Look for: Retained Heap (memory freed if object is GC'd)
# Find: Objects with large retained heap that shouldn't be alive
</code></pre>
<h3>Step 3: Allocation profiling</h3>
<p>When your object lifetime distribution is healthy but GC is still frequent, the problem is usually allocation rate â€” your application is creating objects faster than GC can collect them. Allocation profiling pinpoints exactly which code paths are responsible:</p>
<pre><code class="language-bash"># Async-profiler: low-overhead allocation profiling
./profiler.sh -e alloc -d 30 -f alloc.html &#x3C;pid>

# Or JVM built-in (Java Flight Recorder)
java -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,settings=profile,filename=recording.jfr \
     -jar app.jar
</code></pre>
<h2>Production Tuning Checklist</h2>
<p>With all three diagnostic steps complete, you are ready to apply targeted configuration changes. The flags below represent a battle-tested starting point for a Java 21 web service, with comments explaining the intent behind each choice. Apply them incrementally and re-measure after each change so you can attribute improvements to specific flags:</p>
<pre><code class="language-bash"># Base flags for any Java web service (Java 21)
-Xms4g -Xmx4g                              # Set min=max (avoid resize pauses)
-XX:+UseG1GC                               # Default, good starting point
-XX:MaxGCPauseMillis=200                   # Define your SLA
-XX:InitiatingHeapOccupancyPercent=35      # Earlier concurrent marking
-XX:+G1UseAdaptiveIHOP                     # Let JVM tune IHOP

# GC Logging (always on in production)
-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m

# OOM handling
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/app/heapdump.hprof
-XX:+ExitOnOutOfMemoryError                # Crash fast rather than limp

# For latency-sensitive services (Java 21)
-XX:+UseZGC -XX:+ZGenerational            # Switch to ZGC
-Xms16g -Xmx16g                           # Give ZGC headroom

# Avoid:
# -Xmn (manually setting young gen size) â€” let G1 manage it
# -XX:+UseConcMarkSweepGC â€” deprecated, removed in Java 14
# -XX:+UseSerialGC â€” only for single-CPU containers
</code></pre>
<p>The golden rule of GC tuning: <strong>measure first, tune second</strong>. Most GC problems are solved by either sizing the heap appropriately or identifying a memory leak. Only after ruling those out should you reach for GC flags.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass â€” Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Java%20GC%20Tuning%3A%20From%20G1%20to%20ZGC%20%E2%80%94%20Eliminating%20Pause-Time%20Spikes&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-gc-tuning%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-gc-tuning%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-generational-hypothesis" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Generational Hypothesis</a></li><li class=""><a href="#g1gc-the-default-since-java-9" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">G1GC: The Default Since Java 9</a></li><li class="ml-4"><a href="#key-g1-jvm-flags" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Key G1 JVM Flags</a></li><li class="ml-4"><a href="#reading-gc-logs" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Reading GC Logs</a></li><li class="ml-4"><a href="#common-g1-issues-and-fixes" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Common G1 Issues and Fixes</a></li><li class=""><a href="#zgc-sub-millisecond-pauses-java-15" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">ZGC: Sub-Millisecond Pauses (Java 15+)</a></li><li class="ml-4"><a href="#g1-vs-zgc-vs-shenandoah" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">G1 vs ZGC vs Shenandoah</a></li><li class=""><a href="#diagnosing-gc-problems-in-production" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Diagnosing GC Problems in Production</a></li><li class="ml-4"><a href="#step-1-measure-before-tuning" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Step 1: Measure before tuning</a></li><li class="ml-4"><a href="#step-2-heap-dump-analysis" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Step 2: Heap dump analysis</a></li><li class="ml-4"><a href="#step-3-allocation-profiling" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Step 3: Allocation profiling</a></li><li class=""><a href="#production-tuning-checklist" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Production Tuning Checklist</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-concurrency-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era&#x27;s patterns still exist in production codebases. Understanding all thâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->concurrency</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->completablefuture</span></div></article></a><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durinâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength â€” and its complexity. Misconfigured security is worse than no security, because it giveâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java GC Tuning: From G1 to ZGC â€” Eliminating Pause-Time Spikes","description":"Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes.","date":"2025-02-22","category":"Java","tags":["java","gc","performance","jvm","g1gc","zgc","tuning"],"featured":false,"affiliateSection":"java-courses","slug":"java-gc-tuning","readingTime":"10 min read","excerpt":"Garbage collection pauses are the invisible killer of Java application latency. A service with p99 latency of 20ms can suddenly spike to 500ms because GC paused all threads for a full collection. Understanding GC internaâ€¦","contentHtml":"\u003cp\u003eGarbage collection pauses are the invisible killer of Java application latency. A service with p99 latency of 20ms can suddenly spike to 500ms because GC paused all threads for a full collection. Understanding GC internals â€” not just tuning flags â€” is what separates engineers who eliminate GC pauses from those who keep adding heap and hoping.\u003c/p\u003e\n\u003ch2\u003eThe Generational Hypothesis\u003c/h2\u003e\n\u003cp\u003eAll production JVM GCs exploit the \u003cstrong\u003egenerational hypothesis\u003c/strong\u003e: most objects die young. A freshly allocated \u003ccode\u003eHttpRequest\u003c/code\u003e object, a \u003ccode\u003eStringBuilder\u003c/code\u003e built for one response, a DTO for one API call â€” these live for milliseconds. To see why this insight is so powerful, consider the typical shape of object lifetimes in a real Java web service:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eObject lifetime distribution (typical Java web service):\n\n Count\n   â”‚\n   â–ˆ\n   â–ˆ â–ˆ\n   â–ˆ â–ˆ â–ˆ\n   â–ˆ â–ˆ â–ˆ â–ˆ                    Â·\n   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ                Â· Â· Â·\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Age\n   \u0026#x3C;1ms           \u0026#x3C;1s            Long-lived\n\n99% of objects die in the first few milliseconds.\n~1% survive to become long-lived (caches, thread pools, connection pools).\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe steep drop-off in that chart is what makes generational collection efficient: the JVM can reclaim the vast majority of memory by scanning only the small, recently-allocated portion of the heap. This is why JVMs divide the heap into generations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYoung Generation (Eden + Survivor spaces)\u003c/strong\u003e: New objects allocated here. Minor GC runs frequently (~seconds) and is fast (~10ms)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOld Generation (Tenured)\u003c/strong\u003e: Objects that survive enough minor GCs are promoted here. Major/Full GC runs rarely but can pause for seconds\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eG1GC: The Default Since Java 9\u003c/h2\u003e\n\u003cp\u003eG1 (Garbage First) divides the heap into equal-sized regions (~2MB each) rather than fixed young/old spaces. It predicts which regions have the most garbage and collects those first â€” hence \"Garbage First.\" The diagram below shows how regions are dynamically assigned roles, which lets G1 balance collection work without requiring you to manually size each generation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eG1 Heap Layout:\n  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\n  â”‚ E â”‚ E â”‚ S â”‚ S â”‚ O â”‚ O â”‚ O â”‚ H â”‚  E=Eden, S=Survivor\n  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤  O=Old, H=Humongous\n  â”‚ E â”‚ O â”‚ O â”‚ E â”‚ O â”‚ S â”‚ H â”‚ E â”‚\n  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\n  â”‚ O â”‚ O â”‚ E â”‚ E â”‚ O â”‚ O â”‚ O â”‚ O â”‚\n  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n\nG1 collects whichever regions have highest garbage ratio first.\nRegions dynamically reassigned as young/old based on need.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eKey G1 JVM Flags\u003c/h3\u003e\n\u003cp\u003eThe following flags give you a solid starting configuration for G1 on a production service. The most important one to understand is \u003ccode\u003eMaxGCPauseMillis\u003c/code\u003e â€” it is a \u003cem\u003esoft target\u003c/em\u003e, meaning G1 uses it as a goal when deciding how much work to do per cycle, but it cannot always guarantee it will be met under extreme heap pressure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Target: pause \u0026#x3C; 200ms, heap = 8GB\n-XX:+UseG1GC                          # Default since Java 9 â€” usually don't need to specify\n-Xms8g -Xmx8g                         # Set min = max to avoid resize pauses\n-XX:MaxGCPauseMillis=200              # G1 soft target (not guaranteed)\n-XX:G1HeapRegionSize=16m              # Larger regions for large heaps (up to 32MB)\n-XX:G1NewSizePercent=20               # Min young gen = 20% of heap\n-XX:G1MaxNewSizePercent=40            # Max young gen = 40% of heap\n-XX:G1MixedGCCountTarget=8           # Number of mixed GC cycles\n-XX:G1HeapWastePercent=5             # Don't collect if less than 5% is reclaimable\n-XX:InitiatingHeapOccupancyPercent=45 # Start concurrent marking at 45% heap usage\n-XX:+G1UseAdaptiveIHOP               # Adaptive IHOP (Java 9+)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eReading GC Logs\u003c/h3\u003e\n\u003cp\u003eFlags alone won't help you if you can't observe what GC is actually doing. Always enable GC logging in production â€” the overhead is negligible and the diagnostic value is enormous:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSample output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[2025-02-20T10:15:32.045+0000][2.345s][info][gc] GC(42) Pause Young (Normal) (G1 Evacuation Pause) 2048M-\u003e512M(8192M) 45.234ms\n[2025-02-20T10:15:35.891+0000][5.191s][info][gc] GC(43) Pause Young (Normal) (G1 Evacuation Pause) 1536M-\u003e400M(8192M) 38.102ms\n[2025-02-20T10:15:50.123+0000][19.423s][warning][gc] GC(44) To-space exhausted\n[2025-02-20T10:15:50.234+0000][19.534s][info][gc] GC(44) Pause Full (G1 Compaction Pause) 7800M-\u003e2100M(8192M) 4523.891ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e4523.891ms\u003c/code\u003e Full GC in the last line is a 4.5-second stop-the-world pause â€” the kind of spike that will blow through any reasonable latency SLA. Learning to recognize the warning signs before that happens is the key skill.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRed flags in GC logs:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTo-space exhausted\u003c/code\u003e â†’ Survivor spaces too small, objects forced to Old Gen prematurely\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePause Full\u003c/code\u003e â†’ Full GC triggered â€” expensive, caused by heap exhaustion or humongous object allocation failure\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEvacuation Failure\u003c/code\u003e â†’ GC couldn't evacuate young gen â†’ heap pressure\u003c/li\u003e\n\u003cli\u003ePause time consistently \u003e \u003ccode\u003eMaxGCPauseMillis\u003c/code\u003e target â†’ Heap too small or mixed GC tuning needed\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCommon G1 Issues and Fixes\u003c/h3\u003e\n\u003cp\u003eOnce you know how to read the logs, the next step is mapping the symptoms you see to the right corrective action. Each of the three scenarios below has a distinct cause and a specific set of flags or code changes that address it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eIssue: Humongous Object Allocation\n  Objects \u003e 50% of region size (\u003e8MB for 16MB regions) are allocated directly in Old Gen.\n  If short-lived, they skip Young Gen and pollute Old Gen.\n\nFix:\n  1. Increase G1HeapRegionSize to make more objects \"normal\" size\n  2. Identify culprits: -XX:+G1PrintRegionRememberedSetInfo (Java 11+)\n  3. Refactor: stream large byte arrays instead of materializing them\n\nIssue: Old Gen fills up â†’ Full GC\n  Mixed GC isn't reclaiming Old Gen fast enough.\n\nFix:\n  -XX:G1MixedGCCountTarget=4          # More frequent mixed GC\n  -XX:G1HeapWastePercent=1            # Collect more aggressively\n  -XX:InitiatingHeapOccupancyPercent=35 # Start concurrent marking earlier\n\nIssue: Long Young GC pauses\n  Too many live objects in Young Gen â†’ evacuation takes long.\n\nFix:\n  -XX:G1NewSizePercent=10             # Smaller young gen = faster minor GC\n  -XX:MaxTenuringThreshold=3          # Promote to Old Gen sooner\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eZGC: Sub-Millisecond Pauses (Java 15+)\u003c/h2\u003e\n\u003cp\u003eIf G1 tuning still leaves you with pauses that violate your latency requirements, ZGC offers a fundamentally different trade-off. ZGC is a concurrent collector â€” it does almost all work while application threads run. Stop-the-world pauses are limited to root scanning and reference processing, typically \u003cstrong\u003e\u0026#x3C; 1ms\u003c/strong\u003e even on 100GB+ heaps. The trade-off is that it requires more heap headroom and uses more CPU for its background collection work. Here is a recommended baseline configuration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# ZGC configuration\n-XX:+UseZGC                     # Enable ZGC\n-Xms16g -Xmx16g                 # ZGC needs generous heap headroom (~2-3x live set)\n-XX:SoftMaxHeapSize=14g         # Soft limit: ZGC starts collecting harder above this\n-XX:ZCollectionInterval=0       # 0 = adaptive (recommended)\n-XX:ConcGCThreads=4             # Concurrent GC threads (increase for large heaps)\n-XX:+ZGenerational              # Java 21+: Generational ZGC (much better throughput)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eZGenerational\u003c/code\u003e flag (Java 21+) is particularly important: it adds generational awareness to ZGC, dramatically improving throughput without sacrificing the sub-millisecond pause times that make ZGC appealing in the first place.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eZGC tradeoffs:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePause times: \u0026#x3C; 1ms âœ“\u003c/li\u003e\n\u003cli\u003eThroughput: 5-10% lower than G1 (concurrent work has CPU cost)\u003c/li\u003e\n\u003cli\u003eMemory overhead: Higher (needs extra heap headroom ~2x)\u003c/li\u003e\n\u003cli\u003eBest for: Latency-sensitive services (trading, real-time APIs) with large heaps\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eG1 vs ZGC vs Shenandoah\u003c/h3\u003e\n\u003cp\u003eChoosing between collectors comes down to understanding your own latency requirements and heap size. Use this table as a quick reference when deciding which collector is appropriate for a given service:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eG1GC\u003c/th\u003e\n\u003cth\u003eZGC (Java 21 Gen)\u003c/th\u003e\n\u003cth\u003eShenandoah\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003ePause time\u003c/td\u003e\n\u003ctd\u003e50-500ms\u003c/td\u003e\n\u003ctd\u003e\u0026#x3C; 1ms\u003c/td\u003e\n\u003ctd\u003e\u0026#x3C; 10ms\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eThroughput\u003c/td\u003e\n\u003ctd\u003eExcellent\u003c/td\u003e\n\u003ctd\u003eGood (-5%)\u003c/td\u003e\n\u003ctd\u003eGood (-5%)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eHeap size\u003c/td\u003e\n\u003ctd\u003eAny\u003c/td\u003e\n\u003ctd\u003eLarge (\u003e 4GB benefits most)\u003c/td\u003e\n\u003ctd\u003eAny\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMemory overhead\u003c/td\u003e\n\u003ctd\u003eLow\u003c/td\u003e\n\u003ctd\u003eHigh (2x)\u003c/td\u003e\n\u003ctd\u003eMedium\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eJava version\u003c/td\u003e\n\u003ctd\u003e9+\u003c/td\u003e\n\u003ctd\u003e11+, Gen in 21+\u003c/td\u003e\n\u003ctd\u003e12+\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBest for\u003c/td\u003e\n\u003ctd\u003eDefault choice\u003c/td\u003e\n\u003ctd\u003eLatency-critical\u003c/td\u003e\n\u003ctd\u003eLatency-sensitive\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003eDiagnosing GC Problems in Production\u003c/h2\u003e\n\u003cp\u003eKnowing which collector to use is only half the battle. When a GC problem surfaces in production, you need a repeatable diagnostic process to find the root cause without guessing. Follow these steps in order â€” measuring first prevents you from applying the wrong fix.\u003c/p\u003e\n\u003ch3\u003eStep 1: Measure before tuning\u003c/h3\u003e\n\u003cp\u003eStart by quantifying how much of your CPU time is consumed by GC and which areas of the heap are under pressure. This gives you a baseline to compare against after any change you make:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# GC overhead: what % of CPU time is GC?\n# Rule of thumb: \u003e 5% GC CPU â†’ GC is a problem\njstat -gcutil \u0026#x3C;pid\u003e 1000 10\n# Output: S0  S1  E   O   M   CCS  YGC  YGCT  FGC  FGCT  CGC  CGCT  GCT\n#           0  50  80  45  95   90   42  0.845    0     0    3   0.234  1.079\n# YGC=42 young GCs in measurement period, YGCT=total young GC time\n\n# Heap histogram: what's consuming heap?\njmap -histo:live \u0026#x3C;pid\u003e | head -30\n# Lists: #instances, bytes, class name\n# Look for: unexpected retention of Request/Response objects, large byte arrays\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eStep 2: Heap dump analysis\u003c/h3\u003e\n\u003cp\u003eIf \u003ccode\u003ejstat\u003c/code\u003e shows high Old Gen occupancy or frequent Full GCs, the next step is a heap dump. A heap dump lets you see exactly which objects are being retained and why â€” this is how you find memory leaks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Trigger heap dump (OOM or manual)\njmap -dump:format=b,file=/tmp/heap.hprof \u0026#x3C;pid\u003e\n\n# Or configure JVM to dump on OOM\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/var/log/app/\n\n# Analyze with Eclipse MAT or VisualVM\n# Look for: Retained Heap (memory freed if object is GC'd)\n# Find: Objects with large retained heap that shouldn't be alive\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eStep 3: Allocation profiling\u003c/h3\u003e\n\u003cp\u003eWhen your object lifetime distribution is healthy but GC is still frequent, the problem is usually allocation rate â€” your application is creating objects faster than GC can collect them. Allocation profiling pinpoints exactly which code paths are responsible:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Async-profiler: low-overhead allocation profiling\n./profiler.sh -e alloc -d 30 -f alloc.html \u0026#x3C;pid\u003e\n\n# Or JVM built-in (Java Flight Recorder)\njava -XX:+FlightRecorder \\\n     -XX:StartFlightRecording=duration=60s,settings=profile,filename=recording.jfr \\\n     -jar app.jar\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eProduction Tuning Checklist\u003c/h2\u003e\n\u003cp\u003eWith all three diagnostic steps complete, you are ready to apply targeted configuration changes. The flags below represent a battle-tested starting point for a Java 21 web service, with comments explaining the intent behind each choice. Apply them incrementally and re-measure after each change so you can attribute improvements to specific flags:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Base flags for any Java web service (Java 21)\n-Xms4g -Xmx4g                              # Set min=max (avoid resize pauses)\n-XX:+UseG1GC                               # Default, good starting point\n-XX:MaxGCPauseMillis=200                   # Define your SLA\n-XX:InitiatingHeapOccupancyPercent=35      # Earlier concurrent marking\n-XX:+G1UseAdaptiveIHOP                     # Let JVM tune IHOP\n\n# GC Logging (always on in production)\n-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m\n\n# OOM handling\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/var/log/app/heapdump.hprof\n-XX:+ExitOnOutOfMemoryError                # Crash fast rather than limp\n\n# For latency-sensitive services (Java 21)\n-XX:+UseZGC -XX:+ZGenerational            # Switch to ZGC\n-Xms16g -Xmx16g                           # Give ZGC headroom\n\n# Avoid:\n# -Xmn (manually setting young gen size) â€” let G1 manage it\n# -XX:+UseConcMarkSweepGC â€” deprecated, removed in Java 14\n# -XX:+UseSerialGC â€” only for single-CPU containers\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe golden rule of GC tuning: \u003cstrong\u003emeasure first, tune second\u003c/strong\u003e. Most GC problems are solved by either sizing the heap appropriately or identifying a memory leak. Only after ruling those out should you reach for GC flags.\u003c/p\u003e\n","tableOfContents":[{"id":"the-generational-hypothesis","text":"The Generational Hypothesis","level":2},{"id":"g1gc-the-default-since-java-9","text":"G1GC: The Default Since Java 9","level":2},{"id":"key-g1-jvm-flags","text":"Key G1 JVM Flags","level":3},{"id":"reading-gc-logs","text":"Reading GC Logs","level":3},{"id":"common-g1-issues-and-fixes","text":"Common G1 Issues and Fixes","level":3},{"id":"zgc-sub-millisecond-pauses-java-15","text":"ZGC: Sub-Millisecond Pauses (Java 15+)","level":2},{"id":"g1-vs-zgc-vs-shenandoah","text":"G1 vs ZGC vs Shenandoah","level":3},{"id":"diagnosing-gc-problems-in-production","text":"Diagnosing GC Problems in Production","level":2},{"id":"step-1-measure-before-tuning","text":"Step 1: Measure before tuning","level":3},{"id":"step-2-heap-dump-analysis","text":"Step 2: Heap dump analysis","level":3},{"id":"step-3-allocation-profiling","text":"Step 3: Allocation profiling","level":3},{"id":"production-tuning-checklist","text":"Production Tuning Checklist","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all thâ€¦"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durinâ€¦"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength â€” and its complexity. Misconfigured security is worse than no security, because it giveâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-gc-tuning"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>