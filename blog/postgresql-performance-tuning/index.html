<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads<!-- --> | CodeSprintPro</title><meta name="description" content="A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/postgresql-performance-tuning/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads" data-next-head=""/><meta property="og:description" content="A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/postgresql-performance-tuning/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-06-03" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="postgresql" data-next-head=""/><meta property="article:tag" content="databases" data-next-head=""/><meta property="article:tag" content="performance" data-next-head=""/><meta property="article:tag" content="sql" data-next-head=""/><meta property="article:tag" content="indexing" data-next-head=""/><meta property="article:tag" content="query optimization" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads" data-next-head=""/><meta name="twitter:description" content="A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads","description":"A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-06-03","dateModified":"2025-06-03","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/postgresql-performance-tuning/"},"keywords":"postgresql, databases, performance, sql, indexing, query optimization","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>June 3, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->postgresql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->databases</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->performance</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->sql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->indexing</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->query optimization</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they're a query design problem that PostgreSQL surfaces. This article covers both: the query patterns that create avoidable load, and the server configuration that extracts maximum performance from your hardware.</p>
<h2>Reading EXPLAIN ANALYZE Like a Senior DBA</h2>
<p>Every performance investigation starts here:</p>
<pre><code class="language-sql">EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT u.id, u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
WHERE u.status = 'active'
  AND u.created_at > '2024-01-01'
GROUP BY u.id, u.name
ORDER BY order_count DESC
LIMIT 100;
</code></pre>
<p>Key output fields to read:</p>
<pre><code>Hash Left Join  (cost=12500.00..89432.00 rows=100 width=40)
                (actual time=1823.421..4231.005 rows=100 loops=1)
  Buffers: shared hit=2841 read=31823
  ->  Seq Scan on users  (cost=0.00..42000.00 rows=500000 width=32)
                         (actual time=0.023..1203.000 rows=500000 loops=1)
        Filter: ((status = 'active') AND (created_at > '2024-01-01'))
        Rows Removed by Filter: 250000
  ->  Hash  (cost=8000.00..8000.00 rows=2000000 width=16) (...)
        Buckets: 131072  Batches: 16  Memory Usage: 4096kB
</code></pre>
<p><strong>What to look for:</strong></p>
<ul>
<li><code>Seq Scan</code> on large tables: missing index</li>
<li><code>actual time</code> much higher than <code>cost</code>: stale statistics ‚Äî run <code>ANALYZE</code></li>
<li><code>Buffers: read=31823</code>: reading 31K pages from disk (cache miss) ‚Äî memory too small or missing index</li>
<li><code>Rows Removed by Filter: 250000</code>: filter applied post-scan ‚Äî index on filter column needed</li>
<li><code>Batches: 16</code> on Hash: hash join spilled to disk ‚Äî increase <code>work_mem</code></li>
</ul>
<h2>Index Design That Actually Helps</h2>
<h3>Composite Indexes: Column Order Matters</h3>
<pre><code class="language-sql">-- Query:
SELECT * FROM orders
WHERE user_id = 123 AND status = 'pending' AND created_at > NOW() - INTERVAL '7 days';

-- WRONG: index can only use leftmost prefix
CREATE INDEX idx_orders_status_user ON orders (status, user_id);
-- Query has high-cardinality filter (user_id) after low-cardinality (status) ‚Äî bad

-- RIGHT: highest cardinality first, then equality, then range
CREATE INDEX idx_orders_user_status_created ON orders (user_id, status, created_at DESC);
-- user_id equality ‚Üí status equality ‚Üí created_at range: all 3 columns used
</code></pre>
<p><strong>Rule:</strong> Equality columns before range columns. High-cardinality before low-cardinality within equality columns.</p>
<h3>Partial Indexes for Selective Queries</h3>
<pre><code class="language-sql">-- Only index active users (90% of queries)
CREATE INDEX idx_users_active_created
ON users (created_at DESC)
WHERE status = 'active';

-- Only index unprocessed orders
CREATE INDEX idx_orders_pending
ON orders (created_at, user_id)
WHERE status = 'pending';
-- If 5% of orders are pending, this index is 20√ó smaller ‚Äî faster scans, better cache utilization
</code></pre>
<h3>Index-Only Scans with INCLUDE</h3>
<pre><code class="language-sql">-- Query needs id + email + name, but WHERE is on email
CREATE INDEX idx_users_email ON users (email);
-- Requires heap fetch to get id and name ‚Üí not index-only

-- Include the extra columns:
CREATE INDEX idx_users_email_include ON users (email) INCLUDE (id, name);
-- Query satisfied entirely from index ‚Äî no heap access
-- Check with EXPLAIN: "Index Only Scan" instead of "Index Scan"
</code></pre>
<h2>Fixing N+1 Queries</h2>
<p>The most common performance killer in ORMs:</p>
<pre><code class="language-sql">-- N+1: 1 query for users + N queries for orders
SELECT * FROM users WHERE status = 'active';
-- Then for each user:
SELECT * FROM orders WHERE user_id = $1;

-- Fix: JOIN or subquery
SELECT
    u.id,
    u.name,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT('id', o.id, 'total', o.total)
            ORDER BY o.created_at DESC
        ) FILTER (WHERE o.id IS NOT NULL),
        '[]'
    ) AS recent_orders
FROM users u
LEFT JOIN LATERAL (
    SELECT id, total, created_at
    FROM orders
    WHERE user_id = u.id
    ORDER BY created_at DESC
    LIMIT 5
) o ON true
WHERE u.status = 'active'
GROUP BY u.id, u.name;
</code></pre>
<p><code>LATERAL JOIN</code> is PostgreSQL's correlated subquery that's evaluated per-row but uses indexes on the subquery table ‚Äî perfect for "top N per group" patterns.</p>
<h2>VACUUM and AUTOVACUUM Tuning</h2>
<p>PostgreSQL uses MVCC ‚Äî old row versions accumulate as "dead tuples." VACUUM reclaims them. Without proper VACUUM, tables bloat and queries slow down.</p>
<p>Default autovacuum triggers when 20% of a table is dead tuples (<code>autovacuum_vacuum_scale_factor = 0.2</code>). For a 10M row table, that's 2M dead rows before vacuum runs ‚Äî too late.</p>
<pre><code class="language-sql">-- Per-table autovacuum tuning for high-update tables:
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.01,   -- Vacuum at 1% dead tuples (not 20%)
    autovacuum_vacuum_threshold = 100,        -- Minimum 100 dead tuples
    autovacuum_analyze_scale_factor = 0.005, -- Analyze at 0.5%
    autovacuum_vacuum_cost_delay = 2          -- Less throttling for busy tables
);

-- Monitor table bloat:
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    n_dead_tup,
    n_live_tup,
    round(n_dead_tup::numeric / nullif(n_live_tup + n_dead_tup, 0) * 100, 2) AS dead_pct,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY dead_pct DESC;
</code></pre>
<h2>Connection Pooling with PgBouncer</h2>
<p>PostgreSQL creates a new OS process per connection (~5MB RAM each). At 500 connections: 2.5GB of RAM just for connection overhead. PgBouncer pools many client connections into a small number of server connections:</p>
<pre><code class="language-ini"># pgbouncer.ini
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
listen_addr = 0.0.0.0
listen_port = 6432
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/users.txt

# Transaction pooling: release server connection on COMMIT/ROLLBACK
# Most aggressive pooling ‚Äî incompatible with prepared statements
pool_mode = transaction

default_pool_size = 20       # Server connections per database/user pair
max_client_conn = 1000       # Max client connections PgBouncer accepts
reserve_pool_size = 5        # Emergency connections
reserve_pool_timeout = 3
server_idle_timeout = 600    # Close idle server connections after 10 min
</code></pre>
<p>With PgBouncer in transaction mode: 1,000 app threads ‚Üí 20 actual PostgreSQL connections. PostgreSQL max_connections can be set to 50 instead of 1,000.</p>
<p><strong>Caveat:</strong> Transaction pooling breaks SET LOCAL, LISTEN/NOTIFY, advisory locks, and session-level prepared statements. Use session pooling if your app uses these.</p>
<h2>Partitioning for Large Tables</h2>
<p>Table partitioning keeps query plans efficient by allowing PostgreSQL to skip entire partitions:</p>
<pre><code class="language-sql">-- Range partitioning by month for time-series data
CREATE TABLE events (
    id          BIGSERIAL,
    user_id     BIGINT NOT NULL,
    event_type  TEXT NOT NULL,
    data        JSONB,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
) PARTITION BY RANGE (created_at);

CREATE TABLE events_2025_01 PARTITION OF events
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE events_2025_02 PARTITION OF events
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
-- ... automate with pg_partman extension

-- Query with partition key in WHERE ‚Üí partition pruning:
SELECT * FROM events
WHERE created_at BETWEEN '2025-01-01' AND '2025-01-31'
  AND user_id = 12345;
-- Scans only events_2025_01, not all partitions
</code></pre>
<p><strong>Partition maintenance:</strong> Use <code>pg_partman</code> to auto-create future partitions and drop old ones. Dropping an old partition is instant (DROP TABLE) ‚Äî much faster than DELETE.</p>
<h2>Key postgresql.conf Changes</h2>
<pre><code class="language-ini"># Memory (for a 16GB server):
shared_buffers = 4GB              # 25% of RAM ‚Äî PostgreSQL's buffer pool
effective_cache_size = 12GB       # Tells query planner how much OS cache exists
work_mem = 64MB                   # Per sort/hash operation (set conservatively ‚Äî multiplies)
maintenance_work_mem = 1GB        # For VACUUM, CREATE INDEX

# WAL and checkpoints:
wal_buffers = 64MB
checkpoint_completion_target = 0.9    # Spread checkpoint writes over 90% of interval
max_wal_size = 4GB                    # Allow larger WAL before forced checkpoint

# Query planner:
random_page_cost = 1.1               # SSD: set close to seq_page_cost (1.0)
                                     # HDD: default 4.0 is appropriate
effective_io_concurrency = 200       # SSD: set to 200; HDD: 2
parallel_workers_per_gather = 4      # Enable parallel query execution
max_parallel_workers_per_gather = 4

# Logging slow queries:
log_min_duration_statement = 1000    # Log queries > 1 second
log_checkpoints = on                 # Log checkpoint activity
log_autovacuum_min_duration = 250    # Log autovacuum runs > 250ms
</code></pre>
<p><code>work_mem</code> is the most dangerous setting. Each sort/hash operation uses up to <code>work_mem</code>. A query with 5 hash joins, run by 50 concurrent connections with 4 parallel workers = <code>50 √ó 5 √ó 4 √ó 64MB = 64GB</code>. Set it in session for analytical queries, not globally.</p>
<h2>Statistics and Query Plans</h2>
<p>PostgreSQL's query planner uses table statistics (row counts, value distributions) to choose plans. Stale statistics cause bad plans:</p>
<pre><code class="language-sql">-- Update statistics for a specific table:
ANALYZE orders;

-- Increase statistics target for columns with skewed distributions:
ALTER TABLE orders ALTER COLUMN status SET STATISTICS 500;
-- Default is 100 ‚Äî more samples for better cardinality estimates
ANALYZE orders;

-- Check when statistics were last updated:
SELECT tablename, last_analyze, last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'orders';

-- Force a specific plan for debugging (never in production permanently):
SET enable_seqscan = off;  -- Force index usage
EXPLAIN ANALYZE SELECT ...;
SET enable_seqscan = on;
</code></pre>
<h2>Production Monitoring Queries</h2>
<pre><code class="language-sql">-- Top 10 slowest queries (requires pg_stat_statements extension):
SELECT
    query,
    calls,
    round(total_exec_time::numeric / calls, 2) AS avg_ms,
    round(total_exec_time::numeric, 2) AS total_ms,
    rows / calls AS avg_rows
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;

-- Indexes never used (candidates for removal):
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan AS times_used
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexname NOT LIKE '%pkey%'  -- Keep primary keys
ORDER BY pg_relation_size(indexrelid) DESC;

-- Active locks (detect blocking queries):
SELECT
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query,
    state
FROM pg_stat_activity
WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes'
ORDER BY duration DESC;
</code></pre>
<h2>Real Production Case: 15-Second Query to 80ms</h2>
<p><strong>Starting point:</strong> E-commerce platform, orders table with 50M rows, query for customer order history timing out at 15 seconds.</p>
<pre><code class="language-sql">-- Original query:
SELECT o.*, oi.*, p.name as product_name
FROM orders o
JOIN order_items oi ON oi.order_id = o.id
JOIN products p ON p.id = oi.product_id
WHERE o.customer_id = 12345
ORDER BY o.created_at DESC
LIMIT 20;

-- EXPLAIN showed:
-- Seq Scan on orders (rows=50000000, actual rows=847, time=12000ms)
</code></pre>
<p><strong>Diagnosis:</strong> Sequential scan on orders table ‚Äî no index on <code>customer_id</code>.</p>
<p><strong>Fix 1:</strong> Composite index:</p>
<pre><code class="language-sql">CREATE INDEX CONCURRENTLY idx_orders_customer_created
ON orders (customer_id, created_at DESC);
</code></pre>
<p>Result: 15s ‚Üí 400ms. Good progress.</p>
<p><strong>Fix 2:</strong> EXPLAIN still showed <code>Buffers: read=12000</code> ‚Äî reading 12K pages for the joins. Added covering index for order_items:</p>
<pre><code class="language-sql">CREATE INDEX CONCURRENTLY idx_order_items_order_product
ON order_items (order_id) INCLUDE (product_id, quantity, unit_price);
</code></pre>
<p>Result: 400ms ‚Üí 80ms.</p>
<p><strong>Fix 3:</strong> pg_stat_statements showed this query running 50,000 times/day. Added application-level Redis cache with 5-minute TTL for customer order history. Database load reduced by 90%.</p>
<p>The lesson: indexing solves the query, caching solves the system.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=PostgreSQL%20Performance%20Tuning%3A%20From%20Slow%20Queries%20to%20Sub-Millisecond%20Reads&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fpostgresql-performance-tuning%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fpostgresql-performance-tuning%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#reading-explain-analyze-like-a-senior-dba" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Reading EXPLAIN ANALYZE Like a Senior DBA</a></li><li class=""><a href="#index-design-that-actually-helps" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Design That Actually Helps</a></li><li class="ml-4"><a href="#composite-indexes-column-order-matters" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Composite Indexes: Column Order Matters</a></li><li class="ml-4"><a href="#partial-indexes-for-selective-queries" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Partial Indexes for Selective Queries</a></li><li class="ml-4"><a href="#index-only-scans-with-include" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Index-Only Scans with INCLUDE</a></li><li class=""><a href="#fixing-n1-queries" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Fixing N+1 Queries</a></li><li class=""><a href="#vacuum-and-autovacuum-tuning" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">VACUUM and AUTOVACUUM Tuning</a></li><li class=""><a href="#connection-pooling-with-pgbouncer" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Connection Pooling with PgBouncer</a></li><li class=""><a href="#partitioning-for-large-tables" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Partitioning for Large Tables</a></li><li class=""><a href="#key-postgresqlconf-changes" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Key postgresql.conf Changes</a></li><li class=""><a href="#statistics-and-query-plans" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Statistics and Query Plans</a></li><li class=""><a href="#production-monitoring-queries" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Production Monitoring Queries</a></li><li class=""><a href="#real-production-case-15-second-query-to-80ms" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Real Production Case: 15-Second Query to 80ms</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there&#x27;s no primary, and data placement is determined by partit‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"PostgreSQL Performance Tuning: From Slow Queries to Sub-Millisecond Reads","description":"A production guide to PostgreSQL query optimization: EXPLAIN ANALYZE, index design, VACUUM tuning, connection pooling with PgBouncer, partitioning, and the configuration changes that actually move the needle.","date":"2025-06-03","category":"Databases","tags":["postgresql","databases","performance","sql","indexing","query optimization"],"featured":false,"affiliateSection":"database-resources","slug":"postgresql-performance-tuning","readingTime":"9 min read","excerpt":"PostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they're a query design problem that Post‚Ä¶","contentHtml":"\u003cp\u003ePostgreSQL ships with defaults tuned for a 512MB machine from 2005. Every production deployment needs to be re-tuned. Beyond that, most slow queries are not a PostgreSQL problem ‚Äî they're a query design problem that PostgreSQL surfaces. This article covers both: the query patterns that create avoidable load, and the server configuration that extracts maximum performance from your hardware.\u003c/p\u003e\n\u003ch2\u003eReading EXPLAIN ANALYZE Like a Senior DBA\u003c/h2\u003e\n\u003cp\u003eEvery performance investigation starts here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eEXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)\nSELECT u.id, u.name, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id\nWHERE u.status = 'active'\n  AND u.created_at \u003e '2024-01-01'\nGROUP BY u.id, u.name\nORDER BY order_count DESC\nLIMIT 100;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKey output fields to read:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHash Left Join  (cost=12500.00..89432.00 rows=100 width=40)\n                (actual time=1823.421..4231.005 rows=100 loops=1)\n  Buffers: shared hit=2841 read=31823\n  -\u003e  Seq Scan on users  (cost=0.00..42000.00 rows=500000 width=32)\n                         (actual time=0.023..1203.000 rows=500000 loops=1)\n        Filter: ((status = 'active') AND (created_at \u003e '2024-01-01'))\n        Rows Removed by Filter: 250000\n  -\u003e  Hash  (cost=8000.00..8000.00 rows=2000000 width=16) (...)\n        Buckets: 131072  Batches: 16  Memory Usage: 4096kB\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWhat to look for:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSeq Scan\u003c/code\u003e on large tables: missing index\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eactual time\u003c/code\u003e much higher than \u003ccode\u003ecost\u003c/code\u003e: stale statistics ‚Äî run \u003ccode\u003eANALYZE\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBuffers: read=31823\u003c/code\u003e: reading 31K pages from disk (cache miss) ‚Äî memory too small or missing index\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRows Removed by Filter: 250000\u003c/code\u003e: filter applied post-scan ‚Äî index on filter column needed\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBatches: 16\u003c/code\u003e on Hash: hash join spilled to disk ‚Äî increase \u003ccode\u003ework_mem\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eIndex Design That Actually Helps\u003c/h2\u003e\n\u003ch3\u003eComposite Indexes: Column Order Matters\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Query:\nSELECT * FROM orders\nWHERE user_id = 123 AND status = 'pending' AND created_at \u003e NOW() - INTERVAL '7 days';\n\n-- WRONG: index can only use leftmost prefix\nCREATE INDEX idx_orders_status_user ON orders (status, user_id);\n-- Query has high-cardinality filter (user_id) after low-cardinality (status) ‚Äî bad\n\n-- RIGHT: highest cardinality first, then equality, then range\nCREATE INDEX idx_orders_user_status_created ON orders (user_id, status, created_at DESC);\n-- user_id equality ‚Üí status equality ‚Üí created_at range: all 3 columns used\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRule:\u003c/strong\u003e Equality columns before range columns. High-cardinality before low-cardinality within equality columns.\u003c/p\u003e\n\u003ch3\u003ePartial Indexes for Selective Queries\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Only index active users (90% of queries)\nCREATE INDEX idx_users_active_created\nON users (created_at DESC)\nWHERE status = 'active';\n\n-- Only index unprocessed orders\nCREATE INDEX idx_orders_pending\nON orders (created_at, user_id)\nWHERE status = 'pending';\n-- If 5% of orders are pending, this index is 20√ó smaller ‚Äî faster scans, better cache utilization\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eIndex-Only Scans with INCLUDE\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Query needs id + email + name, but WHERE is on email\nCREATE INDEX idx_users_email ON users (email);\n-- Requires heap fetch to get id and name ‚Üí not index-only\n\n-- Include the extra columns:\nCREATE INDEX idx_users_email_include ON users (email) INCLUDE (id, name);\n-- Query satisfied entirely from index ‚Äî no heap access\n-- Check with EXPLAIN: \"Index Only Scan\" instead of \"Index Scan\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eFixing N+1 Queries\u003c/h2\u003e\n\u003cp\u003eThe most common performance killer in ORMs:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- N+1: 1 query for users + N queries for orders\nSELECT * FROM users WHERE status = 'active';\n-- Then for each user:\nSELECT * FROM orders WHERE user_id = $1;\n\n-- Fix: JOIN or subquery\nSELECT\n    u.id,\n    u.name,\n    COALESCE(\n        JSON_AGG(\n            JSON_BUILD_OBJECT('id', o.id, 'total', o.total)\n            ORDER BY o.created_at DESC\n        ) FILTER (WHERE o.id IS NOT NULL),\n        '[]'\n    ) AS recent_orders\nFROM users u\nLEFT JOIN LATERAL (\n    SELECT id, total, created_at\n    FROM orders\n    WHERE user_id = u.id\n    ORDER BY created_at DESC\n    LIMIT 5\n) o ON true\nWHERE u.status = 'active'\nGROUP BY u.id, u.name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eLATERAL JOIN\u003c/code\u003e is PostgreSQL's correlated subquery that's evaluated per-row but uses indexes on the subquery table ‚Äî perfect for \"top N per group\" patterns.\u003c/p\u003e\n\u003ch2\u003eVACUUM and AUTOVACUUM Tuning\u003c/h2\u003e\n\u003cp\u003ePostgreSQL uses MVCC ‚Äî old row versions accumulate as \"dead tuples.\" VACUUM reclaims them. Without proper VACUUM, tables bloat and queries slow down.\u003c/p\u003e\n\u003cp\u003eDefault autovacuum triggers when 20% of a table is dead tuples (\u003ccode\u003eautovacuum_vacuum_scale_factor = 0.2\u003c/code\u003e). For a 10M row table, that's 2M dead rows before vacuum runs ‚Äî too late.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Per-table autovacuum tuning for high-update tables:\nALTER TABLE orders SET (\n    autovacuum_vacuum_scale_factor = 0.01,   -- Vacuum at 1% dead tuples (not 20%)\n    autovacuum_vacuum_threshold = 100,        -- Minimum 100 dead tuples\n    autovacuum_analyze_scale_factor = 0.005, -- Analyze at 0.5%\n    autovacuum_vacuum_cost_delay = 2          -- Less throttling for busy tables\n);\n\n-- Monitor table bloat:\nSELECT\n    schemaname,\n    tablename,\n    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,\n    n_dead_tup,\n    n_live_tup,\n    round(n_dead_tup::numeric / nullif(n_live_tup + n_dead_tup, 0) * 100, 2) AS dead_pct,\n    last_autovacuum\nFROM pg_stat_user_tables\nWHERE n_dead_tup \u003e 10000\nORDER BY dead_pct DESC;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eConnection Pooling with PgBouncer\u003c/h2\u003e\n\u003cp\u003ePostgreSQL creates a new OS process per connection (~5MB RAM each). At 500 connections: 2.5GB of RAM just for connection overhead. PgBouncer pools many client connections into a small number of server connections:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ini\"\u003e# pgbouncer.ini\n[databases]\nmydb = host=localhost port=5432 dbname=mydb\n\n[pgbouncer]\nlisten_addr = 0.0.0.0\nlisten_port = 6432\nauth_type = scram-sha-256\nauth_file = /etc/pgbouncer/users.txt\n\n# Transaction pooling: release server connection on COMMIT/ROLLBACK\n# Most aggressive pooling ‚Äî incompatible with prepared statements\npool_mode = transaction\n\ndefault_pool_size = 20       # Server connections per database/user pair\nmax_client_conn = 1000       # Max client connections PgBouncer accepts\nreserve_pool_size = 5        # Emergency connections\nreserve_pool_timeout = 3\nserver_idle_timeout = 600    # Close idle server connections after 10 min\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith PgBouncer in transaction mode: 1,000 app threads ‚Üí 20 actual PostgreSQL connections. PostgreSQL max_connections can be set to 50 instead of 1,000.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCaveat:\u003c/strong\u003e Transaction pooling breaks SET LOCAL, LISTEN/NOTIFY, advisory locks, and session-level prepared statements. Use session pooling if your app uses these.\u003c/p\u003e\n\u003ch2\u003ePartitioning for Large Tables\u003c/h2\u003e\n\u003cp\u003eTable partitioning keeps query plans efficient by allowing PostgreSQL to skip entire partitions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Range partitioning by month for time-series data\nCREATE TABLE events (\n    id          BIGSERIAL,\n    user_id     BIGINT NOT NULL,\n    event_type  TEXT NOT NULL,\n    data        JSONB,\n    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()\n) PARTITION BY RANGE (created_at);\n\nCREATE TABLE events_2025_01 PARTITION OF events\n    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');\nCREATE TABLE events_2025_02 PARTITION OF events\n    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');\n-- ... automate with pg_partman extension\n\n-- Query with partition key in WHERE ‚Üí partition pruning:\nSELECT * FROM events\nWHERE created_at BETWEEN '2025-01-01' AND '2025-01-31'\n  AND user_id = 12345;\n-- Scans only events_2025_01, not all partitions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePartition maintenance:\u003c/strong\u003e Use \u003ccode\u003epg_partman\u003c/code\u003e to auto-create future partitions and drop old ones. Dropping an old partition is instant (DROP TABLE) ‚Äî much faster than DELETE.\u003c/p\u003e\n\u003ch2\u003eKey postgresql.conf Changes\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-ini\"\u003e# Memory (for a 16GB server):\nshared_buffers = 4GB              # 25% of RAM ‚Äî PostgreSQL's buffer pool\neffective_cache_size = 12GB       # Tells query planner how much OS cache exists\nwork_mem = 64MB                   # Per sort/hash operation (set conservatively ‚Äî multiplies)\nmaintenance_work_mem = 1GB        # For VACUUM, CREATE INDEX\n\n# WAL and checkpoints:\nwal_buffers = 64MB\ncheckpoint_completion_target = 0.9    # Spread checkpoint writes over 90% of interval\nmax_wal_size = 4GB                    # Allow larger WAL before forced checkpoint\n\n# Query planner:\nrandom_page_cost = 1.1               # SSD: set close to seq_page_cost (1.0)\n                                     # HDD: default 4.0 is appropriate\neffective_io_concurrency = 200       # SSD: set to 200; HDD: 2\nparallel_workers_per_gather = 4      # Enable parallel query execution\nmax_parallel_workers_per_gather = 4\n\n# Logging slow queries:\nlog_min_duration_statement = 1000    # Log queries \u003e 1 second\nlog_checkpoints = on                 # Log checkpoint activity\nlog_autovacuum_min_duration = 250    # Log autovacuum runs \u003e 250ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ework_mem\u003c/code\u003e is the most dangerous setting. Each sort/hash operation uses up to \u003ccode\u003ework_mem\u003c/code\u003e. A query with 5 hash joins, run by 50 concurrent connections with 4 parallel workers = \u003ccode\u003e50 √ó 5 √ó 4 √ó 64MB = 64GB\u003c/code\u003e. Set it in session for analytical queries, not globally.\u003c/p\u003e\n\u003ch2\u003eStatistics and Query Plans\u003c/h2\u003e\n\u003cp\u003ePostgreSQL's query planner uses table statistics (row counts, value distributions) to choose plans. Stale statistics cause bad plans:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Update statistics for a specific table:\nANALYZE orders;\n\n-- Increase statistics target for columns with skewed distributions:\nALTER TABLE orders ALTER COLUMN status SET STATISTICS 500;\n-- Default is 100 ‚Äî more samples for better cardinality estimates\nANALYZE orders;\n\n-- Check when statistics were last updated:\nSELECT tablename, last_analyze, last_autoanalyze\nFROM pg_stat_user_tables\nWHERE tablename = 'orders';\n\n-- Force a specific plan for debugging (never in production permanently):\nSET enable_seqscan = off;  -- Force index usage\nEXPLAIN ANALYZE SELECT ...;\nSET enable_seqscan = on;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eProduction Monitoring Queries\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Top 10 slowest queries (requires pg_stat_statements extension):\nSELECT\n    query,\n    calls,\n    round(total_exec_time::numeric / calls, 2) AS avg_ms,\n    round(total_exec_time::numeric, 2) AS total_ms,\n    rows / calls AS avg_rows\nFROM pg_stat_statements\nORDER BY total_exec_time DESC\nLIMIT 10;\n\n-- Indexes never used (candidates for removal):\nSELECT\n    schemaname,\n    tablename,\n    indexname,\n    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n    idx_scan AS times_used\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexname NOT LIKE '%pkey%'  -- Keep primary keys\nORDER BY pg_relation_size(indexrelid) DESC;\n\n-- Active locks (detect blocking queries):\nSELECT\n    pid,\n    now() - pg_stat_activity.query_start AS duration,\n    query,\n    state\nFROM pg_stat_activity\nWHERE (now() - pg_stat_activity.query_start) \u003e interval '5 minutes'\nORDER BY duration DESC;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReal Production Case: 15-Second Query to 80ms\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eStarting point:\u003c/strong\u003e E-commerce platform, orders table with 50M rows, query for customer order history timing out at 15 seconds.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Original query:\nSELECT o.*, oi.*, p.name as product_name\nFROM orders o\nJOIN order_items oi ON oi.order_id = o.id\nJOIN products p ON p.id = oi.product_id\nWHERE o.customer_id = 12345\nORDER BY o.created_at DESC\nLIMIT 20;\n\n-- EXPLAIN showed:\n-- Seq Scan on orders (rows=50000000, actual rows=847, time=12000ms)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eDiagnosis:\u003c/strong\u003e Sequential scan on orders table ‚Äî no index on \u003ccode\u003ecustomer_id\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFix 1:\u003c/strong\u003e Composite index:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE INDEX CONCURRENTLY idx_orders_customer_created\nON orders (customer_id, created_at DESC);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eResult: 15s ‚Üí 400ms. Good progress.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFix 2:\u003c/strong\u003e EXPLAIN still showed \u003ccode\u003eBuffers: read=12000\u003c/code\u003e ‚Äî reading 12K pages for the joins. Added covering index for order_items:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE INDEX CONCURRENTLY idx_order_items_order_product\nON order_items (order_id) INCLUDE (product_id, quantity, unit_price);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eResult: 400ms ‚Üí 80ms.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFix 3:\u003c/strong\u003e pg_stat_statements showed this query running 50,000 times/day. Added application-level Redis cache with 5-minute TTL for customer order history. Database load reduced by 90%.\u003c/p\u003e\n\u003cp\u003eThe lesson: indexing solves the query, caching solves the system.\u003c/p\u003e\n","tableOfContents":[{"id":"reading-explain-analyze-like-a-senior-dba","text":"Reading EXPLAIN ANALYZE Like a Senior DBA","level":2},{"id":"index-design-that-actually-helps","text":"Index Design That Actually Helps","level":2},{"id":"composite-indexes-column-order-matters","text":"Composite Indexes: Column Order Matters","level":3},{"id":"partial-indexes-for-selective-queries","text":"Partial Indexes for Selective Queries","level":3},{"id":"index-only-scans-with-include","text":"Index-Only Scans with INCLUDE","level":3},{"id":"fixing-n1-queries","text":"Fixing N+1 Queries","level":2},{"id":"vacuum-and-autovacuum-tuning","text":"VACUUM and AUTOVACUUM Tuning","level":2},{"id":"connection-pooling-with-pgbouncer","text":"Connection Pooling with PgBouncer","level":2},{"id":"partitioning-for-large-tables","text":"Partitioning for Large Tables","level":2},{"id":"key-postgresqlconf-changes","text":"Key postgresql.conf Changes","level":2},{"id":"statistics-and-query-plans","text":"Statistics and Query Plans","level":2},{"id":"production-monitoring-queries","text":"Production Monitoring Queries","level":2},{"id":"real-production-case-15-second-query-to-80ms","text":"Real Production Case: 15-Second Query to 80ms","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"postgresql-performance-tuning"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>