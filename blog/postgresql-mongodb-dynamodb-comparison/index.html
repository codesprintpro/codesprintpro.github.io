<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database<!-- --> | CodeSprintPro</title><meta name="description" content="A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/postgresql-mongodb-dynamodb-comparison/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database" data-next-head=""/><meta property="og:description" content="A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/postgresql-mongodb-dynamodb-comparison/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-01-12" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="postgresql" data-next-head=""/><meta property="article:tag" content="mongodb" data-next-head=""/><meta property="article:tag" content="dynamodb" data-next-head=""/><meta property="article:tag" content="nosql" data-next-head=""/><meta property="article:tag" content="sql" data-next-head=""/><meta property="article:tag" content="databases" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database" data-next-head=""/><meta name="twitter:description" content="A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database","description":"A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-01-12","dateModified":"2025-01-12","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/postgresql-mongodb-dynamodb-comparison/"},"keywords":"postgresql, mongodb, dynamodb, nosql, sql, databases","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>January 12, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>11 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->postgresql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->mongodb</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->dynamodb</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->nosql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->sql</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->databases</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Every database choice is a bet on your access patterns. PostgreSQL, MongoDB, and DynamoDB are all excellent databases ‚Äî for different problems. The mistake engineers make is choosing based on hype ("NoSQL scales better") or familiarity ("we've always used Postgres") rather than modeling their actual data access patterns.</p>
<p>This article gives you a decision framework based on concrete trade-offs, not vendor marketing.</p>
<h2>The Core Trade-off: Flexibility vs Predictability</h2>
<p>Before diving into each database, it helps to understand the fundamental spectrum they sit on. As you move from PostgreSQL toward DynamoDB, you give up query flexibility in exchange for more predictable performance at scale. Neither end is universally better ‚Äî the right position on the spectrum depends entirely on what your application needs to do.</p>
<pre><code>PostgreSQL:  Schema-first, ACID, flexible queries, bounded performance at scale
MongoDB:     Schema-flexible, eventual consistency by default, rich queries, scales horizontally
DynamoDB:    Schema-minimal, predictable single-digit millisecond latency, massive scale, constrained queries
</code></pre>
<p>The more you sacrifice query flexibility (PostgreSQL ‚Üí MongoDB ‚Üí DynamoDB), the more predictable and scalable your read/write performance becomes. Choose the right level for your use case.</p>
<h2>PostgreSQL: When Your Data Is Relational</h2>
<p>PostgreSQL excels when:</p>
<ul>
<li>Data has complex relationships (foreign keys, joins)</li>
<li>You need ACID transactions across multiple entities</li>
<li>Query patterns are varied and exploratory (reporting, analytics)</li>
<li>Your dataset fits in a few TB (or you can shard)</li>
</ul>
<h3>PostgreSQL Strengths</h3>
<p><strong>MVCC and True ACID:</strong></p>
<p>Financial operations are the canonical example of why ACID transactions matter. The code below shows a bank transfer ‚Äî the classic case where partial success is worse than failure. PostgreSQL's MVCC (Multi-Version Concurrency Control) ensures that other transactions reading the accounts during this transfer see a consistent snapshot, not half-transferred state.</p>
<pre><code class="language-sql">-- Bank transfer: both operations succeed or both fail
BEGIN;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
  -- If any error here, ROLLBACK; both changes undone
COMMIT;
</code></pre>
<p><strong>JSONB for schema flexibility within structure:</strong></p>
<p>One of PostgreSQL's underappreciated features is JSONB ‚Äî it lets you store structured relational data alongside flexible document data in the same table. The <code>attributes</code> column below can hold different keys for different product types (a shirt has <code>color</code> and <code>size</code>, while a laptop has <code>ram</code> and <code>storage</code>), while the rest of the table stays strongly typed. You get schema flexibility where you need it, without giving it up everywhere.</p>
<pre><code class="language-sql">-- Mix relational and document in one table
CREATE TABLE products (
    id         BIGSERIAL PRIMARY KEY,
    name       VARCHAR(255) NOT NULL,
    price      DECIMAL(10,2) NOT NULL,
    category   VARCHAR(100) NOT NULL,
    attributes JSONB,                 -- flexible product-specific fields
    created_at TIMESTAMP DEFAULT NOW()
);

-- Index into JSONB for performant queries
CREATE INDEX idx_products_color ON products USING gin((attributes->'color'));

-- Query JSONB fields
SELECT name, price, attributes->>'color' AS color
FROM products
WHERE category = 'shirts'
  AND (attributes->>'size')::text = 'L'
  AND price &#x3C; 50;
</code></pre>
<p><strong>Partitioning for time-series data:</strong></p>
<p>When a table grows into the hundreds of millions of rows, even indexed queries slow down because the index itself becomes large and expensive to scan. Table partitioning solves this by splitting the data into smaller physical tables (partitions) based on a key ‚Äî in this case, the month. The query planner then automatically skips partitions that can't possibly match your time range, a technique called partition pruning.</p>
<pre><code class="language-sql">-- Monthly partitions for events table
CREATE TABLE events (
    id         UUID DEFAULT gen_random_uuid(),
    user_id    BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    occurred_at TIMESTAMPTZ NOT NULL,
    payload    JSONB
) PARTITION BY RANGE (occurred_at);

CREATE TABLE events_2025_01 PARTITION OF events
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE events_2025_02 PARTITION OF events
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- Queries automatically prune irrelevant partitions
SELECT * FROM events WHERE occurred_at BETWEEN '2025-01-15' AND '2025-01-20';
-- Scans only events_2025_01 partition
</code></pre>
<p><strong>When PostgreSQL struggles:</strong></p>
<ul>
<li>Horizontal sharding is manual and complex (CitusDB or application-level sharding)</li>
<li>Connection overhead at high concurrency (use PgBouncer ‚Äî connection pooling is essential)</li>
<li>Full-text search is functional but not as feature-rich as Elasticsearch</li>
<li>Writes slow down as table size grows without careful partition/index management</li>
</ul>
<h2>MongoDB: When Documents Are Natural</h2>
<p>MongoDB excels when:</p>
<ul>
<li>Your data is naturally document-shaped (nested objects, arrays)</li>
<li>Schema evolves frequently (rapidly changing product attributes, user profiles)</li>
<li>You need horizontal sharding without application-level complexity</li>
<li>Read patterns favor fetching complete documents</li>
</ul>
<h3>MongoDB Strengths</h3>
<p><strong>Document model matches application objects:</strong></p>
<p>The key insight behind MongoDB's document model is that it eliminates the object-relational impedance mismatch. In a relational database, a user profile with preferences, an address, and subscription details is spread across 3-4 tables. Every read requires a join. In MongoDB, the whole user is one document ‚Äî one read, no joins. This makes the most sense when you almost always need the whole object together, not fragments of it.</p>
<pre><code class="language-javascript">// No joins needed ‚Äî embed related data that's fetched together
{
  "_id": ObjectId("..."),
  "userId": "user_123",
  "name": "John Doe",
  "email": "john@example.com",
  "address": {
    "street": "123 Main St",
    "city": "San Francisco",
    "country": "US"
  },
  "preferences": {
    "theme": "dark",
    "notifications": ["email", "push"],
    "timezone": "America/New_York"
  },
  "subscription": {
    "tier": "pro",
    "expiresAt": ISODate("2025-12-31")
  },
  "createdAt": ISODate("2024-01-15")
}
</code></pre>
<p>With PostgreSQL, this requires 3-4 tables and a join query. With MongoDB, it's one document ‚Äî one read.</p>
<p><strong>Aggregation pipeline for complex analytics:</strong></p>
<p>MongoDB's aggregation pipeline works like a Unix pipe: data flows through stages, each stage transforming the output of the previous one. The pipeline below unwinds order line items, joins with product data, groups by region and category, and sorts by revenue ‚Äî all inside the database. For analytics that need to stay close to the document model, this is significantly more natural than translating to SQL.</p>
<pre><code class="language-javascript">// Sales report by region and product category
db.orders.aggregate([
  { $match: { status: "completed", date: { $gte: new Date("2025-01-01") } } },
  { $unwind: "$items" },
  { $lookup: {
    from: "products",
    localField: "items.productId",
    foreignField: "_id",
    as: "product"
  }},
  { $unwind: "$product" },
  { $group: {
    _id: { region: "$region", category: "$product.category" },
    totalRevenue: { $sum: { $multiply: ["$items.quantity", "$items.price"] } },
    orderCount: { $count: {} }
  }},
  { $sort: { totalRevenue: -1 } }
]);
</code></pre>
<p><strong>When MongoDB struggles:</strong></p>
<ul>
<li>Multi-document transactions (added in 4.0, but have overhead ‚Äî design to avoid them)</li>
<li>Complex joins across collections (schema design mistake ‚Äî embed more)</li>
<li>Strong consistency requirements (default is eventual ‚Äî use <code>readConcern: majority</code> for strong reads, at latency cost)</li>
<li>Fixed-cost analytics at scale (Aggregation pipeline is powerful but slower than ClickHouse for OLAP)</li>
</ul>
<h2>DynamoDB: When You Need Predictable Scale</h2>
<p>DynamoDB excels when:</p>
<ul>
<li>You need guaranteed single-digit millisecond latency at any scale</li>
<li>Access patterns are known and simple (get by key, query by partition)</li>
<li>You expect massive, unpredictable traffic spikes</li>
<li>Operational overhead must be near-zero (fully managed, no tuning)</li>
</ul>
<h3>Single-Table Design: The Key Concept</h3>
<p>DynamoDB's most unusual characteristic is that it rewards putting all your entity types into a single table. This feels wrong to SQL-trained engineers, but there's a reason: DynamoDB can only efficiently query by partition key and sort key. By encoding entity type and relationships into those keys, you make all your access patterns fast. Think of it as designing your access API first, then building the schema to serve it.</p>
<p>DynamoDB's data model forces you to think about access patterns first, schema second. All entity types live in one table.</p>
<pre><code>Table: "app-table"

PK              | SK              | GSI1PK      | GSI1SK      | Data
----------------|-----------------|-------------|-------------|----------
USER#user123    | PROFILE         | EMAIL#j@e   | USER#user123| name, phone
USER#user123    | ORDER#order456  | STATUS#PAID | 2025-01-15  | total, items
USER#user123    | ORDER#order789  | STATUS#SHIP | 2025-01-20  | total, items
ORDER#order456  | ITEM#item001    |             |             | qty, price
ORDER#order456  | ITEM#item002    |             |             | qty, price
PRODUCT#prod001 | METADATA        |             |             | name, price

Access patterns satisfied by this schema:
1. GetItem: Get user profile ‚Üí PK=USER#user123, SK=PROFILE
2. Query: Get all orders for user ‚Üí PK=USER#user123, SK begins_with "ORDER#"
3. Query: Get all paid orders (any user) ‚Üí GSI1, PK=STATUS#PAID
4. Query: Get all items in order ‚Üí PK=ORDER#order456, SK begins_with "ITEM#"
</code></pre>
<p>The Java code below shows how to talk to this table using the DynamoDB Enhanced Client, which maps your annotated Java classes to DynamoDB items. Notice that the <code>pk</code> field holds compound keys like <code>USER#user123</code> ‚Äî the <code>#</code> separator is a convention that keeps different entity types from accidentally colliding while still letting you query all entities of a type by prefix.</p>
<pre><code class="language-java">// DynamoDB single-table access with DynamoDB Enhanced Client
@DynamoDbBean
public class UserProfile {
    private String pk;  // "USER#user123"
    private String sk;  // "PROFILE"
    private String name;
    private String email;
    // ...

    @DynamoDbPartitionKey
    public String getPk() { return pk; }

    @DynamoDbSortKey
    public String getSk() { return sk; }
}

DynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()
    .dynamoDbClient(DynamoDbClient.create())
    .build();

DynamoDbTable&#x3C;UserProfile> table = client.table("app-table", TableSchema.fromBean(UserProfile.class));

// Put
table.putItem(userProfile);

// Get
UserProfile profile = table.getItem(Key.builder()
    .partitionValue("USER#user123")
    .sortValue("PROFILE")
    .build());

// Query all orders for user
PageIterable&#x3C;UserProfile> orders = table.query(
    QueryConditional.sortBeginsWith(Key.builder()
        .partitionValue("USER#user123")
        .sortValue("ORDER#")
        .build())
);
</code></pre>
<p><strong>DynamoDB Streams for event-driven architecture:</strong></p>
<p>DynamoDB Streams captures a time-ordered log of every write to your table, which you can process with a Lambda function. This turns your database into an event bus: a new order row appears, Streams fires an event, Lambda processes it. This pattern is how you build event-driven microservices without adding a separate message broker.</p>
<pre><code class="language-java">// DynamoDB Streams captures every write as an event
// Lambda trigger: process changes in real-time

@Override
public void handleRequest(DynamodbEvent event, Context context) {
    for (DynamodbStreamRecord record : event.getRecords()) {
        if ("INSERT".equals(record.getEventName())) {
            Map&#x3C;String, AttributeValue> newItem = record.getDynamodb().getNewImage();
            String pk = newItem.get("pk").getS();

            if (pk.startsWith("ORDER#")) {
                // New order created ‚Äî trigger fulfillment workflow
                fulfillmentService.processOrder(pk.replace("ORDER#", ""));
            }
        }
    }
}
</code></pre>
<p><strong>When DynamoDB struggles:</strong></p>
<ul>
<li>Ad-hoc queries (you don't know your access patterns upfront)</li>
<li>Complex joins across entity types (impossible without multiple round-trips)</li>
<li>Large item sizes (400KB item limit)</li>
<li>ACID transactions (supported but limited to 25 items, higher cost)</li>
<li>Migrations (no schema = no migration tooling, managing attribute evolution is manual)</li>
</ul>
<h2>Decision Framework</h2>
<p>Use this flow when you are evaluating which database to pick for a new service or feature. The questions are ordered by the factors that most strongly constrain your choice ‚Äî start at the top and stop when you have a clear answer.</p>
<pre><code>Question 1: Do you have complex relationships and varied query patterns?
  YES ‚Üí PostgreSQL

Question 2: Is your data naturally document-shaped with evolving schema?
  YES ‚Üí MongoDB

Question 3: Do you need guaranteed &#x3C; 10ms latency at 100K+ RPS with zero ops burden?
  YES ‚Üí DynamoDB

Question 4: Do you need ACID across multiple entities?
  YES ‚Üí PostgreSQL (or MongoDB 4.0+ with caveats)

Question 5: Do you expect 10x traffic spikes without pre-scaling?
  YES ‚Üí DynamoDB (serverless on-demand mode handles this automatically)
</code></pre>
<h2>The Hybrid Architecture (Real World)</h2>
<p>In practice, the most robust production systems don't pick one database and force everything through it. They use each database for what it does best, accepting the operational cost of running multiple systems in exchange for the performance and scalability benefits. Here is a realistic example of how these databases coexist in a mature e-commerce platform.</p>
<p>Most production systems use multiple databases:</p>
<pre><code>E-commerce platform:

  PostgreSQL:
    - User accounts, authentication
    - Products, inventory (complex relationships)
    - Orders (ACID transactions for payment)

  DynamoDB:
    - Session storage (high throughput, simple key-value)
    - Shopping cart (real-time, per-user state)
    - Search history (write-heavy, simple structure)

  Redis:
    - Product catalog cache (hot reads)
    - Rate limiting
    - Real-time inventory counters

  Elasticsearch:
    - Product search with full-text + facets

  ClickHouse:
    - Analytics (revenue reports, funnel analysis)
</code></pre>
<p>No single database is the right answer. The polyglot persistence approach ‚Äî using each database for what it does best ‚Äî is the production-grade solution.</p>
<p>The interview trap is picking one and defending it universally. The production mindset is asking: "What are the actual access patterns?" and then matching the tool to the requirement.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB ‚Äî The Complete Developer&#x27;s Guide ‚Äî Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=PostgreSQL%20vs%20MongoDB%20vs%20DynamoDB%3A%20When%20to%20Use%20Which%20Database&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fpostgresql-mongodb-dynamodb-comparison%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fpostgresql-mongodb-dynamodb-comparison%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#the-core-trade-off-flexibility-vs-predictability" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Core Trade-off: Flexibility vs Predictability</a></li><li class=""><a href="#postgresql-when-your-data-is-relational" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">PostgreSQL: When Your Data Is Relational</a></li><li class="ml-4"><a href="#postgresql-strengths" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">PostgreSQL Strengths</a></li><li class=""><a href="#mongodb-when-documents-are-natural" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">MongoDB: When Documents Are Natural</a></li><li class="ml-4"><a href="#mongodb-strengths" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">MongoDB Strengths</a></li><li class=""><a href="#dynamodb-when-you-need-predictable-scale" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">DynamoDB: When You Need Predictable Scale</a></li><li class="ml-4"><a href="#single-table-design-the-key-concept" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Single-Table Design: The Key Concept</a></li><li class=""><a href="#decision-framework" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Decision Framework</a></li><li class=""><a href="#the-hybrid-architecture-real-world" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">The Hybrid Architecture (Real World)</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there&#x27;s no primary, and data placement is determined by partit‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"PostgreSQL vs MongoDB vs DynamoDB: When to Use Which Database","description":"A pragmatic guide to choosing between relational, document, and key-value stores. Real trade-offs, access patterns, and decision criteria ‚Äî not marketing material.","date":"2025-01-12","category":"Databases","tags":["postgresql","mongodb","dynamodb","nosql","sql","databases"],"featured":false,"affiliateSection":"database-resources","slug":"postgresql-mongodb-dynamodb-comparison","readingTime":"11 min read","excerpt":"Every database choice is a bet on your access patterns. PostgreSQL, MongoDB, and DynamoDB are all excellent databases ‚Äî for different problems. The mistake engineers make is choosing based on hype (\"NoSQL scales better\")‚Ä¶","contentHtml":"\u003cp\u003eEvery database choice is a bet on your access patterns. PostgreSQL, MongoDB, and DynamoDB are all excellent databases ‚Äî for different problems. The mistake engineers make is choosing based on hype (\"NoSQL scales better\") or familiarity (\"we've always used Postgres\") rather than modeling their actual data access patterns.\u003c/p\u003e\n\u003cp\u003eThis article gives you a decision framework based on concrete trade-offs, not vendor marketing.\u003c/p\u003e\n\u003ch2\u003eThe Core Trade-off: Flexibility vs Predictability\u003c/h2\u003e\n\u003cp\u003eBefore diving into each database, it helps to understand the fundamental spectrum they sit on. As you move from PostgreSQL toward DynamoDB, you give up query flexibility in exchange for more predictable performance at scale. Neither end is universally better ‚Äî the right position on the spectrum depends entirely on what your application needs to do.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePostgreSQL:  Schema-first, ACID, flexible queries, bounded performance at scale\nMongoDB:     Schema-flexible, eventual consistency by default, rich queries, scales horizontally\nDynamoDB:    Schema-minimal, predictable single-digit millisecond latency, massive scale, constrained queries\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe more you sacrifice query flexibility (PostgreSQL ‚Üí MongoDB ‚Üí DynamoDB), the more predictable and scalable your read/write performance becomes. Choose the right level for your use case.\u003c/p\u003e\n\u003ch2\u003ePostgreSQL: When Your Data Is Relational\u003c/h2\u003e\n\u003cp\u003ePostgreSQL excels when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eData has complex relationships (foreign keys, joins)\u003c/li\u003e\n\u003cli\u003eYou need ACID transactions across multiple entities\u003c/li\u003e\n\u003cli\u003eQuery patterns are varied and exploratory (reporting, analytics)\u003c/li\u003e\n\u003cli\u003eYour dataset fits in a few TB (or you can shard)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePostgreSQL Strengths\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eMVCC and True ACID:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFinancial operations are the canonical example of why ACID transactions matter. The code below shows a bank transfer ‚Äî the classic case where partial success is worse than failure. PostgreSQL's MVCC (Multi-Version Concurrency Control) ensures that other transactions reading the accounts during this transfer see a consistent snapshot, not half-transferred state.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Bank transfer: both operations succeed or both fail\nBEGIN;\n  UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n  UPDATE accounts SET balance = balance + 100 WHERE id = 2;\n  -- If any error here, ROLLBACK; both changes undone\nCOMMIT;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eJSONB for schema flexibility within structure:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOne of PostgreSQL's underappreciated features is JSONB ‚Äî it lets you store structured relational data alongside flexible document data in the same table. The \u003ccode\u003eattributes\u003c/code\u003e column below can hold different keys for different product types (a shirt has \u003ccode\u003ecolor\u003c/code\u003e and \u003ccode\u003esize\u003c/code\u003e, while a laptop has \u003ccode\u003eram\u003c/code\u003e and \u003ccode\u003estorage\u003c/code\u003e), while the rest of the table stays strongly typed. You get schema flexibility where you need it, without giving it up everywhere.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Mix relational and document in one table\nCREATE TABLE products (\n    id         BIGSERIAL PRIMARY KEY,\n    name       VARCHAR(255) NOT NULL,\n    price      DECIMAL(10,2) NOT NULL,\n    category   VARCHAR(100) NOT NULL,\n    attributes JSONB,                 -- flexible product-specific fields\n    created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Index into JSONB for performant queries\nCREATE INDEX idx_products_color ON products USING gin((attributes-\u003e'color'));\n\n-- Query JSONB fields\nSELECT name, price, attributes-\u003e\u003e'color' AS color\nFROM products\nWHERE category = 'shirts'\n  AND (attributes-\u003e\u003e'size')::text = 'L'\n  AND price \u0026#x3C; 50;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePartitioning for time-series data:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhen a table grows into the hundreds of millions of rows, even indexed queries slow down because the index itself becomes large and expensive to scan. Table partitioning solves this by splitting the data into smaller physical tables (partitions) based on a key ‚Äî in this case, the month. The query planner then automatically skips partitions that can't possibly match your time range, a technique called partition pruning.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- Monthly partitions for events table\nCREATE TABLE events (\n    id         UUID DEFAULT gen_random_uuid(),\n    user_id    BIGINT NOT NULL,\n    event_type VARCHAR(50) NOT NULL,\n    occurred_at TIMESTAMPTZ NOT NULL,\n    payload    JSONB\n) PARTITION BY RANGE (occurred_at);\n\nCREATE TABLE events_2025_01 PARTITION OF events\n    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');\n\nCREATE TABLE events_2025_02 PARTITION OF events\n    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');\n\n-- Queries automatically prune irrelevant partitions\nSELECT * FROM events WHERE occurred_at BETWEEN '2025-01-15' AND '2025-01-20';\n-- Scans only events_2025_01 partition\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWhen PostgreSQL struggles:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHorizontal sharding is manual and complex (CitusDB or application-level sharding)\u003c/li\u003e\n\u003cli\u003eConnection overhead at high concurrency (use PgBouncer ‚Äî connection pooling is essential)\u003c/li\u003e\n\u003cli\u003eFull-text search is functional but not as feature-rich as Elasticsearch\u003c/li\u003e\n\u003cli\u003eWrites slow down as table size grows without careful partition/index management\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMongoDB: When Documents Are Natural\u003c/h2\u003e\n\u003cp\u003eMongoDB excels when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYour data is naturally document-shaped (nested objects, arrays)\u003c/li\u003e\n\u003cli\u003eSchema evolves frequently (rapidly changing product attributes, user profiles)\u003c/li\u003e\n\u003cli\u003eYou need horizontal sharding without application-level complexity\u003c/li\u003e\n\u003cli\u003eRead patterns favor fetching complete documents\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMongoDB Strengths\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eDocument model matches application objects:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe key insight behind MongoDB's document model is that it eliminates the object-relational impedance mismatch. In a relational database, a user profile with preferences, an address, and subscription details is spread across 3-4 tables. Every read requires a join. In MongoDB, the whole user is one document ‚Äî one read, no joins. This makes the most sense when you almost always need the whole object together, not fragments of it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// No joins needed ‚Äî embed related data that's fetched together\n{\n  \"_id\": ObjectId(\"...\"),\n  \"userId\": \"user_123\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"address\": {\n    \"street\": \"123 Main St\",\n    \"city\": \"San Francisco\",\n    \"country\": \"US\"\n  },\n  \"preferences\": {\n    \"theme\": \"dark\",\n    \"notifications\": [\"email\", \"push\"],\n    \"timezone\": \"America/New_York\"\n  },\n  \"subscription\": {\n    \"tier\": \"pro\",\n    \"expiresAt\": ISODate(\"2025-12-31\")\n  },\n  \"createdAt\": ISODate(\"2024-01-15\")\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith PostgreSQL, this requires 3-4 tables and a join query. With MongoDB, it's one document ‚Äî one read.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAggregation pipeline for complex analytics:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMongoDB's aggregation pipeline works like a Unix pipe: data flows through stages, each stage transforming the output of the previous one. The pipeline below unwinds order line items, joins with product data, groups by region and category, and sorts by revenue ‚Äî all inside the database. For analytics that need to stay close to the document model, this is significantly more natural than translating to SQL.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Sales report by region and product category\ndb.orders.aggregate([\n  { $match: { status: \"completed\", date: { $gte: new Date(\"2025-01-01\") } } },\n  { $unwind: \"$items\" },\n  { $lookup: {\n    from: \"products\",\n    localField: \"items.productId\",\n    foreignField: \"_id\",\n    as: \"product\"\n  }},\n  { $unwind: \"$product\" },\n  { $group: {\n    _id: { region: \"$region\", category: \"$product.category\" },\n    totalRevenue: { $sum: { $multiply: [\"$items.quantity\", \"$items.price\"] } },\n    orderCount: { $count: {} }\n  }},\n  { $sort: { totalRevenue: -1 } }\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWhen MongoDB struggles:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMulti-document transactions (added in 4.0, but have overhead ‚Äî design to avoid them)\u003c/li\u003e\n\u003cli\u003eComplex joins across collections (schema design mistake ‚Äî embed more)\u003c/li\u003e\n\u003cli\u003eStrong consistency requirements (default is eventual ‚Äî use \u003ccode\u003ereadConcern: majority\u003c/code\u003e for strong reads, at latency cost)\u003c/li\u003e\n\u003cli\u003eFixed-cost analytics at scale (Aggregation pipeline is powerful but slower than ClickHouse for OLAP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eDynamoDB: When You Need Predictable Scale\u003c/h2\u003e\n\u003cp\u003eDynamoDB excels when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need guaranteed single-digit millisecond latency at any scale\u003c/li\u003e\n\u003cli\u003eAccess patterns are known and simple (get by key, query by partition)\u003c/li\u003e\n\u003cli\u003eYou expect massive, unpredictable traffic spikes\u003c/li\u003e\n\u003cli\u003eOperational overhead must be near-zero (fully managed, no tuning)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSingle-Table Design: The Key Concept\u003c/h3\u003e\n\u003cp\u003eDynamoDB's most unusual characteristic is that it rewards putting all your entity types into a single table. This feels wrong to SQL-trained engineers, but there's a reason: DynamoDB can only efficiently query by partition key and sort key. By encoding entity type and relationships into those keys, you make all your access patterns fast. Think of it as designing your access API first, then building the schema to serve it.\u003c/p\u003e\n\u003cp\u003eDynamoDB's data model forces you to think about access patterns first, schema second. All entity types live in one table.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTable: \"app-table\"\n\nPK              | SK              | GSI1PK      | GSI1SK      | Data\n----------------|-----------------|-------------|-------------|----------\nUSER#user123    | PROFILE         | EMAIL#j@e   | USER#user123| name, phone\nUSER#user123    | ORDER#order456  | STATUS#PAID | 2025-01-15  | total, items\nUSER#user123    | ORDER#order789  | STATUS#SHIP | 2025-01-20  | total, items\nORDER#order456  | ITEM#item001    |             |             | qty, price\nORDER#order456  | ITEM#item002    |             |             | qty, price\nPRODUCT#prod001 | METADATA        |             |             | name, price\n\nAccess patterns satisfied by this schema:\n1. GetItem: Get user profile ‚Üí PK=USER#user123, SK=PROFILE\n2. Query: Get all orders for user ‚Üí PK=USER#user123, SK begins_with \"ORDER#\"\n3. Query: Get all paid orders (any user) ‚Üí GSI1, PK=STATUS#PAID\n4. Query: Get all items in order ‚Üí PK=ORDER#order456, SK begins_with \"ITEM#\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Java code below shows how to talk to this table using the DynamoDB Enhanced Client, which maps your annotated Java classes to DynamoDB items. Notice that the \u003ccode\u003epk\u003c/code\u003e field holds compound keys like \u003ccode\u003eUSER#user123\u003c/code\u003e ‚Äî the \u003ccode\u003e#\u003c/code\u003e separator is a convention that keeps different entity types from accidentally colliding while still letting you query all entities of a type by prefix.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DynamoDB single-table access with DynamoDB Enhanced Client\n@DynamoDbBean\npublic class UserProfile {\n    private String pk;  // \"USER#user123\"\n    private String sk;  // \"PROFILE\"\n    private String name;\n    private String email;\n    // ...\n\n    @DynamoDbPartitionKey\n    public String getPk() { return pk; }\n\n    @DynamoDbSortKey\n    public String getSk() { return sk; }\n}\n\nDynamoDbEnhancedClient client = DynamoDbEnhancedClient.builder()\n    .dynamoDbClient(DynamoDbClient.create())\n    .build();\n\nDynamoDbTable\u0026#x3C;UserProfile\u003e table = client.table(\"app-table\", TableSchema.fromBean(UserProfile.class));\n\n// Put\ntable.putItem(userProfile);\n\n// Get\nUserProfile profile = table.getItem(Key.builder()\n    .partitionValue(\"USER#user123\")\n    .sortValue(\"PROFILE\")\n    .build());\n\n// Query all orders for user\nPageIterable\u0026#x3C;UserProfile\u003e orders = table.query(\n    QueryConditional.sortBeginsWith(Key.builder()\n        .partitionValue(\"USER#user123\")\n        .sortValue(\"ORDER#\")\n        .build())\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eDynamoDB Streams for event-driven architecture:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eDynamoDB Streams captures a time-ordered log of every write to your table, which you can process with a Lambda function. This turns your database into an event bus: a new order row appears, Streams fires an event, Lambda processes it. This pattern is how you build event-driven microservices without adding a separate message broker.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// DynamoDB Streams captures every write as an event\n// Lambda trigger: process changes in real-time\n\n@Override\npublic void handleRequest(DynamodbEvent event, Context context) {\n    for (DynamodbStreamRecord record : event.getRecords()) {\n        if (\"INSERT\".equals(record.getEventName())) {\n            Map\u0026#x3C;String, AttributeValue\u003e newItem = record.getDynamodb().getNewImage();\n            String pk = newItem.get(\"pk\").getS();\n\n            if (pk.startsWith(\"ORDER#\")) {\n                // New order created ‚Äî trigger fulfillment workflow\n                fulfillmentService.processOrder(pk.replace(\"ORDER#\", \"\"));\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWhen DynamoDB struggles:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAd-hoc queries (you don't know your access patterns upfront)\u003c/li\u003e\n\u003cli\u003eComplex joins across entity types (impossible without multiple round-trips)\u003c/li\u003e\n\u003cli\u003eLarge item sizes (400KB item limit)\u003c/li\u003e\n\u003cli\u003eACID transactions (supported but limited to 25 items, higher cost)\u003c/li\u003e\n\u003cli\u003eMigrations (no schema = no migration tooling, managing attribute evolution is manual)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eDecision Framework\u003c/h2\u003e\n\u003cp\u003eUse this flow when you are evaluating which database to pick for a new service or feature. The questions are ordered by the factors that most strongly constrain your choice ‚Äî start at the top and stop when you have a clear answer.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eQuestion 1: Do you have complex relationships and varied query patterns?\n  YES ‚Üí PostgreSQL\n\nQuestion 2: Is your data naturally document-shaped with evolving schema?\n  YES ‚Üí MongoDB\n\nQuestion 3: Do you need guaranteed \u0026#x3C; 10ms latency at 100K+ RPS with zero ops burden?\n  YES ‚Üí DynamoDB\n\nQuestion 4: Do you need ACID across multiple entities?\n  YES ‚Üí PostgreSQL (or MongoDB 4.0+ with caveats)\n\nQuestion 5: Do you expect 10x traffic spikes without pre-scaling?\n  YES ‚Üí DynamoDB (serverless on-demand mode handles this automatically)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Hybrid Architecture (Real World)\u003c/h2\u003e\n\u003cp\u003eIn practice, the most robust production systems don't pick one database and force everything through it. They use each database for what it does best, accepting the operational cost of running multiple systems in exchange for the performance and scalability benefits. Here is a realistic example of how these databases coexist in a mature e-commerce platform.\u003c/p\u003e\n\u003cp\u003eMost production systems use multiple databases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eE-commerce platform:\n\n  PostgreSQL:\n    - User accounts, authentication\n    - Products, inventory (complex relationships)\n    - Orders (ACID transactions for payment)\n\n  DynamoDB:\n    - Session storage (high throughput, simple key-value)\n    - Shopping cart (real-time, per-user state)\n    - Search history (write-heavy, simple structure)\n\n  Redis:\n    - Product catalog cache (hot reads)\n    - Rate limiting\n    - Real-time inventory counters\n\n  Elasticsearch:\n    - Product search with full-text + facets\n\n  ClickHouse:\n    - Analytics (revenue reports, funnel analysis)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo single database is the right answer. The polyglot persistence approach ‚Äî using each database for what it does best ‚Äî is the production-grade solution.\u003c/p\u003e\n\u003cp\u003eThe interview trap is picking one and defending it universally. The production mindset is asking: \"What are the actual access patterns?\" and then matching the tool to the requirement.\u003c/p\u003e\n","tableOfContents":[{"id":"the-core-trade-off-flexibility-vs-predictability","text":"The Core Trade-off: Flexibility vs Predictability","level":2},{"id":"postgresql-when-your-data-is-relational","text":"PostgreSQL: When Your Data Is Relational","level":2},{"id":"postgresql-strengths","text":"PostgreSQL Strengths","level":3},{"id":"mongodb-when-documents-are-natural","text":"MongoDB: When Documents Are Natural","level":2},{"id":"mongodb-strengths","text":"MongoDB Strengths","level":3},{"id":"dynamodb-when-you-need-predictable-scale","text":"DynamoDB: When You Need Predictable Scale","level":2},{"id":"single-table-design-the-key-concept","text":"Single-Table Design: The Key Concept","level":3},{"id":"decision-framework","text":"Decision Framework","level":2},{"id":"the-hybrid-architecture-real-world","text":"The Hybrid Architecture (Real World)","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring ‚Äî every node is equal, there's no primary, and data placement is determined by partit‚Ä¶"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before you‚Ä¶"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible ‚Äî rollback a bad deploy and your code is back to the previous version. Database schema changes are st‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"postgresql-mongodb-dynamodb-comparison"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>