<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Java 21 Virtual Threads: The End of Reactive Programming Boilerplate<!-- --> | CodeSprintPro</title><meta name="description" content="Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/java-virtual-threads-java21/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Java 21 Virtual Threads: The End of Reactive Programming Boilerplate" data-next-head=""/><meta property="og:description" content="Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/java-virtual-threads-java21/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-02-05" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Java" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="java21" data-next-head=""/><meta property="article:tag" content="concurrency" data-next-head=""/><meta property="article:tag" content="virtual threads" data-next-head=""/><meta property="article:tag" content="spring boot" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Java 21 Virtual Threads: The End of Reactive Programming Boilerplate" data-next-head=""/><meta name="twitter:description" content="Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java 21 Virtual Threads: The End of Reactive Programming Boilerplate","description":"Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-02-05","dateModified":"2025-02-05","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/java-virtual-threads-java21/"},"keywords":"java, java21, concurrency, virtual threads, spring boot","articleSection":"Java"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Java 21 Virtual Threads: The End of Reactive Programming Boilerplate</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Java</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Java 21 Virtual Threads: The End of Reactive Programming Boilerplate</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>¬∑</span><span>February 5, 2025</span><span>¬∑</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>12 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java21</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->concurrency</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->virtual threads</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->spring boot</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>For the past decade, Java developers dealing with high-concurrency IO-bound workloads faced an uncomfortable choice: write readable sequential code that does not scale, or write reactive/async code that scales but is notoriously difficult to debug and maintain. Project Loom, delivered in Java 21, eliminates this false dichotomy.</p>
<p>Virtual threads let you write blocking sequential code that scales to millions of concurrent operations ‚Äî no reactive frameworks, no callback chains, no <code>CompletableFuture</code> composition hell.</p>
<h2>Why Platform Threads Don't Scale</h2>
<p>A traditional Java <strong>platform thread</strong> maps 1:1 to an OS thread:</p>
<ul>
<li><strong>Stack size</strong>: 512KB to 1MB per thread</li>
<li><strong>Practical OS limit</strong>: ~10,000 threads before scheduling overhead dominates</li>
<li><strong>Blocking cost</strong>: A platform thread waiting on IO holds an OS thread ‚Äî doing nothing</li>
</ul>
<p>At 10,000 concurrent requests each waiting 50ms for a database query, you need 10,000 OS threads. That's 5-10 GB of stack memory. This is why servlet containers default to 200 threads ‚Äî not because engineers are lazy, but because threads are expensive.</p>
<p>The reactive model addresses this by making IO non-blocking (callbacks, Mono/Flux). The thread releases while IO waits, then a callback runs when IO completes. High throughput, low thread count ‚Äî but at serious complexity cost. To understand why that complexity matters, consider what a real concurrent fetch looks like once you leave the happy path. The following example demonstrates a parallel user profile build using <code>CompletableFuture</code> ‚Äî notice how much ceremony you need just to run three calls concurrently and handle a failure:</p>
<pre><code class="language-java">// CompletableFuture: parallel user profile fetch ‚Äî readable, but complex
public CompletableFuture&#x3C;UserProfile> buildProfile(String userId) {
    return CompletableFuture
        .supplyAsync(() -> userService.fetch(userId))
        .thenCombine(
            CompletableFuture.supplyAsync(() -> subscriptionService.fetch(userId)),
            (user, sub) -> {
                try {
                    List&#x3C;Product> recs = recommendationService.fetch(user.getPreferences());
                    return new UserProfile(user, sub, recs);
                } catch (Exception e) {
                    throw new CompletionException(e);
                }
            }
        )
        .exceptionally(e -> {
            log.error("Failed to build profile", e);
            return UserProfile.empty();
        });
}
</code></pre>
<p>Stack traces in reactive code show only the current stage. Thread-local context (MDC, security) breaks. The mental model is fundamentally different from sequential code.</p>
<h2>How Virtual Threads Work</h2>
<p>Before writing any code, it helps to understand the architectural difference between platform threads and virtual threads. Think of carrier threads as a small team of workers (one per CPU core), and virtual threads as a vast queue of tasks those workers pick up whenever they are free. When a virtual thread blocks on IO, the worker sets it aside and immediately picks up the next waiting task ‚Äî nothing is wasted.</p>
<pre><code>Platform Thread Model (1:1 with OS):

  VT1 ‚îÄ‚îÄ‚ñ∫ OS Thread 1 (blocked on DB, holding OS thread)
  VT2 ‚îÄ‚îÄ‚ñ∫ OS Thread 2 (blocked on HTTP call, holding OS thread)
  ...
  N limited by OS (typical max: 10K)

Virtual Thread Model (M:N with OS):

  VT1 ‚îÄ‚îê
  VT2 ‚îÄ‚î§ Scheduled onto ‚îÄ‚ñ∫ Carrier Thread 1 (= 1 OS thread)
  VT3 ‚îÄ‚î§                 ‚îÄ‚ñ∫ Carrier Thread 2 (= 1 OS thread)
  VTM ‚îÄ‚îò                 ‚îÄ‚ñ∫ Carrier Thread N (N = CPU cores)

  M can be millions ‚Äî each VT is ~1KB on heap (not stack)
</code></pre>
<p>When a virtual thread hits a blocking operation (JDBC query, HTTP call, <code>Thread.sleep()</code>), the JVM <strong>unmounts</strong> the virtual thread from the carrier: saves its stack to the heap and lets the carrier take another virtual thread. When the IO completes, the virtual thread is rescheduled ‚Äî mounted onto an available carrier. The OS never blocks.</p>
<p>This is why virtual threads can handle 100K concurrent connections with only 8 carrier threads (one per CPU core).</p>
<h2>Creating Virtual Threads</h2>
<p>Java 21 gives you three ways to create virtual threads, each suited to a different context. Choose the one that fits how your application is structured ‚Äî the <code>newVirtualThreadPerTaskExecutor</code> is the most practical choice for service-layer code because it integrates cleanly with <code>ExecutorService</code> and supports <code>Future</code>-based result collection:</p>
<pre><code class="language-java">// Method 1: Thread.ofVirtual()
Thread vt = Thread.ofVirtual()
    .name("handler-", 0)   // Named: handler-0, handler-1, ...
    .start(() -> handleRequest(request));

// Method 2: Virtual thread per task executor (most common in services)
try (ExecutorService exec = Executors.newVirtualThreadPerTaskExecutor()) {
    Future&#x3C;UserProfile> profileFuture = exec.submit(() -> buildProfile(userId));
    Future&#x3C;List&#x3C;Order>> ordersFuture = exec.submit(() -> fetchOrders(userId));

    // Both run on virtual threads concurrently
    // .get() blocks the calling virtual thread ‚Äî unmounts it while waiting
    UserProfile profile = profileFuture.get();
    List&#x3C;Order> orders = ordersFuture.get();
}

// Method 3: Thread factory (for integrating with existing APIs)
ThreadFactory vtFactory = Thread.ofVirtual().factory();
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(0, vtFactory);
</code></pre>
<p>Notice that <code>.get()</code> in Method 2 blocks the <em>calling</em> virtual thread, not the carrier ‚Äî so even your result-collection code is non-blocking at the OS level.</p>
<h2>Structured Concurrency: The Right Way to Fan Out</h2>
<p>Virtual threads solve the scalability problem, but running multiple concurrent tasks still requires coordination. Java 21 also introduces <code>StructuredTaskScope</code> ‚Äî a cleaner model for running concurrent subtasks that makes the relationship between parent and child tasks explicit and ensures no subtask can outlive its enclosing scope:</p>
<pre><code class="language-java">import java.util.concurrent.StructuredTaskScope;

// Old way: CompletableFuture fan-out
public UserDashboard buildDashboard(String userId) throws InterruptedException {
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        // All three tasks start immediately on virtual threads
        var userTask    = scope.fork(() -> userService.fetch(userId));
        var ordersTask  = scope.fork(() -> orderService.fetchRecent(userId, 10));
        var notifTask   = scope.fork(() -> notificationService.getUnread(userId));

        // Wait for all ‚Äî or cancel all if any fails (ShutdownOnFailure)
        scope.join();
        scope.throwIfFailed(e -> new DashboardBuildException("Failed to build dashboard", e));

        // All subtasks complete here ‚Äî results are available
        return new UserDashboard(
            userTask.get(),
            ordersTask.get(),
            notifTask.get()
        );
    }
    // Scope exit guarantees: no subtask outlives this block
    // Any exception = all subtasks cancelled
}
</code></pre>
<p><code>ShutdownOnFailure</code> is one scope policy. <code>ShutdownOnSuccess</code> cancels remaining tasks as soon as one succeeds ‚Äî useful for "first result wins" patterns. This is a natural fit for scenarios like reading from multiple replicas where you care only about getting the fastest response, not all of them:</p>
<pre><code class="language-java">// Race multiple read replicas ‚Äî use whichever responds first
public String readFromFastestReplica(String key) throws Exception {
    try (var scope = new StructuredTaskScope.ShutdownOnSuccess&#x3C;String>()) {
        scope.fork(() -> replica1.get(key));
        scope.fork(() -> replica2.get(key));
        scope.fork(() -> replica3.get(key));

        scope.join();
        return scope.result(); // First successful result
    }
}
</code></pre>
<p>The key insight here is that <code>ShutdownOnSuccess</code> automatically cancels the two slower replicas once the first result arrives, preventing wasted work and keeping resource consumption predictable.</p>
<h2>Spring Boot 3.2 Configuration</h2>
<p>Now that you understand how virtual threads work, enabling them in your Spring Boot application is deliberately straightforward. Virtual threads in Spring Boot 3.2+ require one line:</p>
<pre><code class="language-yaml"># application.yml
spring:
  threads:
    virtual:
      enabled: true
</code></pre>
<p>This switches Tomcat's thread pool to virtual threads. Each incoming HTTP request gets its own virtual thread. JDBC calls, Redis operations, and HTTP client calls block that virtual thread (not the carrier), freeing the carrier for other requests.</p>
<p>Once you've enabled virtual threads, you can verify they are actually being used at runtime by adding a small diagnostic endpoint. This is especially useful when first rolling out the change to catch any misconfiguration early:</p>
<pre><code class="language-java">@RestController
public class DiagnosticsController {

    @GetMapping("/thread-info")
    public Map&#x3C;String, Object> threadInfo() {
        Thread t = Thread.currentThread();
        return Map.of(
            "name", t.getName(),
            "isVirtual", t.isVirtual(),
            "isDaemon", t.isDaemon()
        );
    }
}
// Returns: {"name":"tomcat-handler-7","isVirtual":true,"isDaemon":true}
</code></pre>
<h2>Benchmark: Virtual Threads vs Platform Threads</h2>
<p>The following benchmark results illustrate the real-world impact of virtual threads. The test simulates a realistic IO-bound endpoint ‚Äî something like any database-backed REST API ‚Äî where threads spend most of their time waiting rather than computing:</p>
<pre><code>Environment: EC2 c5.2xlarge (8 vCPUs, 16GB RAM), JDK 21.0.2

Concurrency ‚îÇ Platform Threads (200 pool) ‚îÇ Virtual Threads
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       200  ‚îÇ  3,960 rps, p99: 52ms       ‚îÇ  3,980 rps, p99: 51ms
     1,000  ‚îÇ    980 rps, p99: 1.02s      ‚îÇ 19,600 rps, p99: 52ms
     5,000  ‚îÇ    timeout                  ‚îÇ 98,000 rps, p99: 53ms
    10,000  ‚îÇ    OOM / GC pressure        ‚îÇ 195,000 rps, p99: 55ms

Memory at 10,000 concurrent requests:
  Platform Threads: OOM (200 thread pool creates massive queue backlog)
  Virtual Threads: ~2.1 GB heap (10K stack frames at ~200KB each)
</code></pre>
<p>Below 200 concurrent requests, performance is identical. Above 200, platform threads queue up while virtual threads scale linearly with IO wait time.</p>
<h2>Pitfall 1: Pinning</h2>
<p>With the performance benefits clear, it's equally important to understand the one failure mode that can silently erase those gains. A virtual thread <strong>pins</strong> to its carrier when inside a <code>synchronized</code> block. While pinned, the carrier cannot take other virtual threads ‚Äî blocking the OS thread and recreating the exact problem virtual threads were designed to solve.</p>
<pre><code class="language-java">// PROBLEM: synchronized + IO = carrier thread blocks
public synchronized String fetchData(String key) {
    return database.query("SELECT value FROM cache WHERE key = ?", key);
    // Database call blocks inside synchronized ‚Üí pins carrier thread
}

// SOLUTION: Replace synchronized with ReentrantLock
private final ReentrantLock lock = new ReentrantLock();

public String fetchData(String key) {
    lock.lock(); // Virtual thread parks here (unmountable), not carrier
    try {
        return database.query("SELECT value FROM cache WHERE key = ?", key);
    } finally {
        lock.unlock();
    }
}

// BETTER SOLUTION: Minimize lock scope ‚Äî lock only for in-memory state
public String fetchData(String key) {
    // IO outside the lock
    String result = database.query("SELECT value FROM cache WHERE key = ?", key);

    // Lock only for the in-memory cache update
    synchronized (this) {
        localCache.put(key, result);
    }
    return result;
}
</code></pre>
<p>The "better solution" above illustrates a broader principle: separate IO from in-memory coordination. By doing the database call outside the lock, you ensure the virtual thread can unmount during the slow operation, and only hold the lock for the fast, in-memory cache update. Use the JVM's built-in diagnostics to detect any remaining pinning in your application:</p>
<pre><code class="language-bash"># JVM flag: print stack trace when virtual thread pins for >20ms
java -Djdk.tracePinnedThreads=full -jar app.jar

# During load test, watch for:
# VirtualThread[#48]/runnable@ForkJoinPool-1-worker-3
#     java.base/.../Unsafe.park (pinned due to monitor hold)
</code></pre>
<p><strong>Common libraries with pinning issues (as of 2025):</strong></p>
<ul>
<li><strong>HikariCP</strong> &#x3C; 5.1.0: Uses <code>synchronized</code> internally. Workaround: set carrier thread pool size to match HikariCP max pool size</li>
<li><strong>Some JDBC drivers</strong>: Oracle, older MySQL connectors</li>
<li><strong>Legacy code</strong> with <code>synchronized</code> on IO paths</li>
</ul>
<h2>Pitfall 2: Thread-Local State</h2>
<p>The second common pitfall involves how context is passed through the call stack. <code>ThreadLocal</code> works with virtual threads ‚Äî each virtual thread has its own <code>ThreadLocal</code> map. The subtle problem is that <code>ThreadLocal</code> values set in one request can leak to subsequent requests if not cleaned up.</p>
<pre><code class="language-java">// LEAK: ThreadLocal not cleared
public void processRequest(Request req) {
    MDC.put("requestId", req.getId());    // Sets ThreadLocal
    handleRequest(req);
    // Missing: MDC.clear()
    // If this virtual thread is reused, next request inherits old requestId
}

// SAFE: Always clean up in finally
public void processRequest(Request req) {
    try {
        MDC.put("requestId", req.getId());
        handleRequest(req);
    } finally {
        MDC.clear();
    }
}

// BEST for Java 21+: Use ScopedValue (replaces ThreadLocal for shared context)
static final ScopedValue&#x3C;RequestContext> REQUEST_CTX = ScopedValue.newInstance();

public void processRequest(Request req) {
    ScopedValue.runWhere(REQUEST_CTX, new RequestContext(req), () -> {
        handleRequest(req);
    }); // ScopedValue automatically cleaned up when runWhere exits
}

private void deepInCallStack() {
    // Access from anywhere without passing as parameter
    RequestContext ctx = REQUEST_CTX.get();
    MDC.put("requestId", ctx.getRequestId());
}
</code></pre>
<p><code>ScopedValue</code> is the long-term solution: it is immutable, automatically scoped to the <code>runWhere</code> block, and eliminates the cleanup burden entirely. Prefer it over <code>ThreadLocal</code> for any new code written on Java 21+.</p>
<h2>When NOT to Use Virtual Threads</h2>
<p>Virtual threads are a powerful tool, but they are not a universal replacement for every concurrency approach. Knowing the boundaries of their usefulness is as important as knowing how to enable them.</p>
<ol>
<li>
<p><strong>CPU-bound work</strong>: Virtual threads only help when threads park (wait for IO). CPU-bound tasks never park ‚Äî they keep the carrier busy. Use <code>ForkJoinPool</code> for CPU-intensive work.</p>
</li>
<li>
<p><strong>Very high-frequency, very-short tasks</strong>: Nanosecond-duration tasks where virtual thread scheduling overhead dominates. Prefer <code>CompletableFuture</code> with a bounded pool.</p>
</li>
<li>
<p><strong>Libraries with extensive native pinning</strong>: If critical paths run through JNI code that holds monitors, virtual threads cannot help.</p>
</li>
</ol>
<p>For CPU-bound workloads, parallel streams backed by <code>ForkJoinPool</code> remain the right tool ‚Äî they keep all cores busy with actual computation rather than waiting on IO:</p>
<pre><code class="language-java">// For CPU-bound parallel work, still use ForkJoinPool or parallel streams:
List&#x3C;Result> results = items.parallelStream()
    .map(this::expensiveComputation) // ForkJoinPool, not virtual threads
    .collect(Collectors.toList());
</code></pre>
<h2>Migration Checklist</h2>
<p>With the concepts and pitfalls covered, here is a practical, step-by-step checklist for migrating an existing Spring Boot application to virtual threads. Follow the steps in order ‚Äî enabling virtual threads first and then diagnosing pinning issues is far more productive than auditing every <code>synchronized</code> block upfront:</p>
<pre><code class="language-bash"># 1. Upgrade
#    Java: 21+
#    Spring Boot: 3.2+
#    Maven/Gradle: latest

# 2. Enable virtual threads (one line)
echo "spring.threads.virtual.enabled=true" >> application.yml

# 3. Detect pinning
java -Djdk.tracePinnedThreads=full -jar app.jar
# Run load test, watch logs for pinning events

# 4. Replace synchronized+IO with ReentrantLock
grep -r "synchronized" src/main/java/ | grep -i "repository\|service\|dao"

# 5. Upgrade HikariCP to 5.1.0+ (reduced synchronized blocks)
# Or set: maximumPoolSize = expected concurrent DB operations (not threads)

# 6. Remove artificial thread pool limits
# Remove from application.properties:
#   server.tomcat.threads.max=200
#   spring.task.execution.pool.max-size=50
# (Virtual threads don't need these ‚Äî they scale automatically)

# 7. Load test and compare p99 latency at high concurrency
</code></pre>
<p>Virtual threads represent a paradigm shift for Java. For the first time, high-concurrency IO-bound applications can be written with simple, sequential, debuggable code ‚Äî and still achieve throughput that previously required reactive frameworks. The migration cost is near-zero for Spring Boot applications. The remaining challenge is library adoption, and that is improving rapidly with each JDK release.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">üìö</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Masterclass ‚Äî Udemy</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Best Seller</span></div><p class="text-xs text-gray-600">Comprehensive Java course covering Java 17+, OOP, concurrency, and modern APIs.</p></div><a href="https://www.udemy.com/course/java-the-complete-java-developer-course/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Effective Java, 3rd Edition</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Must Read</span></div><p class="text-xs text-gray-600">Joshua Bloch&#x27;s classic guide to writing clear, correct, and efficient Java code.</p></div><a href="https://amzn.to/3RxIpuB" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Java Concurrency in Practice</span></div><p class="text-xs text-gray-600">The authoritative book on writing thread-safe, concurrent Java programs.</p></div><a href="https://amzn.to/3Rx3xM4" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> ‚Üí</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Java%2021%20Virtual%20Threads%3A%20The%20End%20of%20Reactive%20Programming%20Boilerplate&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-virtual-threads-java21%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Fjava-virtual-threads-java21%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#why-platform-threads-dont-scale" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Why Platform Threads Don&#x27;t Scale</a></li><li class=""><a href="#how-virtual-threads-work" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">How Virtual Threads Work</a></li><li class=""><a href="#creating-virtual-threads" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Creating Virtual Threads</a></li><li class=""><a href="#structured-concurrency-the-right-way-to-fan-out" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Structured Concurrency: The Right Way to Fan Out</a></li><li class=""><a href="#spring-boot-32-configuration" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Spring Boot 3.2 Configuration</a></li><li class=""><a href="#benchmark-virtual-threads-vs-platform-threads" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Benchmark: Virtual Threads vs Platform Threads</a></li><li class=""><a href="#pitfall-1-pinning" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pitfall 1: Pinning</a></li><li class=""><a href="#pitfall-2-thread-local-state" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Pitfall 2: Thread-Local State</a></li><li class=""><a href="#when-not-to-use-virtual-threads" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">When NOT to Use Virtual Threads</a></li><li class=""><a href="#migration-checklist" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Migration Checklist</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/java-concurrency-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era&#x27;s patterns still exist in production codebases. Understanding all th‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jul 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->concurrency</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->completablefuture</span></div></article></a><a href="/blog/java-memory-management-deep-dive/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Java Memory Management Deep Dive: Heap, GC, and Production Tuning</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Java&#x27;s garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->java</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jvm</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->garbage collection</span></div></article></a><a href="/blog/spring-security-oauth2-jwt/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-orange-100 text-orange-700">Java</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Spring Security OAuth2 and JWT: Production Implementation Guide</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 3, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>7 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->spring security</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->oauth2</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->jwt</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">‚Üê Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS ‚Äî by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">¬© <!-- -->2026<!-- --> CodeSprintPro ¬∑ Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js ¬∑ TailwindCSS ¬∑ Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java 21 Virtual Threads: The End of Reactive Programming Boilerplate","description":"Java 21 virtual threads let you write simple blocking code that scales like async. Understand how they work under the hood, when to use them, and what pitfalls to avoid.","date":"2025-02-05","category":"Java","tags":["java","java21","concurrency","virtual threads","spring boot"],"featured":true,"affiliateSection":"java-courses","slug":"java-virtual-threads-java21","readingTime":"12 min read","excerpt":"For the past decade, Java developers dealing with high-concurrency IO-bound workloads faced an uncomfortable choice: write readable sequential code that does not scale, or write reactive/async code that scales but is not‚Ä¶","contentHtml":"\u003cp\u003eFor the past decade, Java developers dealing with high-concurrency IO-bound workloads faced an uncomfortable choice: write readable sequential code that does not scale, or write reactive/async code that scales but is notoriously difficult to debug and maintain. Project Loom, delivered in Java 21, eliminates this false dichotomy.\u003c/p\u003e\n\u003cp\u003eVirtual threads let you write blocking sequential code that scales to millions of concurrent operations ‚Äî no reactive frameworks, no callback chains, no \u003ccode\u003eCompletableFuture\u003c/code\u003e composition hell.\u003c/p\u003e\n\u003ch2\u003eWhy Platform Threads Don't Scale\u003c/h2\u003e\n\u003cp\u003eA traditional Java \u003cstrong\u003eplatform thread\u003c/strong\u003e maps 1:1 to an OS thread:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStack size\u003c/strong\u003e: 512KB to 1MB per thread\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePractical OS limit\u003c/strong\u003e: ~10,000 threads before scheduling overhead dominates\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBlocking cost\u003c/strong\u003e: A platform thread waiting on IO holds an OS thread ‚Äî doing nothing\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAt 10,000 concurrent requests each waiting 50ms for a database query, you need 10,000 OS threads. That's 5-10 GB of stack memory. This is why servlet containers default to 200 threads ‚Äî not because engineers are lazy, but because threads are expensive.\u003c/p\u003e\n\u003cp\u003eThe reactive model addresses this by making IO non-blocking (callbacks, Mono/Flux). The thread releases while IO waits, then a callback runs when IO completes. High throughput, low thread count ‚Äî but at serious complexity cost. To understand why that complexity matters, consider what a real concurrent fetch looks like once you leave the happy path. The following example demonstrates a parallel user profile build using \u003ccode\u003eCompletableFuture\u003c/code\u003e ‚Äî notice how much ceremony you need just to run three calls concurrently and handle a failure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// CompletableFuture: parallel user profile fetch ‚Äî readable, but complex\npublic CompletableFuture\u0026#x3C;UserProfile\u003e buildProfile(String userId) {\n    return CompletableFuture\n        .supplyAsync(() -\u003e userService.fetch(userId))\n        .thenCombine(\n            CompletableFuture.supplyAsync(() -\u003e subscriptionService.fetch(userId)),\n            (user, sub) -\u003e {\n                try {\n                    List\u0026#x3C;Product\u003e recs = recommendationService.fetch(user.getPreferences());\n                    return new UserProfile(user, sub, recs);\n                } catch (Exception e) {\n                    throw new CompletionException(e);\n                }\n            }\n        )\n        .exceptionally(e -\u003e {\n            log.error(\"Failed to build profile\", e);\n            return UserProfile.empty();\n        });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStack traces in reactive code show only the current stage. Thread-local context (MDC, security) breaks. The mental model is fundamentally different from sequential code.\u003c/p\u003e\n\u003ch2\u003eHow Virtual Threads Work\u003c/h2\u003e\n\u003cp\u003eBefore writing any code, it helps to understand the architectural difference between platform threads and virtual threads. Think of carrier threads as a small team of workers (one per CPU core), and virtual threads as a vast queue of tasks those workers pick up whenever they are free. When a virtual thread blocks on IO, the worker sets it aside and immediately picks up the next waiting task ‚Äî nothing is wasted.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlatform Thread Model (1:1 with OS):\n\n  VT1 ‚îÄ‚îÄ‚ñ∫ OS Thread 1 (blocked on DB, holding OS thread)\n  VT2 ‚îÄ‚îÄ‚ñ∫ OS Thread 2 (blocked on HTTP call, holding OS thread)\n  ...\n  N limited by OS (typical max: 10K)\n\nVirtual Thread Model (M:N with OS):\n\n  VT1 ‚îÄ‚îê\n  VT2 ‚îÄ‚î§ Scheduled onto ‚îÄ‚ñ∫ Carrier Thread 1 (= 1 OS thread)\n  VT3 ‚îÄ‚î§                 ‚îÄ‚ñ∫ Carrier Thread 2 (= 1 OS thread)\n  VTM ‚îÄ‚îò                 ‚îÄ‚ñ∫ Carrier Thread N (N = CPU cores)\n\n  M can be millions ‚Äî each VT is ~1KB on heap (not stack)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen a virtual thread hits a blocking operation (JDBC query, HTTP call, \u003ccode\u003eThread.sleep()\u003c/code\u003e), the JVM \u003cstrong\u003eunmounts\u003c/strong\u003e the virtual thread from the carrier: saves its stack to the heap and lets the carrier take another virtual thread. When the IO completes, the virtual thread is rescheduled ‚Äî mounted onto an available carrier. The OS never blocks.\u003c/p\u003e\n\u003cp\u003eThis is why virtual threads can handle 100K concurrent connections with only 8 carrier threads (one per CPU core).\u003c/p\u003e\n\u003ch2\u003eCreating Virtual Threads\u003c/h2\u003e\n\u003cp\u003eJava 21 gives you three ways to create virtual threads, each suited to a different context. Choose the one that fits how your application is structured ‚Äî the \u003ccode\u003enewVirtualThreadPerTaskExecutor\u003c/code\u003e is the most practical choice for service-layer code because it integrates cleanly with \u003ccode\u003eExecutorService\u003c/code\u003e and supports \u003ccode\u003eFuture\u003c/code\u003e-based result collection:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Method 1: Thread.ofVirtual()\nThread vt = Thread.ofVirtual()\n    .name(\"handler-\", 0)   // Named: handler-0, handler-1, ...\n    .start(() -\u003e handleRequest(request));\n\n// Method 2: Virtual thread per task executor (most common in services)\ntry (ExecutorService exec = Executors.newVirtualThreadPerTaskExecutor()) {\n    Future\u0026#x3C;UserProfile\u003e profileFuture = exec.submit(() -\u003e buildProfile(userId));\n    Future\u0026#x3C;List\u0026#x3C;Order\u003e\u003e ordersFuture = exec.submit(() -\u003e fetchOrders(userId));\n\n    // Both run on virtual threads concurrently\n    // .get() blocks the calling virtual thread ‚Äî unmounts it while waiting\n    UserProfile profile = profileFuture.get();\n    List\u0026#x3C;Order\u003e orders = ordersFuture.get();\n}\n\n// Method 3: Thread factory (for integrating with existing APIs)\nThreadFactory vtFactory = Thread.ofVirtual().factory();\nScheduledExecutorService scheduler = Executors.newScheduledThreadPool(0, vtFactory);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that \u003ccode\u003e.get()\u003c/code\u003e in Method 2 blocks the \u003cem\u003ecalling\u003c/em\u003e virtual thread, not the carrier ‚Äî so even your result-collection code is non-blocking at the OS level.\u003c/p\u003e\n\u003ch2\u003eStructured Concurrency: The Right Way to Fan Out\u003c/h2\u003e\n\u003cp\u003eVirtual threads solve the scalability problem, but running multiple concurrent tasks still requires coordination. Java 21 also introduces \u003ccode\u003eStructuredTaskScope\u003c/code\u003e ‚Äî a cleaner model for running concurrent subtasks that makes the relationship between parent and child tasks explicit and ensures no subtask can outlive its enclosing scope:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.StructuredTaskScope;\n\n// Old way: CompletableFuture fan-out\npublic UserDashboard buildDashboard(String userId) throws InterruptedException {\n    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n        // All three tasks start immediately on virtual threads\n        var userTask    = scope.fork(() -\u003e userService.fetch(userId));\n        var ordersTask  = scope.fork(() -\u003e orderService.fetchRecent(userId, 10));\n        var notifTask   = scope.fork(() -\u003e notificationService.getUnread(userId));\n\n        // Wait for all ‚Äî or cancel all if any fails (ShutdownOnFailure)\n        scope.join();\n        scope.throwIfFailed(e -\u003e new DashboardBuildException(\"Failed to build dashboard\", e));\n\n        // All subtasks complete here ‚Äî results are available\n        return new UserDashboard(\n            userTask.get(),\n            ordersTask.get(),\n            notifTask.get()\n        );\n    }\n    // Scope exit guarantees: no subtask outlives this block\n    // Any exception = all subtasks cancelled\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eShutdownOnFailure\u003c/code\u003e is one scope policy. \u003ccode\u003eShutdownOnSuccess\u003c/code\u003e cancels remaining tasks as soon as one succeeds ‚Äî useful for \"first result wins\" patterns. This is a natural fit for scenarios like reading from multiple replicas where you care only about getting the fastest response, not all of them:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Race multiple read replicas ‚Äî use whichever responds first\npublic String readFromFastestReplica(String key) throws Exception {\n    try (var scope = new StructuredTaskScope.ShutdownOnSuccess\u0026#x3C;String\u003e()) {\n        scope.fork(() -\u003e replica1.get(key));\n        scope.fork(() -\u003e replica2.get(key));\n        scope.fork(() -\u003e replica3.get(key));\n\n        scope.join();\n        return scope.result(); // First successful result\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key insight here is that \u003ccode\u003eShutdownOnSuccess\u003c/code\u003e automatically cancels the two slower replicas once the first result arrives, preventing wasted work and keeping resource consumption predictable.\u003c/p\u003e\n\u003ch2\u003eSpring Boot 3.2 Configuration\u003c/h2\u003e\n\u003cp\u003eNow that you understand how virtual threads work, enabling them in your Spring Boot application is deliberately straightforward. Virtual threads in Spring Boot 3.2+ require one line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# application.yml\nspring:\n  threads:\n    virtual:\n      enabled: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis switches Tomcat's thread pool to virtual threads. Each incoming HTTP request gets its own virtual thread. JDBC calls, Redis operations, and HTTP client calls block that virtual thread (not the carrier), freeing the carrier for other requests.\u003c/p\u003e\n\u003cp\u003eOnce you've enabled virtual threads, you can verify they are actually being used at runtime by adding a small diagnostic endpoint. This is especially useful when first rolling out the change to catch any misconfiguration early:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RestController\npublic class DiagnosticsController {\n\n    @GetMapping(\"/thread-info\")\n    public Map\u0026#x3C;String, Object\u003e threadInfo() {\n        Thread t = Thread.currentThread();\n        return Map.of(\n            \"name\", t.getName(),\n            \"isVirtual\", t.isVirtual(),\n            \"isDaemon\", t.isDaemon()\n        );\n    }\n}\n// Returns: {\"name\":\"tomcat-handler-7\",\"isVirtual\":true,\"isDaemon\":true}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eBenchmark: Virtual Threads vs Platform Threads\u003c/h2\u003e\n\u003cp\u003eThe following benchmark results illustrate the real-world impact of virtual threads. The test simulates a realistic IO-bound endpoint ‚Äî something like any database-backed REST API ‚Äî where threads spend most of their time waiting rather than computing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEnvironment: EC2 c5.2xlarge (8 vCPUs, 16GB RAM), JDK 21.0.2\n\nConcurrency ‚îÇ Platform Threads (200 pool) ‚îÇ Virtual Threads\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       200  ‚îÇ  3,960 rps, p99: 52ms       ‚îÇ  3,980 rps, p99: 51ms\n     1,000  ‚îÇ    980 rps, p99: 1.02s      ‚îÇ 19,600 rps, p99: 52ms\n     5,000  ‚îÇ    timeout                  ‚îÇ 98,000 rps, p99: 53ms\n    10,000  ‚îÇ    OOM / GC pressure        ‚îÇ 195,000 rps, p99: 55ms\n\nMemory at 10,000 concurrent requests:\n  Platform Threads: OOM (200 thread pool creates massive queue backlog)\n  Virtual Threads: ~2.1 GB heap (10K stack frames at ~200KB each)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBelow 200 concurrent requests, performance is identical. Above 200, platform threads queue up while virtual threads scale linearly with IO wait time.\u003c/p\u003e\n\u003ch2\u003ePitfall 1: Pinning\u003c/h2\u003e\n\u003cp\u003eWith the performance benefits clear, it's equally important to understand the one failure mode that can silently erase those gains. A virtual thread \u003cstrong\u003epins\u003c/strong\u003e to its carrier when inside a \u003ccode\u003esynchronized\u003c/code\u003e block. While pinned, the carrier cannot take other virtual threads ‚Äî blocking the OS thread and recreating the exact problem virtual threads were designed to solve.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// PROBLEM: synchronized + IO = carrier thread blocks\npublic synchronized String fetchData(String key) {\n    return database.query(\"SELECT value FROM cache WHERE key = ?\", key);\n    // Database call blocks inside synchronized ‚Üí pins carrier thread\n}\n\n// SOLUTION: Replace synchronized with ReentrantLock\nprivate final ReentrantLock lock = new ReentrantLock();\n\npublic String fetchData(String key) {\n    lock.lock(); // Virtual thread parks here (unmountable), not carrier\n    try {\n        return database.query(\"SELECT value FROM cache WHERE key = ?\", key);\n    } finally {\n        lock.unlock();\n    }\n}\n\n// BETTER SOLUTION: Minimize lock scope ‚Äî lock only for in-memory state\npublic String fetchData(String key) {\n    // IO outside the lock\n    String result = database.query(\"SELECT value FROM cache WHERE key = ?\", key);\n\n    // Lock only for the in-memory cache update\n    synchronized (this) {\n        localCache.put(key, result);\n    }\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \"better solution\" above illustrates a broader principle: separate IO from in-memory coordination. By doing the database call outside the lock, you ensure the virtual thread can unmount during the slow operation, and only hold the lock for the fast, in-memory cache update. Use the JVM's built-in diagnostics to detect any remaining pinning in your application:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# JVM flag: print stack trace when virtual thread pins for \u003e20ms\njava -Djdk.tracePinnedThreads=full -jar app.jar\n\n# During load test, watch for:\n# VirtualThread[#48]/runnable@ForkJoinPool-1-worker-3\n#     java.base/.../Unsafe.park (pinned due to monitor hold)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCommon libraries with pinning issues (as of 2025):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHikariCP\u003c/strong\u003e \u0026#x3C; 5.1.0: Uses \u003ccode\u003esynchronized\u003c/code\u003e internally. Workaround: set carrier thread pool size to match HikariCP max pool size\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSome JDBC drivers\u003c/strong\u003e: Oracle, older MySQL connectors\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLegacy code\u003c/strong\u003e with \u003ccode\u003esynchronized\u003c/code\u003e on IO paths\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePitfall 2: Thread-Local State\u003c/h2\u003e\n\u003cp\u003eThe second common pitfall involves how context is passed through the call stack. \u003ccode\u003eThreadLocal\u003c/code\u003e works with virtual threads ‚Äî each virtual thread has its own \u003ccode\u003eThreadLocal\u003c/code\u003e map. The subtle problem is that \u003ccode\u003eThreadLocal\u003c/code\u003e values set in one request can leak to subsequent requests if not cleaned up.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// LEAK: ThreadLocal not cleared\npublic void processRequest(Request req) {\n    MDC.put(\"requestId\", req.getId());    // Sets ThreadLocal\n    handleRequest(req);\n    // Missing: MDC.clear()\n    // If this virtual thread is reused, next request inherits old requestId\n}\n\n// SAFE: Always clean up in finally\npublic void processRequest(Request req) {\n    try {\n        MDC.put(\"requestId\", req.getId());\n        handleRequest(req);\n    } finally {\n        MDC.clear();\n    }\n}\n\n// BEST for Java 21+: Use ScopedValue (replaces ThreadLocal for shared context)\nstatic final ScopedValue\u0026#x3C;RequestContext\u003e REQUEST_CTX = ScopedValue.newInstance();\n\npublic void processRequest(Request req) {\n    ScopedValue.runWhere(REQUEST_CTX, new RequestContext(req), () -\u003e {\n        handleRequest(req);\n    }); // ScopedValue automatically cleaned up when runWhere exits\n}\n\nprivate void deepInCallStack() {\n    // Access from anywhere without passing as parameter\n    RequestContext ctx = REQUEST_CTX.get();\n    MDC.put(\"requestId\", ctx.getRequestId());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eScopedValue\u003c/code\u003e is the long-term solution: it is immutable, automatically scoped to the \u003ccode\u003erunWhere\u003c/code\u003e block, and eliminates the cleanup burden entirely. Prefer it over \u003ccode\u003eThreadLocal\u003c/code\u003e for any new code written on Java 21+.\u003c/p\u003e\n\u003ch2\u003eWhen NOT to Use Virtual Threads\u003c/h2\u003e\n\u003cp\u003eVirtual threads are a powerful tool, but they are not a universal replacement for every concurrency approach. Knowing the boundaries of their usefulness is as important as knowing how to enable them.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCPU-bound work\u003c/strong\u003e: Virtual threads only help when threads park (wait for IO). CPU-bound tasks never park ‚Äî they keep the carrier busy. Use \u003ccode\u003eForkJoinPool\u003c/code\u003e for CPU-intensive work.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eVery high-frequency, very-short tasks\u003c/strong\u003e: Nanosecond-duration tasks where virtual thread scheduling overhead dominates. Prefer \u003ccode\u003eCompletableFuture\u003c/code\u003e with a bounded pool.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eLibraries with extensive native pinning\u003c/strong\u003e: If critical paths run through JNI code that holds monitors, virtual threads cannot help.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor CPU-bound workloads, parallel streams backed by \u003ccode\u003eForkJoinPool\u003c/code\u003e remain the right tool ‚Äî they keep all cores busy with actual computation rather than waiting on IO:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// For CPU-bound parallel work, still use ForkJoinPool or parallel streams:\nList\u0026#x3C;Result\u003e results = items.parallelStream()\n    .map(this::expensiveComputation) // ForkJoinPool, not virtual threads\n    .collect(Collectors.toList());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMigration Checklist\u003c/h2\u003e\n\u003cp\u003eWith the concepts and pitfalls covered, here is a practical, step-by-step checklist for migrating an existing Spring Boot application to virtual threads. Follow the steps in order ‚Äî enabling virtual threads first and then diagnosing pinning issues is far more productive than auditing every \u003ccode\u003esynchronized\u003c/code\u003e block upfront:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 1. Upgrade\n#    Java: 21+\n#    Spring Boot: 3.2+\n#    Maven/Gradle: latest\n\n# 2. Enable virtual threads (one line)\necho \"spring.threads.virtual.enabled=true\" \u003e\u003e application.yml\n\n# 3. Detect pinning\njava -Djdk.tracePinnedThreads=full -jar app.jar\n# Run load test, watch logs for pinning events\n\n# 4. Replace synchronized+IO with ReentrantLock\ngrep -r \"synchronized\" src/main/java/ | grep -i \"repository\\|service\\|dao\"\n\n# 5. Upgrade HikariCP to 5.1.0+ (reduced synchronized blocks)\n# Or set: maximumPoolSize = expected concurrent DB operations (not threads)\n\n# 6. Remove artificial thread pool limits\n# Remove from application.properties:\n#   server.tomcat.threads.max=200\n#   spring.task.execution.pool.max-size=50\n# (Virtual threads don't need these ‚Äî they scale automatically)\n\n# 7. Load test and compare p99 latency at high concurrency\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVirtual threads represent a paradigm shift for Java. For the first time, high-concurrency IO-bound applications can be written with simple, sequential, debuggable code ‚Äî and still achieve throughput that previously required reactive frameworks. The migration cost is near-zero for Spring Boot applications. The remaining challenge is library adoption, and that is improving rapidly with each JDK release.\u003c/p\u003e\n","tableOfContents":[{"id":"why-platform-threads-dont-scale","text":"Why Platform Threads Don't Scale","level":2},{"id":"how-virtual-threads-work","text":"How Virtual Threads Work","level":2},{"id":"creating-virtual-threads","text":"Creating Virtual Threads","level":2},{"id":"structured-concurrency-the-right-way-to-fan-out","text":"Structured Concurrency: The Right Way to Fan Out","level":2},{"id":"spring-boot-32-configuration","text":"Spring Boot 3.2 Configuration","level":2},{"id":"benchmark-virtual-threads-vs-platform-threads","text":"Benchmark: Virtual Threads vs Platform Threads","level":2},{"id":"pitfall-1-pinning","text":"Pitfall 1: Pinning","level":2},{"id":"pitfall-2-thread-local-state","text":"Pitfall 2: Thread-Local State","level":2},{"id":"when-not-to-use-virtual-threads","text":"When NOT to Use Virtual Threads","level":2},{"id":"migration-checklist","text":"Migration Checklist","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th‚Ä¶"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin‚Ä¶"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength ‚Äî and its complexity. Misconfigured security is worse than no security, because it give‚Ä¶"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"java-virtual-threads-java21"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>