<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL<!-- --> | CodeSprintPro</title><meta name="description" content="Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications." data-next-head=""/><meta name="author" content="Sachin Sarawgi" data-next-head=""/><link rel="canonical" href="https://codesprintpro.com/blog/elasticsearch-deep-dive/" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:title" content="Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL" data-next-head=""/><meta property="og:description" content="Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications." data-next-head=""/><meta property="og:url" content="https://codesprintpro.com/blog/elasticsearch-deep-dive/" data-next-head=""/><meta property="og:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><meta property="og:site_name" content="CodeSprintPro" data-next-head=""/><meta property="article:published_time" content="2025-02-24" data-next-head=""/><meta property="article:author" content="Sachin Sarawgi" data-next-head=""/><meta property="article:section" content="Databases" data-next-head=""/><meta property="article:tag" content="elasticsearch" data-next-head=""/><meta property="article:tag" content="search" data-next-head=""/><meta property="article:tag" content="inverted index" data-next-head=""/><meta property="article:tag" content="java" data-next-head=""/><meta property="article:tag" content="databases" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL" data-next-head=""/><meta name="twitter:description" content="Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications." data-next-head=""/><meta name="twitter:image" content="https://codesprintpro.com/images/og-default.jpg" data-next-head=""/><script type="application/ld+json" data-next-head="">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL","description":"Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications.","image":"https://codesprintpro.com/images/og-default.jpg","datePublished":"2025-02-24","dateModified":"2025-02-24","author":{"@type":"Person","name":"Sachin Sarawgi","url":"https://codesprintpro.com","sameAs":["https://www.linkedin.com/in/sachin-sarawgi/","https://github.com/codesprintpro","https://medium.com/@codesprintpro"]},"publisher":{"@type":"Organization","name":"CodeSprintPro","url":"https://codesprintpro.com","logo":{"@type":"ImageObject","url":"https://codesprintpro.com/favicon/favicon-96x96.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codesprintpro.com/blog/elasticsearch-deep-dive/"},"keywords":"elasticsearch, search, inverted index, java, databases","articleSection":"Databases"}</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/735d4373f93910ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/735d4373f93910ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-11a4a2dad04962bb.js" defer=""></script><script src="/_next/static/chunks/framework-1ce91eb6f9ecda85.js" defer=""></script><script src="/_next/static/chunks/main-c7f4109f032d7b6e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1a852bd9e38c70ab.js" defer=""></script><script src="/_next/static/chunks/730-db7827467817f501.js" defer=""></script><script src="/_next/static/chunks/90-1cd4611704c3dbe0.js" defer=""></script><script src="/_next/static/chunks/440-29f4b99a44e744b5.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0c1b14a33d5e05ee.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_buildManifest.js" defer=""></script><script src="/_next/static/rpFn_jslWZ9qPkJwor7RD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="__className_f367f3"><div class="min-h-screen bg-white"><nav class="fixed w-full z-50 transition-all duration-300 bg-white shadow-md" style="transform:translateY(-100px) translateZ(0)"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><a class="text-xl font-bold transition-colors text-blue-600" href="/">CodeSprintPro</a><div class="hidden md:flex items-center space-x-8"><a class="text-sm font-medium transition-colors text-blue-600" href="/blog/">Blog</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#about">About</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#portfolio">Portfolio</a><a class="text-sm font-medium transition-colors text-gray-600 hover:text-blue-600" href="/#contact">Contact</a></div><button class="md:hidden p-2 rounded-lg transition-colors hover:bg-gray-100 text-gray-600" aria-label="Toggle mobile menu"><svg class="w-6 h-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></nav><div class="pt-20"><div class="bg-gradient-to-br from-gray-900 to-blue-950 py-16"><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl"><nav class="flex items-center gap-2 text-sm text-gray-400 mb-6"><a class="hover:text-white transition-colors" href="/">Home</a><span>/</span><a class="hover:text-white transition-colors" href="/blog/">Blog</a><span>/</span><span class="text-gray-300 truncate max-w-xs">Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL</span></nav><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full bg-blue-100 text-blue-700 mb-4">Databases</span><h1 class="text-3xl md:text-5xl font-bold text-white mb-4 leading-tight">Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL</h1><p class="text-gray-300 text-lg mb-6 max-w-3xl">Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications.</p><div class="flex flex-wrap items-center gap-4 text-gray-400 text-sm"><span class="flex items-center gap-1.5"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>Sachin Sarawgi</span><span>Â·</span><span>February 24, 2025</span><span>Â·</span><span class="flex items-center gap-1"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>11 min read</span></div><div class="flex flex-wrap gap-2 mt-4"><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->elasticsearch</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->search</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->inverted index</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->java</span><span class="text-xs text-gray-400 bg-gray-800 px-2 py-1 rounded">#<!-- -->databases</span></div></div></div><div class="container mx-auto px-4 sm:px-6 lg:px-8 max-w-5xl py-12"><div class="flex gap-12"><div class="flex-1 min-w-0"><article class="prose prose-lg max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-h2:text-2xl prose-h2:mt-10 prose-h2:mb-4 prose-h3:text-xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline prose-strong:text-gray-900 prose-blockquote:border-blue-600 prose-blockquote:text-gray-600 prose-code:text-blue-700 prose-code:bg-blue-50 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none prose-pre:rounded-xl prose-img:rounded-xl prose-img:shadow-md prose-table:text-sm prose-th:bg-gray-100 prose-th:text-gray-700"><p>Most engineers use Elasticsearch as a black box: index some JSON, run a search, get results. When search quality is poor or performance degrades at scale, they reach for random settings without understanding why. This article explains the internals that make Elasticsearch work â€” and why your index design decisions matter enormously.</p>
<h2>How Elasticsearch Stores Data</h2>
<p>Elasticsearch is built on Apache Lucene. The core data structure is the <strong>inverted index</strong> â€” a mapping from terms to the documents containing them.</p>
<p>Think of an inverted index like the index at the back of a textbook. Instead of reading every page to find where "Kafka" is mentioned, you look up "Kafka" in the index and get a list of page numbers. Elasticsearch builds this structure automatically when you index a document, analyzing text into individual terms and recording which documents contain each term. This is why full-text search in Elasticsearch is so fast â€” it never has to scan document content at query time.</p>
<pre><code>Documents:
  Doc 1: "Kafka is a distributed streaming platform"
  Doc 2: "Redis is an in-memory data structure store"
  Doc 3: "Kafka and Redis are both used in distributed systems"

Inverted Index (simplified):
  Term        â†’ Document IDs (posting list)
  "kafka"     â†’ [1, 3]
  "redis"     â†’ [2, 3]
  "distributed" â†’ [1, 3]
  "streaming" â†’ [1]
  "memory"    â†’ [2]
  "systems"   â†’ [3]

Query: "kafka distributed"
  â†’ Find docs with "kafka": {1, 3}
  â†’ Find docs with "distributed": {1, 3}
  â†’ Intersection: {1, 3}
  â†’ Score by BM25 relevance (term frequency, inverse document frequency)
  â†’ Return Doc 1 (more relevant: both terms in shorter text)
</code></pre>
<p>Each posting list also stores:</p>
<ul>
<li>Term frequency in each document (for relevance scoring)</li>
<li>Position of each term (for phrase queries)</li>
<li>Offsets (for highlighting)</li>
</ul>
<h2>Index Architecture</h2>
<p>Understanding how Elasticsearch distributes data across a cluster is essential before you make sizing decisions. Each index is split into shards â€” independent Lucene indexes that can live on different nodes. Replicas provide both redundancy and read throughput, since any replica can serve search requests. The diagram below shows a 3-shard index with one replica each, spread across 3 nodes so that every node holds one primary and one replica â€” no single node failure takes down any shard.</p>
<pre><code>Elasticsearch Cluster:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                    Cluster                           â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  â”‚   Node 1     â”‚  â”‚   Node 2     â”‚  â”‚   Node 3     â”‚
  â”‚  â”‚  (Master)    â”‚  â”‚              â”‚  â”‚              â”‚
  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
  â”‚  â”‚  Shard 0 (P) â”‚  â”‚  Shard 1 (P) â”‚  â”‚  Shard 2 (P) â”‚
  â”‚  â”‚  Shard 1 (R) â”‚  â”‚  Shard 2 (R) â”‚  â”‚  Shard 0 (R) â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Index "products": 3 primary shards, 1 replica each
  P = Primary, R = Replica
  Total shards: 6 (3 primary + 3 replica)
</code></pre>
<p>Each <strong>shard</strong> is a complete Lucene index. Documents are routed to shards by:</p>
<pre><code>shard_id = hash(document_id) % number_of_primary_shards
</code></pre>
<p><strong>Shard sizing guidelines:</strong></p>
<ul>
<li>Target 20-50 GB per shard (larger = slower GC and recovery)</li>
<li>Number of shards = expected total data / 30 GB (rounded up)</li>
<li>Don't over-shard: each shard has overhead (~few MB), and more shards = more coordination cost</li>
</ul>
<h2>Mapping Design: The Most Important Decision</h2>
<p>Mappings define how documents and their fields are stored and indexed. Poor mapping design is the #1 cause of Elasticsearch performance problems.</p>
<p>Mappings are to Elasticsearch what a schema is to a relational database â€” but with higher stakes. You cannot change a field's type after indexing data without reindexing everything. Choosing <code>text</code> instead of <code>keyword</code> for a category field means you can't aggregate by category. Getting this right upfront saves you from expensive reindexing operations in production.</p>
<pre><code class="language-json">// Product catalog mapping
PUT /products
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "refresh_interval": "5s",          // How often new docs become searchable
    "analysis": {
      "analyzer": {
        "product_analyzer": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": ["lowercase", "stop", "snowball"]  // Stemming: "running" â†’ "run"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "id":          { "type": "keyword" },           // Exact match only
      "name":        {
        "type": "text",
        "analyzer": "product_analyzer",
        "fields": {
          "raw": { "type": "keyword" },               // For sorting and aggregations
          "suggest": { "type": "completion" }         // For autocomplete
        }
      },
      "description": { "type": "text", "analyzer": "product_analyzer" },
      "price":       { "type": "scaled_float", "scaling_factor": 100 },
      "category":    { "type": "keyword" },           // For filtering and facets
      "tags":        { "type": "keyword" },
      "in_stock":    { "type": "boolean" },
      "rating":      { "type": "half_float" },
      "created_at":  { "type": "date" },

      // Nested: preserve object identity for inner hits
      "variants": {
        "type": "nested",
        "properties": {
          "color": { "type": "keyword" },
          "size":  { "type": "keyword" },
          "stock": { "type": "integer" }
        }
      }
    }
  }
}
</code></pre>
<p>Notice that <code>name</code> is mapped as both <code>text</code> (for full-text search) and <code>keyword</code> (for sorting and faceting) using the <code>fields</code> feature. This is a common pattern â€” you want to search within the name using analyzed text, but you also want to sort results alphabetically, which requires the unanalyzed keyword version.</p>
<p><strong>Critical mapping decisions:</strong></p>
<table>
<thead>
<tr>
<th>Field Type</th>
<th>Use When</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>keyword</code></td>
<td>Exact match, sorting, aggregations (category, ID, status)</td>
</tr>
<tr>
<td><code>text</code></td>
<td>Full-text search (descriptions, names) â€” analyzed and tokenized</td>
</tr>
<tr>
<td><code>nested</code></td>
<td>Arrays of objects where you need to query inner fields independently</td>
</tr>
<tr>
<td><code>object</code></td>
<td>Simple nested objects without cross-field query requirements</td>
</tr>
<tr>
<td><code>date</code></td>
<td>Timestamps â€” store as ISO 8601, query with date math</td>
</tr>
<tr>
<td><code>scaled_float</code></td>
<td>Prices, percentages (avoids float precision issues)</td>
</tr>
</tbody>
</table>
<p><strong>Avoid:</strong></p>
<ul>
<li><code>dynamic: true</code> in production â€” unknown fields get auto-mapped, causing mapping explosions</li>
<li>Storing large binary data (use S3 + store URL)</li>
<li>Deep nesting (Elasticsearch flattens it, but queries get complex)</li>
</ul>
<h2>Query DSL: From Simple to Complex</h2>
<p>With mappings in place, you are ready to build queries. Elasticsearch's Query DSL is a JSON-based language that composes simple building blocks into arbitrarily complex search logic. The progression below goes from a basic match query to a full bool query with filters and aggregations â€” the same pattern you will use in most real-world search features.</p>
<h3>Full-Text Search</h3>
<p>The <code>match</code> query is the workhorse of Elasticsearch â€” it analyzes your search string using the same analyzer as the indexed field, then finds documents containing the resulting terms. The <code>fuzziness: AUTO</code> option adds typo tolerance by allowing small edit-distance variations, so "headpones" still finds "headphones".</p>
<pre><code class="language-json">// Match query: analyzes query string, standard choice for full-text
GET /products/_search
{
  "query": {
    "match": {
      "name": {
        "query": "wireless bluetooth headphones",
        "operator": "and",        // All terms must match (default: "or")
        "fuzziness": "AUTO"       // Typo tolerance
      }
    }
  }
}

// Multi-match: search across multiple fields with field boosting
GET /products/_search
{
  "query": {
    "multi_match": {
      "query": "gaming laptop",
      "fields": ["name^3", "description", "tags^2"],  // ^N = boost factor
      "type": "best_fields"
    }
  }
}
</code></pre>
<h3>Boolean Queries (Filtering + Searching)</h3>
<p>The bool query is where real search features come alive. It combines full-text search with structured filtering in a single query, and the distinction between <code>must</code> and <code>filter</code> clauses is one of the most important performance decisions you will make.</p>
<pre><code class="language-json">// Find: in-stock Sony headphones under $200, sorted by rating
GET /products/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "name": "headphones" } }      // Affects relevance score
      ],
      "filter": [
        { "term": { "category": "electronics" } }, // Does NOT affect score (cached)
        { "term": { "in_stock": true } },
        { "range": { "price": { "lte": 200 } } },
        { "prefix": { "brand.raw": "Sony" } }
      ],
      "must_not": [
        { "term": { "tags": "refurbished" } }
      ],
      "should": [
        { "term": { "tags": "featured" } }         // Optional boost
      ],
      "minimum_should_match": 0
    }
  },
  "sort": [
    { "rating": { "order": "desc" } },
    "_score"
  ]
}
</code></pre>
<p><strong><code>filter</code> vs <code>must</code>:</strong> Filters don't compute relevance scores and are cached by Elasticsearch. Always use <code>filter</code> for structured criteria (category, price range, boolean flags) and <code>must</code> only for full-text queries that should influence ranking.</p>
<h3>Aggregations: Faceted Search</h3>
<p>Aggregations are what power the sidebar filters you see on every e-commerce site â€” "Electronics (143)", "$500-$1000", "4+ stars". The query below runs a search and simultaneously computes facet counts, price distribution, and average rating, all in a single request. Without aggregations, you would need separate queries for each of these counts.</p>
<pre><code class="language-json">// Product search with facets (category counts, price histogram)
GET /products/_search
{
  "query": { "match": { "name": "laptop" } },
  "aggs": {
    "by_category": {
      "terms": { "field": "category", "size": 10 }
    },
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 500 },
          { "from": 500, "to": 1000 },
          { "from": 1000, "to": 2000 },
          { "from": 2000 }
        ]
      }
    },
    "avg_rating": { "avg": { "field": "rating" } },
    "in_stock_count": {
      "filter": { "term": { "in_stock": true } }
    }
  },
  "size": 10
}
</code></pre>
<h3>Nested Queries</h3>
<p>Nested queries exist because of how Elasticsearch flattens arrays of objects. Without <code>nested</code> type and queries, searching for "red L variant" might match a product that has a red M and a blue L as separate variants â€” not what you want. The <code>nested</code> query preserves object boundaries within arrays so that all conditions must match within the same variant object.</p>
<pre><code class="language-json">// Find products that have a red variant in size L
{
  "query": {
    "nested": {
      "path": "variants",
      "query": {
        "bool": {
          "filter": [
            { "term": { "variants.color": "red" } },
            { "term": { "variants.size": "L" } },
            { "range": { "variants.stock": { "gt": 0 } } }
          ]
        }
      },
      "inner_hits": {}  // Return the matching variant in the result
    }
  }
}
</code></pre>
<h2>Java Client (Official Elasticsearch Java API)</h2>
<p>The official Java client uses a fluent builder API that mirrors the JSON Query DSL structure. The search service below combines multi-field search with category and price filters, and appends an aggregation for facets â€” all in a single type-safe call. The builder pattern makes it easy to conditionally add clauses based on which filters the user actually provided.</p>
<pre><code class="language-java">@Service
public class ProductSearchService {

    @Autowired
    private ElasticsearchClient client;

    public SearchResult&#x3C;Product> search(ProductSearchRequest req) throws IOException {
        SearchResponse&#x3C;Product> response = client.search(s -> s
            .index("products")
            .query(q -> q
                .bool(b -> {
                    if (req.getQuery() != null) {
                        b.must(m -> m.multiMatch(mm -> mm
                            .query(req.getQuery())
                            .fields("name^3", "description", "tags^2")
                            .fuzziness("AUTO")
                        ));
                    }
                    if (req.getCategory() != null) {
                        b.filter(f -> f.term(t -> t.field("category").value(req.getCategory())));
                    }
                    if (req.getMaxPrice() != null) {
                        b.filter(f -> f.range(r -> r.field("price").lte(JsonData.of(req.getMaxPrice()))));
                    }
                    b.filter(f -> f.term(t -> t.field("in_stock").value(true)));
                    return b;
                })
            )
            .sort(so -> so.field(f -> f.field("_score").order(SortOrder.Desc)))
            .sort(so -> so.field(f -> f.field("rating").order(SortOrder.Desc)))
            .from(req.getPage() * req.getSize())
            .size(req.getSize())
            .aggregations("categories", a -> a.terms(t -> t.field("category").size(20)))
            , Product.class
        );

        return buildResult(response);
    }
}
</code></pre>
<h2>Production Tuning</h2>
<p>Production Elasticsearch performance comes down to three areas: JVM memory settings, index configuration for your write pattern, and ongoing monitoring. The settings below are starting points â€” you will need to adjust based on your cluster's actual size and workload.</p>
<pre><code class="language-yaml"># JVM heap: 50% of RAM, max 32GB (compressed OOPs stop working above 32GB)
ES_JAVA_OPTS: "-Xms16g -Xmx16g"

# elasticsearch.yml
indices.memory.index_buffer_size: 20%      # Buffer for indexing (default 10%)
indices.fielddata.cache.size: 20%          # FieldData cache for aggregations
</code></pre>
<p>During bulk data loads (initial indexing or migration), disabling replicas and relaxing the refresh interval can dramatically increase throughput. The steps below show how to maximize write speed during ingestion, then restore production settings when done. The <code>forcemerge</code> step is important: it compacts many small Lucene segments into one, which significantly speeds up queries on the freshly loaded index.</p>
<pre><code class="language-bash"># Index settings for write-heavy ingestion
PUT /products/_settings
{
  "refresh_interval": "30s",              # Less frequent refresh = faster indexing
  "number_of_replicas": 0                 # Disable replicas during bulk load, re-enable after
}

# After bulk load, re-enable:
PUT /products/_settings
{ "number_of_replicas": 1, "refresh_interval": "5s" }

# Force merge after bulk load (improves query performance)
POST /products/_forcemerge?max_num_segments=1
</code></pre>
<p><strong>Monitoring KPIs:</strong></p>
<ul>
<li><strong>Search latency</strong>: <code>p99 &#x3C; 200ms</code> for most queries</li>
<li><strong>Indexing latency</strong>: <code>p99 &#x3C; 500ms</code> for real-time indexing</li>
<li><strong>JVM heap used</strong>: alert at 85% (above 75% triggers GC pressure)</li>
<li><strong>Disk I/O</strong>: sustained high disk I/O = segment merges happening (normal)</li>
<li><strong>Rejected requests</strong>: thread pool rejections = cluster overwhelmed, add nodes or reduce load</li>
</ul>
<p>Elasticsearch rewards careful mapping design and query construction far more than hardware scaling. Get the mapping right first, use filters instead of queries wherever possible, and let aggregations tell you what your data looks like.</p>
</article><div class="my-10 rounded-xl border border-yellow-200 bg-yellow-50 p-6"><div class="flex items-center gap-2 mb-1"><span class="text-lg">ğŸ“š</span><h3 class="text-base font-bold text-gray-900">Recommended Resources</h3></div><div class="space-y-4"><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">Designing Data-Intensive Applications</span><span class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full font-medium">Essential</span></div><p class="text-xs text-gray-600">The go-to book for understanding databases, consistency, and distributed data.</p></div><a href="https://amzn.to/3RyKzOA" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View on Amazon<!-- --> â†’</a></div><div class="flex items-start gap-3 bg-white rounded-lg p-4 border border-yellow-100"><div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap mb-1"><span class="font-semibold text-gray-900 text-sm">MongoDB â€” The Complete Developer&#x27;s Guide â€” Udemy</span></div><p class="text-xs text-gray-600">Comprehensive MongoDB course from basics to advanced aggregations.</p></div><a href="https://www.udemy.com/course/mongodb-the-complete-developers-guide/" target="_blank" rel="noopener noreferrer" class="flex-shrink-0 text-xs bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">View Course<!-- --> â†’</a></div></div></div><div class="mt-10 pt-8 border-t border-gray-100"><p class="text-sm text-gray-500 mb-3">Found this useful? Share it:</p><div class="flex gap-3"><a href="https://twitter.com/intent/tweet?text=Elasticsearch%20Deep%20Dive%3A%20Inverted%20Index%2C%20Mappings%2C%20and%20Query%20DSL&amp;url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Felasticsearch-deep-dive%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">Share on X/Twitter</a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodesprintpro.com%2Fblog%2Felasticsearch-deep-dive%2F" target="_blank" rel="noopener noreferrer" class="text-xs bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Share on LinkedIn</a></div></div></div><aside class="hidden lg:block w-64 flex-shrink-0"><nav class="hidden lg:block sticky top-24"><h4 class="text-xs font-semibold uppercase tracking-widest text-gray-400 mb-3">On This Page</h4><ul class="space-y-1"><li class=""><a href="#how-elasticsearch-stores-data" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">How Elasticsearch Stores Data</a></li><li class=""><a href="#index-architecture" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Index Architecture</a></li><li class=""><a href="#mapping-design-the-most-important-decision" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Mapping Design: The Most Important Decision</a></li><li class=""><a href="#query-dsl-from-simple-to-complex" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Query DSL: From Simple to Complex</a></li><li class="ml-4"><a href="#full-text-search" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Full-Text Search</a></li><li class="ml-4"><a href="#boolean-queries-filtering-searching" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Boolean Queries (Filtering + Searching)</a></li><li class="ml-4"><a href="#aggregations-faceted-search" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Aggregations: Faceted Search</a></li><li class="ml-4"><a href="#nested-queries" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 text-xs">Nested Queries</a></li><li class=""><a href="#java-client-official-elasticsearch-java-api" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Java Client (Official Elasticsearch Java API)</a></li><li class=""><a href="#production-tuning" class="block text-sm py-1 border-l-2 pl-3 transition-all border-transparent text-gray-500 hover:text-gray-900 hover:border-gray-300 ">Production Tuning</a></li></ul></nav></aside></div><div class="mt-16 pt-10 border-t border-gray-100"><h2 class="text-2xl font-bold text-gray-900 mb-6">Related Articles</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-6"><a href="/blog/cassandra-data-modeling/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Cassandra Data Modeling: Design for Queries, Not Entities</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring â€” every node is equal, there&#x27;s no primary, and data placement is determined by partitâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 18, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->cassandra</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->data modeling</span></div></article></a><a href="/blog/dynamodb-advanced-patterns/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">DynamoDB Advanced Patterns: Single-Table Design and Beyond</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before youâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 13, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>9 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->dynamodb</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->aws</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->nosql</span></div></article></a><a href="/blog/zero-downtime-database-migrations/"><article class="group bg-white rounded-xl border border-gray-200 p-6 h-full cursor-pointer hover:border-blue-300 hover:shadow-lg transition-all"><span class="inline-block text-xs font-semibold px-3 py-1 rounded-full mb-3 bg-green-100 text-green-700">Databases</span><h3 class="text-lg font-bold text-gray-900 mb-2 group-hover:text-blue-600 transition-colors leading-snug">Zero-Downtime Database Migrations: Patterns for Production</h3><p class="text-gray-600 text-sm mb-4 line-clamp-3">Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible â€” rollback a bad deploy and your code is back to the previous version. Database schema changes are stâ€¦</p><div class="flex items-center justify-between text-xs text-gray-400"><span>Jun 8, 2025</span><span class="flex items-center gap-1"><svg class="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>8 min read</span></div><div class="mt-3 flex flex-wrap gap-1"><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->database</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->migrations</span><span class="text-xs text-gray-500 bg-gray-50 px-2 py-0.5 rounded border border-gray-100">#<!-- -->postgresql</span></div></article></a></div></div><div class="mt-12 text-center"><a class="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 font-medium transition-colors" href="/blog/">â† Back to all articles</a></div></div></div><footer class="bg-gray-900 text-white py-12"><div class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8"><div class="col-span-1 md:col-span-1"><div><a class="text-xl font-bold block mb-3 text-white hover:text-blue-400 transition-colors" href="/">CodeSprintPro</a></div><p class="text-gray-400 text-sm mb-4 leading-relaxed">Deep-dive technical content on System Design, Java, Databases, AI/ML, and AWS â€” by Sachin Sarawgi.</p><div class="flex space-x-4"><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit GitHub profile"><i class="fab fa-github text-xl"></i></a><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit LinkedIn profile"><i class="fab fa-linkedin text-xl"></i></a><a href="https://medium.com/@codesprintpro" target="_blank" rel="noopener noreferrer" class="text-gray-400 hover:text-white transition-colors" aria-label="Visit Medium profile"><i class="fab fa-medium text-xl"></i></a></div></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Quick Links</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Blog</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#about">About</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#portfolio">Portfolio</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/#contact">Contact</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Categories</h3><ul class="space-y-2"><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">System Design</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Java</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Databases</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AI/ML</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">AWS</a></div></li><li><div><a class="text-gray-400 hover:text-white transition-colors text-sm" href="/blog/">Messaging</a></div></li></ul></div><div><h3 class="text-sm font-semibold uppercase tracking-widest text-gray-400 mb-4">Contact</h3><ul class="space-y-2 text-gray-400 text-sm"><li><a href="mailto:sachinsarawgi201143@gmail.com" class="hover:text-white transition-colors flex items-center gap-2"><i class="fas fa-envelope"></i> Email</a></li><li><a href="https://www.linkedin.com/in/sachin-sarawgi/" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-linkedin"></i> LinkedIn</a></li><li><a href="https://github.com/codesprintpro" target="_blank" rel="noopener noreferrer" class="hover:text-white transition-colors flex items-center gap-2"><i class="fab fa-github"></i> GitHub</a></li></ul></div></div><div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row justify-between items-center gap-2"><p class="text-gray-500 text-sm">Â© <!-- -->2026<!-- --> CodeSprintPro Â· Sachin Sarawgi. All rights reserved.</p><p class="text-gray-600 text-xs">Built with Next.js Â· TailwindCSS Â· Deployed on GitHub Pages</p></div></div></footer></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Elasticsearch Deep Dive: Inverted Index, Mappings, and Query DSL","description":"Understand how Elasticsearch stores and retrieves data using inverted indexes. Learn mapping design, query DSL patterns, aggregations, and production tuning for search-heavy applications.","date":"2025-02-24","category":"Databases","tags":["elasticsearch","search","inverted index","java","databases"],"featured":false,"affiliateSection":"database-resources","slug":"elasticsearch-deep-dive","readingTime":"11 min read","excerpt":"Most engineers use Elasticsearch as a black box: index some JSON, run a search, get results. When search quality is poor or performance degrades at scale, they reach for random settings without understanding why. This arâ€¦","contentHtml":"\u003cp\u003eMost engineers use Elasticsearch as a black box: index some JSON, run a search, get results. When search quality is poor or performance degrades at scale, they reach for random settings without understanding why. This article explains the internals that make Elasticsearch work â€” and why your index design decisions matter enormously.\u003c/p\u003e\n\u003ch2\u003eHow Elasticsearch Stores Data\u003c/h2\u003e\n\u003cp\u003eElasticsearch is built on Apache Lucene. The core data structure is the \u003cstrong\u003einverted index\u003c/strong\u003e â€” a mapping from terms to the documents containing them.\u003c/p\u003e\n\u003cp\u003eThink of an inverted index like the index at the back of a textbook. Instead of reading every page to find where \"Kafka\" is mentioned, you look up \"Kafka\" in the index and get a list of page numbers. Elasticsearch builds this structure automatically when you index a document, analyzing text into individual terms and recording which documents contain each term. This is why full-text search in Elasticsearch is so fast â€” it never has to scan document content at query time.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDocuments:\n  Doc 1: \"Kafka is a distributed streaming platform\"\n  Doc 2: \"Redis is an in-memory data structure store\"\n  Doc 3: \"Kafka and Redis are both used in distributed systems\"\n\nInverted Index (simplified):\n  Term        â†’ Document IDs (posting list)\n  \"kafka\"     â†’ [1, 3]\n  \"redis\"     â†’ [2, 3]\n  \"distributed\" â†’ [1, 3]\n  \"streaming\" â†’ [1]\n  \"memory\"    â†’ [2]\n  \"systems\"   â†’ [3]\n\nQuery: \"kafka distributed\"\n  â†’ Find docs with \"kafka\": {1, 3}\n  â†’ Find docs with \"distributed\": {1, 3}\n  â†’ Intersection: {1, 3}\n  â†’ Score by BM25 relevance (term frequency, inverse document frequency)\n  â†’ Return Doc 1 (more relevant: both terms in shorter text)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach posting list also stores:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTerm frequency in each document (for relevance scoring)\u003c/li\u003e\n\u003cli\u003ePosition of each term (for phrase queries)\u003c/li\u003e\n\u003cli\u003eOffsets (for highlighting)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eIndex Architecture\u003c/h2\u003e\n\u003cp\u003eUnderstanding how Elasticsearch distributes data across a cluster is essential before you make sizing decisions. Each index is split into shards â€” independent Lucene indexes that can live on different nodes. Replicas provide both redundancy and read throughput, since any replica can serve search requests. The diagram below shows a 3-shard index with one replica each, spread across 3 nodes so that every node holds one primary and one replica â€” no single node failure takes down any shard.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eElasticsearch Cluster:\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚                    Cluster                           â”‚\n  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚  â”‚   Node 1     â”‚  â”‚   Node 2     â”‚  â”‚   Node 3     â”‚\n  â”‚  â”‚  (Master)    â”‚  â”‚              â”‚  â”‚              â”‚\n  â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚\n  â”‚  â”‚  Shard 0 (P) â”‚  â”‚  Shard 1 (P) â”‚  â”‚  Shard 2 (P) â”‚\n  â”‚  â”‚  Shard 1 (R) â”‚  â”‚  Shard 2 (R) â”‚  â”‚  Shard 0 (R) â”‚\n  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n  Index \"products\": 3 primary shards, 1 replica each\n  P = Primary, R = Replica\n  Total shards: 6 (3 primary + 3 replica)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach \u003cstrong\u003eshard\u003c/strong\u003e is a complete Lucene index. Documents are routed to shards by:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eshard_id = hash(document_id) % number_of_primary_shards\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eShard sizing guidelines:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTarget 20-50 GB per shard (larger = slower GC and recovery)\u003c/li\u003e\n\u003cli\u003eNumber of shards = expected total data / 30 GB (rounded up)\u003c/li\u003e\n\u003cli\u003eDon't over-shard: each shard has overhead (~few MB), and more shards = more coordination cost\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMapping Design: The Most Important Decision\u003c/h2\u003e\n\u003cp\u003eMappings define how documents and their fields are stored and indexed. Poor mapping design is the #1 cause of Elasticsearch performance problems.\u003c/p\u003e\n\u003cp\u003eMappings are to Elasticsearch what a schema is to a relational database â€” but with higher stakes. You cannot change a field's type after indexing data without reindexing everything. Choosing \u003ccode\u003etext\u003c/code\u003e instead of \u003ccode\u003ekeyword\u003c/code\u003e for a category field means you can't aggregate by category. Getting this right upfront saves you from expensive reindexing operations in production.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Product catalog mapping\nPUT /products\n{\n  \"settings\": {\n    \"number_of_shards\": 3,\n    \"number_of_replicas\": 1,\n    \"refresh_interval\": \"5s\",          // How often new docs become searchable\n    \"analysis\": {\n      \"analyzer\": {\n        \"product_analyzer\": {\n          \"type\": \"custom\",\n          \"tokenizer\": \"standard\",\n          \"filter\": [\"lowercase\", \"stop\", \"snowball\"]  // Stemming: \"running\" â†’ \"run\"\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"id\":          { \"type\": \"keyword\" },           // Exact match only\n      \"name\":        {\n        \"type\": \"text\",\n        \"analyzer\": \"product_analyzer\",\n        \"fields\": {\n          \"raw\": { \"type\": \"keyword\" },               // For sorting and aggregations\n          \"suggest\": { \"type\": \"completion\" }         // For autocomplete\n        }\n      },\n      \"description\": { \"type\": \"text\", \"analyzer\": \"product_analyzer\" },\n      \"price\":       { \"type\": \"scaled_float\", \"scaling_factor\": 100 },\n      \"category\":    { \"type\": \"keyword\" },           // For filtering and facets\n      \"tags\":        { \"type\": \"keyword\" },\n      \"in_stock\":    { \"type\": \"boolean\" },\n      \"rating\":      { \"type\": \"half_float\" },\n      \"created_at\":  { \"type\": \"date\" },\n\n      // Nested: preserve object identity for inner hits\n      \"variants\": {\n        \"type\": \"nested\",\n        \"properties\": {\n          \"color\": { \"type\": \"keyword\" },\n          \"size\":  { \"type\": \"keyword\" },\n          \"stock\": { \"type\": \"integer\" }\n        }\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that \u003ccode\u003ename\u003c/code\u003e is mapped as both \u003ccode\u003etext\u003c/code\u003e (for full-text search) and \u003ccode\u003ekeyword\u003c/code\u003e (for sorting and faceting) using the \u003ccode\u003efields\u003c/code\u003e feature. This is a common pattern â€” you want to search within the name using analyzed text, but you also want to sort results alphabetically, which requires the unanalyzed keyword version.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCritical mapping decisions:\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eField Type\u003c/th\u003e\n\u003cth\u003eUse When\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ekeyword\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eExact match, sorting, aggregations (category, ID, status)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eFull-text search (descriptions, names) â€” analyzed and tokenized\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enested\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eArrays of objects where you need to query inner fields independently\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eobject\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSimple nested objects without cross-field query requirements\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003edate\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTimestamps â€” store as ISO 8601, query with date math\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003escaled_float\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ePrices, percentages (avoids float precision issues)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edynamic: true\u003c/code\u003e in production â€” unknown fields get auto-mapped, causing mapping explosions\u003c/li\u003e\n\u003cli\u003eStoring large binary data (use S3 + store URL)\u003c/li\u003e\n\u003cli\u003eDeep nesting (Elasticsearch flattens it, but queries get complex)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eQuery DSL: From Simple to Complex\u003c/h2\u003e\n\u003cp\u003eWith mappings in place, you are ready to build queries. Elasticsearch's Query DSL is a JSON-based language that composes simple building blocks into arbitrarily complex search logic. The progression below goes from a basic match query to a full bool query with filters and aggregations â€” the same pattern you will use in most real-world search features.\u003c/p\u003e\n\u003ch3\u003eFull-Text Search\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003ematch\u003c/code\u003e query is the workhorse of Elasticsearch â€” it analyzes your search string using the same analyzer as the indexed field, then finds documents containing the resulting terms. The \u003ccode\u003efuzziness: AUTO\u003c/code\u003e option adds typo tolerance by allowing small edit-distance variations, so \"headpones\" still finds \"headphones\".\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Match query: analyzes query string, standard choice for full-text\nGET /products/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": {\n        \"query\": \"wireless bluetooth headphones\",\n        \"operator\": \"and\",        // All terms must match (default: \"or\")\n        \"fuzziness\": \"AUTO\"       // Typo tolerance\n      }\n    }\n  }\n}\n\n// Multi-match: search across multiple fields with field boosting\nGET /products/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"gaming laptop\",\n      \"fields\": [\"name^3\", \"description\", \"tags^2\"],  // ^N = boost factor\n      \"type\": \"best_fields\"\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eBoolean Queries (Filtering + Searching)\u003c/h3\u003e\n\u003cp\u003eThe bool query is where real search features come alive. It combines full-text search with structured filtering in a single query, and the distinction between \u003ccode\u003emust\u003c/code\u003e and \u003ccode\u003efilter\u003c/code\u003e clauses is one of the most important performance decisions you will make.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Find: in-stock Sony headphones under $200, sorted by rating\nGET /products/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"name\": \"headphones\" } }      // Affects relevance score\n      ],\n      \"filter\": [\n        { \"term\": { \"category\": \"electronics\" } }, // Does NOT affect score (cached)\n        { \"term\": { \"in_stock\": true } },\n        { \"range\": { \"price\": { \"lte\": 200 } } },\n        { \"prefix\": { \"brand.raw\": \"Sony\" } }\n      ],\n      \"must_not\": [\n        { \"term\": { \"tags\": \"refurbished\" } }\n      ],\n      \"should\": [\n        { \"term\": { \"tags\": \"featured\" } }         // Optional boost\n      ],\n      \"minimum_should_match\": 0\n    }\n  },\n  \"sort\": [\n    { \"rating\": { \"order\": \"desc\" } },\n    \"_score\"\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003efilter\u003c/code\u003e vs \u003ccode\u003emust\u003c/code\u003e:\u003c/strong\u003e Filters don't compute relevance scores and are cached by Elasticsearch. Always use \u003ccode\u003efilter\u003c/code\u003e for structured criteria (category, price range, boolean flags) and \u003ccode\u003emust\u003c/code\u003e only for full-text queries that should influence ranking.\u003c/p\u003e\n\u003ch3\u003eAggregations: Faceted Search\u003c/h3\u003e\n\u003cp\u003eAggregations are what power the sidebar filters you see on every e-commerce site â€” \"Electronics (143)\", \"$500-$1000\", \"4+ stars\". The query below runs a search and simultaneously computes facet counts, price distribution, and average rating, all in a single request. Without aggregations, you would need separate queries for each of these counts.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Product search with facets (category counts, price histogram)\nGET /products/_search\n{\n  \"query\": { \"match\": { \"name\": \"laptop\" } },\n  \"aggs\": {\n    \"by_category\": {\n      \"terms\": { \"field\": \"category\", \"size\": 10 }\n    },\n    \"price_ranges\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"ranges\": [\n          { \"to\": 500 },\n          { \"from\": 500, \"to\": 1000 },\n          { \"from\": 1000, \"to\": 2000 },\n          { \"from\": 2000 }\n        ]\n      }\n    },\n    \"avg_rating\": { \"avg\": { \"field\": \"rating\" } },\n    \"in_stock_count\": {\n      \"filter\": { \"term\": { \"in_stock\": true } }\n    }\n  },\n  \"size\": 10\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNested Queries\u003c/h3\u003e\n\u003cp\u003eNested queries exist because of how Elasticsearch flattens arrays of objects. Without \u003ccode\u003enested\u003c/code\u003e type and queries, searching for \"red L variant\" might match a product that has a red M and a blue L as separate variants â€” not what you want. The \u003ccode\u003enested\u003c/code\u003e query preserves object boundaries within arrays so that all conditions must match within the same variant object.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// Find products that have a red variant in size L\n{\n  \"query\": {\n    \"nested\": {\n      \"path\": \"variants\",\n      \"query\": {\n        \"bool\": {\n          \"filter\": [\n            { \"term\": { \"variants.color\": \"red\" } },\n            { \"term\": { \"variants.size\": \"L\" } },\n            { \"range\": { \"variants.stock\": { \"gt\": 0 } } }\n          ]\n        }\n      },\n      \"inner_hits\": {}  // Return the matching variant in the result\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eJava Client (Official Elasticsearch Java API)\u003c/h2\u003e\n\u003cp\u003eThe official Java client uses a fluent builder API that mirrors the JSON Query DSL structure. The search service below combines multi-field search with category and price filters, and appends an aggregation for facets â€” all in a single type-safe call. The builder pattern makes it easy to conditionally add clauses based on which filters the user actually provided.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class ProductSearchService {\n\n    @Autowired\n    private ElasticsearchClient client;\n\n    public SearchResult\u0026#x3C;Product\u003e search(ProductSearchRequest req) throws IOException {\n        SearchResponse\u0026#x3C;Product\u003e response = client.search(s -\u003e s\n            .index(\"products\")\n            .query(q -\u003e q\n                .bool(b -\u003e {\n                    if (req.getQuery() != null) {\n                        b.must(m -\u003e m.multiMatch(mm -\u003e mm\n                            .query(req.getQuery())\n                            .fields(\"name^3\", \"description\", \"tags^2\")\n                            .fuzziness(\"AUTO\")\n                        ));\n                    }\n                    if (req.getCategory() != null) {\n                        b.filter(f -\u003e f.term(t -\u003e t.field(\"category\").value(req.getCategory())));\n                    }\n                    if (req.getMaxPrice() != null) {\n                        b.filter(f -\u003e f.range(r -\u003e r.field(\"price\").lte(JsonData.of(req.getMaxPrice()))));\n                    }\n                    b.filter(f -\u003e f.term(t -\u003e t.field(\"in_stock\").value(true)));\n                    return b;\n                })\n            )\n            .sort(so -\u003e so.field(f -\u003e f.field(\"_score\").order(SortOrder.Desc)))\n            .sort(so -\u003e so.field(f -\u003e f.field(\"rating\").order(SortOrder.Desc)))\n            .from(req.getPage() * req.getSize())\n            .size(req.getSize())\n            .aggregations(\"categories\", a -\u003e a.terms(t -\u003e t.field(\"category\").size(20)))\n            , Product.class\n        );\n\n        return buildResult(response);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eProduction Tuning\u003c/h2\u003e\n\u003cp\u003eProduction Elasticsearch performance comes down to three areas: JVM memory settings, index configuration for your write pattern, and ongoing monitoring. The settings below are starting points â€” you will need to adjust based on your cluster's actual size and workload.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# JVM heap: 50% of RAM, max 32GB (compressed OOPs stop working above 32GB)\nES_JAVA_OPTS: \"-Xms16g -Xmx16g\"\n\n# elasticsearch.yml\nindices.memory.index_buffer_size: 20%      # Buffer for indexing (default 10%)\nindices.fielddata.cache.size: 20%          # FieldData cache for aggregations\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDuring bulk data loads (initial indexing or migration), disabling replicas and relaxing the refresh interval can dramatically increase throughput. The steps below show how to maximize write speed during ingestion, then restore production settings when done. The \u003ccode\u003eforcemerge\u003c/code\u003e step is important: it compacts many small Lucene segments into one, which significantly speeds up queries on the freshly loaded index.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Index settings for write-heavy ingestion\nPUT /products/_settings\n{\n  \"refresh_interval\": \"30s\",              # Less frequent refresh = faster indexing\n  \"number_of_replicas\": 0                 # Disable replicas during bulk load, re-enable after\n}\n\n# After bulk load, re-enable:\nPUT /products/_settings\n{ \"number_of_replicas\": 1, \"refresh_interval\": \"5s\" }\n\n# Force merge after bulk load (improves query performance)\nPOST /products/_forcemerge?max_num_segments=1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMonitoring KPIs:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSearch latency\u003c/strong\u003e: \u003ccode\u003ep99 \u0026#x3C; 200ms\u003c/code\u003e for most queries\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndexing latency\u003c/strong\u003e: \u003ccode\u003ep99 \u0026#x3C; 500ms\u003c/code\u003e for real-time indexing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJVM heap used\u003c/strong\u003e: alert at 85% (above 75% triggers GC pressure)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDisk I/O\u003c/strong\u003e: sustained high disk I/O = segment merges happening (normal)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRejected requests\u003c/strong\u003e: thread pool rejections = cluster overwhelmed, add nodes or reduce load\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eElasticsearch rewards careful mapping design and query construction far more than hardware scaling. Get the mapping right first, use filters instead of queries wherever possible, and let aggregations tell you what your data looks like.\u003c/p\u003e\n","tableOfContents":[{"id":"how-elasticsearch-stores-data","text":"How Elasticsearch Stores Data","level":2},{"id":"index-architecture","text":"Index Architecture","level":2},{"id":"mapping-design-the-most-important-decision","text":"Mapping Design: The Most Important Decision","level":2},{"id":"query-dsl-from-simple-to-complex","text":"Query DSL: From Simple to Complex","level":2},{"id":"full-text-search","text":"Full-Text Search","level":3},{"id":"boolean-queries-filtering-searching","text":"Boolean Queries (Filtering + Searching)","level":3},{"id":"aggregations-faceted-search","text":"Aggregations: Faceted Search","level":3},{"id":"nested-queries","text":"Nested Queries","level":3},{"id":"java-client-official-elasticsearch-java-api","text":"Java Client (Official Elasticsearch Java API)","level":2},{"id":"production-tuning","text":"Production Tuning","level":2}]},"relatedPosts":[{"title":"Cassandra Data Modeling: Design for Queries, Not Entities","description":"Apache Cassandra data modeling from first principles: partition key design, clustering columns, denormalization strategies, avoiding hot partitions, materialized views vs. manual duplication, and the anti-patterns that kill Cassandra performance.","date":"2025-06-18","category":"Databases","tags":["cassandra","nosql","data modeling","distributed databases","partition key","cql","time series"],"featured":false,"affiliateSection":"database-resources","slug":"cassandra-data-modeling","readingTime":"9 min read","excerpt":"Cassandra is a write-optimized distributed database built for linear horizontal scalability. It stores data in a distributed hash ring â€” every node is equal, there's no primary, and data placement is determined by partitâ€¦"},{"title":"DynamoDB Advanced Patterns: Single-Table Design and Beyond","description":"Production DynamoDB: single-table design with access pattern mapping, GSI overloading, sparse indexes, adjacency lists for graph relationships, DynamoDB Streams for event-driven architectures, and the read/write capacity math that prevents bill shock.","date":"2025-06-13","category":"Databases","tags":["dynamodb","aws","nosql","single-table design","gsi","dynamodb streams","serverless"],"featured":false,"affiliateSection":"database-resources","slug":"dynamodb-advanced-patterns","readingTime":"9 min read","excerpt":"DynamoDB is a fully managed key-value and document database that delivers single-digit millisecond performance at any scale. It achieves this with a fundamental constraint: you must define your access patterns before youâ€¦"},{"title":"Zero-Downtime Database Migrations: Patterns for Production","description":"How to safely migrate production databases without downtime: expand-contract pattern, backward-compatible schema changes, rolling deployments with dual-write, column renaming strategies, and the PostgreSQL-specific techniques for large table alterations.","date":"2025-06-08","category":"Databases","tags":["database","migrations","postgresql","zero downtime","devops","schema evolution","flyway","liquibase"],"featured":false,"affiliateSection":"database-resources","slug":"zero-downtime-database-migrations","readingTime":"8 min read","excerpt":"Database migrations are the most dangerous part of a deployment. Application code changes are stateless and reversible â€” rollback a bad deploy and your code is back to the previous version. Database schema changes are stâ€¦"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"elasticsearch-deep-dive"},"buildId":"rpFn_jslWZ9qPkJwor7RD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>