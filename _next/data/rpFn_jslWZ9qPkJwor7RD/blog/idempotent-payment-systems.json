{"pageProps":{"post":{"title":"Designing Idempotent Payment Systems in Distributed Architecture","description":"How duplicate payments happen in real systems, idempotency key design, race condition handling, Redis vs DB for idempotency stores, and the production incident that shaped our architecture.","date":"2025-04-26","category":"System Design","tags":["payments","idempotency","distributed systems","java","spring boot","fintech","system design"],"featured":false,"affiliateSection":"system-design-courses","slug":"idempotent-payment-systems","readingTime":"11 min read","excerpt":"Duplicate payments are not a theoretical edge case. In any distributed payment system operating at scale, they are a guaranteed occurrence. Networks time out. Clients retry. Proxies retry on behalf of clients. Load balan…","contentHtml":"<p>Duplicate payments are not a theoretical edge case. In any distributed payment system operating at scale, they are a guaranteed occurrence. Networks time out. Clients retry. Proxies retry on behalf of clients. Load balancers retry on 502s. The question is never \"can we prevent duplicate requests?\" — we cannot. The question is \"can we prevent duplicate charges?\"</p>\n<p>This article covers the complete design of an idempotent payment system, including the race conditions that catch engineers off guard and the production incident that reshaped how our team thinks about distributed side effects.</p>\n<h2>How Duplicate Payment Requests Happen</h2>\n<p>Duplicates in payment systems originate from multiple layers simultaneously:</p>\n<pre><code>Duplicate sources:\n\nClient App ──retry─► API Gateway ──retry─► Load Balancer ──► Payment Service\n     │                    │                      │\n     │                    │                      │\n  Network           5xx response             Health check\n  timeout           from service             failure +\n  (30s default)     (retry policy)           retry\n</code></pre>\n<p><strong>Client-side retries:</strong> A mobile app's payment SDK has a 10-second timeout. The network is slow. At 10 seconds, the SDK retries. The original request arrives at second 11 — now both requests are in flight.</p>\n<p><strong>Proxy and infrastructure retries:</strong> AWS ALB retries on 5xx responses. Nginx has <code>proxy_next_upstream</code>. Your service mesh (Istio, Linkerd) has retry policies. Each layer that retries multiplies the duplicate risk.</p>\n<p><strong>Retry storms:</strong> After a downstream payment gateway recovers from a brief outage, all queued retries flush simultaneously. 10,000 retries arrive in 500ms. Your payment service processes some; others are duplicated in the rush.</p>\n<p><strong>At-least-once message delivery:</strong> If payments flow through Kafka, SQS, or any at-least-once messaging system, your consumer will eventually process the same payment event twice.</p>\n<h2>Idempotency Keys and Database Design</h2>\n<p>An idempotency key is a client-generated, globally unique token that identifies a specific payment request. Same key = same request = same result.</p>\n<pre><code>HTTP Header approach:\nPOST /payments\nIdempotency-Key: idem_key_a3b4c5d6e7f8901234567890\n\nRequest body:\n{\n  \"user_id\": \"usr_123\",\n  \"amount\": 9999,\n  \"currency\": \"USD\",\n  \"payment_method_id\": \"pm_456\"\n}\n</code></pre>\n<p>The server stores the idempotency key and its result. On duplicate request: return the stored result, skip processing.</p>\n<h3>Database Schema for Idempotency</h3>\n<pre><code class=\"language-sql\">-- Idempotency store\nCREATE TABLE idempotency_keys (\n    idempotency_key     VARCHAR(255) NOT NULL,\n    user_id             BIGINT NOT NULL,\n    request_hash        VARCHAR(64) NOT NULL,   -- SHA-256 of request body\n    status              VARCHAR(20) NOT NULL DEFAULT 'PROCESSING',\n    -- status: PROCESSING | COMPLETED | FAILED\n    response_status     INT,                    -- HTTP status code\n    response_body       JSONB,                  -- Stored response\n    created_at          TIMESTAMPTZ DEFAULT NOW(),\n    completed_at        TIMESTAMPTZ,\n    expires_at          TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours',\n    PRIMARY KEY (idempotency_key),\n    INDEX idx_idem_user_created (user_id, created_at)\n);\n\n-- Payments table\nCREATE TABLE payments (\n    payment_id          UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n    idempotency_key     VARCHAR(255) NOT NULL UNIQUE,\n    user_id             BIGINT NOT NULL,\n    amount              DECIMAL(19,4) NOT NULL,\n    currency            CHAR(3) NOT NULL,\n    payment_method_id   VARCHAR(255) NOT NULL,\n    status              VARCHAR(20) NOT NULL,\n    gateway_charge_id   VARCHAR(255),           -- External gateway ID\n    created_at          TIMESTAMPTZ DEFAULT NOW(),\n    FOREIGN KEY (idempotency_key) REFERENCES idempotency_keys(idempotency_key)\n);\n</code></pre>\n<p>The <code>request_hash</code> column enables an important safety check: if a client sends the same idempotency key with a different request body, that's a bug in the client. Return <code>422 Unprocessable Entity</code> rather than processing a potentially different amount.</p>\n<h2>Race Conditions and Locking Strategies</h2>\n<p>The naive implementation has a classic TOCTOU race condition:</p>\n<pre><code>Thread A: SELECT * FROM idempotency_keys WHERE key='idem_123' → Not found\nThread B: SELECT * FROM idempotency_keys WHERE key='idem_123' → Not found\nThread A: INSERT INTO idempotency_keys → Success\nThread B: INSERT INTO idempotency_keys → Duplicate key error OR succeeds (duplicate charge!)\n</code></pre>\n<h3>Strategy 1: Database Unique Constraint (Preferred)</h3>\n<pre><code class=\"language-java\">@Transactional(isolation = Isolation.READ_COMMITTED)\npublic PaymentResponse processPayment(String idempotencyKey, PaymentRequest request) {\n    // Attempt atomic insert - fails on duplicate key\n    try {\n        jdbcTemplate.update(\n            \"\"\"\n            INSERT INTO idempotency_keys (idempotency_key, user_id, request_hash, status)\n            VALUES (?, ?, ?, 'PROCESSING')\n            \"\"\",\n            idempotencyKey, request.userId(), sha256(request)\n        );\n    } catch (DuplicateKeyException e) {\n        // Another thread or request is processing / has processed this key\n        return getStoredResponse(idempotencyKey, request);\n    }\n\n    // Only one thread reaches here per idempotency key\n    try {\n        PaymentResult result = chargeGateway(request);\n        storeResult(idempotencyKey, result);\n        return PaymentResponse.success(result);\n    } catch (Exception e) {\n        markFailed(idempotencyKey, e);\n        throw e;\n    }\n}\n\nprivate PaymentResponse getStoredResponse(String key, PaymentRequest request) {\n    IdempotencyRecord record = findRecord(key);\n\n    // Validate request body matches\n    if (!record.requestHash().equals(sha256(request))) {\n        throw new IdempotencyConflictException(\n            \"Idempotency key reused with different request body\");\n    }\n\n    return switch (record.status()) {\n        case \"PROCESSING\" -> throw new PaymentInProgressException(\n            \"Payment is being processed, retry in 1 second\");\n        case \"COMPLETED\"  -> PaymentResponse.fromStored(record.responseBody());\n        case \"FAILED\"     -> PaymentResponse.fromStoredFailure(record.responseBody());\n        default -> throw new IllegalStateException(\"Unknown status: \" + record.status());\n    };\n}\n</code></pre>\n<p>The database unique constraint enforces mutual exclusion at the storage layer. No distributed lock needed.</p>\n<h3>Strategy 2: Pessimistic Locking with SELECT FOR UPDATE</h3>\n<p>For scenarios where you need to read-then-update atomically:</p>\n<pre><code class=\"language-java\">@Transactional\npublic PaymentResponse processPaymentLocked(String idempotencyKey, PaymentRequest request) {\n    // Lock the row, or insert if absent\n    Optional&#x3C;IdempotencyRecord> existing = jdbcTemplate.query(\n        \"SELECT * FROM idempotency_keys WHERE idempotency_key = ? FOR UPDATE\",\n        idempotencyKeyRowMapper, idempotencyKey\n    ).stream().findFirst();\n\n    if (existing.isPresent()) {\n        return handleExisting(existing.get(), request);\n    }\n\n    // Safe to insert — we hold the lock on this key's position\n    jdbcTemplate.update(\n        \"INSERT INTO idempotency_keys (idempotency_key, user_id, request_hash, status) VALUES (?, ?, ?, 'PROCESSING')\",\n        idempotencyKey, request.userId(), sha256(request)\n    );\n\n    return executePayment(idempotencyKey, request);\n}\n</code></pre>\n<p><code>SELECT FOR UPDATE</code> with a non-existent row doesn't actually lock anything in most databases. Use gap locking or a distributed lock for that case.</p>\n<h2>Redis vs Database for Idempotency Store</h2>\n<p>Both work, but they have different trade-off profiles:</p>\n<table>\n<thead>\n<tr>\n<th>Dimension</th>\n<th>PostgreSQL</th>\n<th>Redis</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Consistency</td>\n<td>ACID, durable</td>\n<td>Eventual (if using Redis Cluster)</td>\n</tr>\n<tr>\n<td>Latency</td>\n<td>1–5ms</td>\n<td>&#x3C; 1ms</td>\n</tr>\n<tr>\n<td>Throughput</td>\n<td>10K ops/s (single node)</td>\n<td>100K+ ops/s</td>\n</tr>\n<tr>\n<td>TTL management</td>\n<td>Manual (cron job)</td>\n<td>Native TTL</td>\n</tr>\n<tr>\n<td>Data co-location</td>\n<td>Same DB transaction</td>\n<td>Separate system, no transactions</td>\n</tr>\n<tr>\n<td>Operational complexity</td>\n<td>Existing infra</td>\n<td>Additional service</td>\n</tr>\n<tr>\n<td>Risk on failure</td>\n<td>Payment processing stops</td>\n<td>Falls back gracefully</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Use PostgreSQL when:</strong></p>\n<ul>\n<li>You need the idempotency check and payment insert to be in the same ACID transaction</li>\n<li>You cannot afford to lose idempotency records on Redis failure</li>\n<li>Throughput is under 5,000 payments/second</li>\n</ul>\n<p><strong>Use Redis when:</strong></p>\n<ul>\n<li>Your payment volume exceeds PostgreSQL's comfortable range</li>\n<li>You accept that Redis failure means falling back to processing (with idempotent downstream)</li>\n<li>You use Redis Cluster with persistence (AOF + RDB) for durability</li>\n</ul>\n<p><strong>Hybrid approach</strong> used at high-scale fintechs:</p>\n<pre><code>Request arrives with idempotency key\n     │\n     ▼\nCheck Redis cache (fast path):\n     │\n     ├── Found in Redis → Return cached response (&#x3C; 1ms)\n     │\n     └── Not in Redis\n               │\n               ▼\n         PostgreSQL (authoritative):\n               │\n               ├── Found in DB → Cache in Redis, return response\n               │\n               └── Not in DB → Process payment, insert to DB, cache in Redis\n</code></pre>\n<p>Redis acts as a read-through cache. Database is authoritative. On Redis failure, requests fall through to the database — slower but correct.</p>\n<pre><code class=\"language-java\">@Service\npublic class HybridIdempotencyService {\n\n    public Optional&#x3C;PaymentResponse> checkCache(String key) {\n        try {\n            String cached = redisTemplate.opsForValue().get(\"idem:\" + key);\n            return Optional.ofNullable(cached)\n                .map(json -> deserialize(json, PaymentResponse.class));\n        } catch (RedisConnectionFailureException e) {\n            log.warn(\"Redis unavailable, falling through to DB: {}\", e.getMessage());\n            return Optional.empty(); // Degrade gracefully\n        }\n    }\n\n    public void cacheResult(String key, PaymentResponse response) {\n        try {\n            redisTemplate.opsForValue().set(\n                \"idem:\" + key,\n                serialize(response),\n                Duration.ofHours(24)\n            );\n        } catch (RedisConnectionFailureException e) {\n            log.warn(\"Redis unavailable, result not cached: {}\", e.getMessage());\n            // Continue — DB has the authoritative record\n        }\n    }\n}\n</code></pre>\n<h2>Failure Scenarios</h2>\n<p><strong>Scenario 1: Payment succeeds at gateway, response lost on return</strong></p>\n<pre><code>Service → Gateway: charge($100) → Gateway charges card ✓\nGateway → Service: HTTP 200 with charge_id [network failure]\nService: times out, marks as FAILED\nClient: retries with same idempotency key\nService: processes payment again → DOUBLE CHARGE\n</code></pre>\n<p><strong>Fix:</strong> Use the gateway's idempotency support. Stripe, Braintree, and Adyen all accept an idempotency key on charge requests. If the same key is sent twice, they return the same result without charging twice. Store <code>gateway_charge_id</code> and verify before processing:</p>\n<pre><code class=\"language-java\">public PaymentResult chargeWithGatewayIdempotency(PaymentRequest req, String idempotencyKey) {\n    StripeRequest stripeReq = StripeRequest.builder()\n        .amount(req.amount())\n        .currency(req.currency())\n        .paymentMethodId(req.paymentMethodId())\n        .idempotencyKey(idempotencyKey)  // Pass through to gateway\n        .build();\n\n    return stripeClient.charges().create(stripeReq);\n}\n</code></pre>\n<p><strong>Scenario 2: PROCESSING status stuck (service crash mid-payment)</strong></p>\n<p>If the service crashes after inserting <code>PROCESSING</code> but before updating to <code>COMPLETED</code>, the idempotency key is locked in PROCESSING forever. Client retries get <code>PaymentInProgressException</code>.</p>\n<p>Fix: Time-bound PROCESSING status:</p>\n<pre><code class=\"language-sql\">-- Detect stuck PROCESSING keys (job runs every minute)\nSELECT idempotency_key\nFROM idempotency_keys\nWHERE status = 'PROCESSING'\n  AND created_at &#x3C; NOW() - INTERVAL '2 minutes';\n\n-- For each stuck key: check gateway for actual status\n-- If gateway has charge: mark COMPLETED with gateway result\n-- If gateway has no charge: mark FAILED, safe to retry\n</code></pre>\n<h2>Text-Based Architecture Diagram</h2>\n<pre><code>Idempotent Payment Flow:\n\nMobile Client\n     │\n     │  POST /payments\n     │  Idempotency-Key: idem_abc123\n     ▼\nAPI Gateway (rate limiting, auth)\n     │\n     ▼\nPayment Service\n     │\n     ├─[1]─► Redis: GET idem:idem_abc123\n     │           │\n     │           ├── Cache hit → Return cached response (END)\n     │           └── Cache miss → continue\n     │\n     ├─[2]─► PostgreSQL: INSERT INTO idempotency_keys\n     │           │\n     │           ├── DuplicateKeyException → Fetch + return stored result (END)\n     │           └── Insert success → continue (exclusive processing)\n     │\n     ├─[3]─► Payment Gateway (Stripe/Braintree)\n     │        with gateway idempotency key\n     │           │\n     │           ├── Success: charge_id=ch_xyz\n     │           └── Failure: error code + message\n     │\n     ├─[4]─► PostgreSQL: UPDATE idempotency_keys SET status='COMPLETED'\n     │        + INSERT INTO payments\n     │        (single transaction)\n     │\n     └─[5]─► Redis: SET idem:idem_abc123 = response (TTL=24h)\n                   └── Return response to client\n</code></pre>\n<h2>Monitoring and Observability</h2>\n<pre><code class=\"language-java\">@Component\npublic class PaymentMetrics {\n\n    private final Counter duplicatePaymentAttempts;\n    private final Counter stuckProcessingKeys;\n\n    public PaymentMetrics(MeterRegistry registry) {\n        this.duplicatePaymentAttempts = Counter.builder(\"payments.duplicate_attempts\")\n            .description(\"Idempotency key reuse count\")\n            .register(registry);\n\n        this.stuckProcessingKeys = Counter.builder(\"payments.stuck_processing_keys\")\n            .description(\"Payments stuck in PROCESSING status\")\n            .register(registry);\n    }\n}\n</code></pre>\n<p>Key metrics to alert on:</p>\n<ul>\n<li><code>payments.duplicate_attempts > 100/min</code> — possible retry storm in progress</li>\n<li><code>payments.stuck_processing_keys > 0</code> — service crashes or network partitions happening</li>\n<li><code>payments.gateway_idempotency_conflict > 0</code> — gateway received same key with different amount (client bug)</li>\n<li>P99 latency of idempotency key lookup > 50ms — database under pressure</li>\n</ul>\n<h2>Real Production Incident</h2>\n<p><strong>Context:</strong> Fintech platform, 50,000 payments/day, Spring Boot + PostgreSQL.</p>\n<p><strong>Incident:</strong> Black Friday sale. Payment volume spiked 10×. Our payment gateway (external) was slow — 8-second response times vs normal 800ms. Our API timeout was 10 seconds. Result: 80% of payment requests timed out client-side at the 10-second mark. All clients retried immediately with the same idempotency keys.</p>\n<p>The retry storm overwhelmed the gateway. The gateway rate-limited us. More timeouts. More retries. A feedback loop.</p>\n<p><strong>What saved us:</strong> Idempotency keys in our database. Despite the chaos, every payment was processed exactly once. Clients that got timeouts eventually got responses on retry — the response was pulled from our idempotency store rather than charging the card again.</p>\n<p><strong>What hurt us:</strong> 70% of our API capacity was consumed by duplicate requests hitting the idempotency cache. Our P99 API latency hit 15 seconds for legitimate new payments.</p>\n<p><strong>Post-incident fixes:</strong></p>\n<ol>\n<li>Redis cache for idempotency hot path — duplicate requests now cost 0.5ms instead of 5ms database lookup</li>\n<li>Separate thread pool for idempotency lookups vs new payment processing</li>\n<li>Exponential backoff enforced server-side: 429 Too Many Requests with <code>Retry-After</code> header</li>\n<li>Gateway circuit breaker: open after 20% of requests exceed 5 seconds</li>\n</ol>\n<h2>Lessons Learned in Production</h2>\n<p><strong>1. Idempotency is not optional.</strong> It is a core payment system requirement, not an edge case handler. Build it in from day one, not after your first duplicate charge incident.</p>\n<p><strong>2. Client-side idempotency keys must be generated before the first attempt.</strong> Generate the key before calling the API, persist it locally, use the same key on retries. Don't generate a new key on retry — that defeats the purpose.</p>\n<p><strong>3. Your gateway must support idempotency keys too.</strong> A payment service that is idempotent but calls a gateway that isn't still causes double charges. Validate your gateway's idempotency behavior explicitly.</p>\n<p><strong>4. <code>PROCESSING</code> status must be time-bounded with a recovery job.</strong> A payment stuck in PROCESSING indefinitely blocks the customer's ability to retry. This is as bad as a double charge from a UX perspective.</p>\n<p><strong>5. Separate idempotency check latency from payment processing latency in your metrics.</strong> Cache hits should be sub-millisecond. If your idempotency P99 is growing, you have either a traffic spike or an index problem — both need different responses.</p>\n","tableOfContents":[{"id":"how-duplicate-payment-requests-happen","text":"How Duplicate Payment Requests Happen","level":2},{"id":"idempotency-keys-and-database-design","text":"Idempotency Keys and Database Design","level":2},{"id":"database-schema-for-idempotency","text":"Database Schema for Idempotency","level":3},{"id":"race-conditions-and-locking-strategies","text":"Race Conditions and Locking Strategies","level":2},{"id":"strategy-1-database-unique-constraint-preferred","text":"Strategy 1: Database Unique Constraint (Preferred)","level":3},{"id":"strategy-2-pessimistic-locking-with-select-for-update","text":"Strategy 2: Pessimistic Locking with SELECT FOR UPDATE","level":3},{"id":"redis-vs-database-for-idempotency-store","text":"Redis vs Database for Idempotency Store","level":2},{"id":"failure-scenarios","text":"Failure Scenarios","level":2},{"id":"text-based-architecture-diagram","text":"Text-Based Architecture Diagram","level":2},{"id":"monitoring-and-observability","text":"Monitoring and Observability","level":2},{"id":"real-production-incident","text":"Real Production Incident","level":2},{"id":"lessons-learned-in-production","text":"Lessons Learned in Production","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why — by exploring system state through metrics, traces, and logs without needing to know in advance…"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory — store events instead of state, derive state by replaying events — is sou…"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t…"}]},"__N_SSG":true}