{"pageProps":{"post":{"title":"Multi-Tenancy Architecture: Database, Application, and Infrastructure Patterns","description":"Production multi-tenancy: database isolation models (shared schema, shared database, separate database), tenant routing, data partitioning strategies, cross-tenant query prevention, Spring Boot tenant context propagation, and the trade-offs at each isolation level.","date":"2025-05-24","category":"System Design","tags":["multi-tenancy","saas","system design","database","spring boot","architecture","isolation"],"featured":false,"affiliateSection":"system-design-courses","slug":"multi-tenancy-architecture","readingTime":"8 min read","excerpt":"Multi-tenancy is the architecture pattern where a single deployed instance of a software system serves multiple customers (tenants), with each tenant's data logically or physically isolated from others. It's the foundati…","contentHtml":"<p>Multi-tenancy is the architecture pattern where a single deployed instance of a software system serves multiple customers (tenants), with each tenant's data logically or physically isolated from others. It's the foundation of SaaS products. The isolation model you choose is a fundamental architectural decision — it determines your security posture, operational complexity, cost structure, and scalability ceiling.</p>\n<h2>The Three Isolation Models</h2>\n<pre><code>Model 1: Shared Schema (Row-Level Isolation)\n┌────────────────────────────────────────────┐\n│  Single database, single schema            │\n│  Every table has a tenant_id column        │\n│  tenant A rows: tenant_id='A'              │\n│  tenant B rows: tenant_id='B'              │\n│  All tenants share tables                  │\n└────────────────────────────────────────────┘\nCost: Lowest    Security: Lowest    Scale: Highest\n\nModel 2: Shared Database, Separate Schemas\n┌────────────────────────────────────────────┐\n│  Single database server                    │\n│  Schema per tenant: tenant_a.orders        │\n│                     tenant_b.orders        │\n│  No shared tables (except system tables)   │\n└────────────────────────────────────────────┘\nCost: Medium    Security: Medium    Scale: Medium\n\nModel 3: Separate Database (Database per Tenant)\n┌──────────┐   ┌──────────┐   ┌──────────┐\n│ Tenant A │   │ Tenant B │   │ Tenant C │\n│    DB    │   │    DB    │   │    DB    │\n└──────────┘   └──────────┘   └──────────┘\nCost: Highest   Security: Highest  Scale: Limited\n</code></pre>\n<p>Most SaaS products start with shared schema (simplest) and migrate toward separate databases as they land larger enterprise customers who demand data isolation guarantees.</p>\n<h2>Model 1: Shared Schema with Row-Level Security</h2>\n<p><strong>PostgreSQL Row-Level Security (RLS):</strong></p>\n<pre><code class=\"language-sql\">-- Enable RLS on every tenant-scoped table:\nALTER TABLE orders ENABLE ROW LEVEL SECURITY;\n\n-- Create policy: users can only see rows matching their tenant_id\nCREATE POLICY tenant_isolation ON orders\n    USING (tenant_id = current_setting('app.current_tenant')::UUID);\n\n-- Set tenant context per connection/transaction:\nSET app.current_tenant = '550e8400-e29b-41d4-a716-446655440000';\n\n-- Now ALL queries on orders are automatically filtered:\nSELECT * FROM orders;\n-- Equivalent to: SELECT * FROM orders WHERE tenant_id = '550e8400-...'\n-- Even if a query accidentally omits the tenant_id filter — RLS enforces it\n</code></pre>\n<p>RLS is a defense-in-depth layer. Even if application code has a bug that omits the tenant filter, RLS prevents cross-tenant data leakage at the database level.</p>\n<p><strong>Spring Boot implementation:</strong></p>\n<pre><code class=\"language-java\">// Tenant context holder (thread-local):\npublic class TenantContext {\n    private static final ThreadLocal&#x3C;String> currentTenant = new ThreadLocal&#x3C;>();\n\n    public static void setCurrentTenant(String tenantId) {\n        currentTenant.set(tenantId);\n    }\n\n    public static String getCurrentTenant() {\n        return currentTenant.get();\n    }\n\n    public static void clear() {\n        currentTenant.remove();\n    }\n}\n\n// Interceptor: extract tenant from request and set context\n@Component\npublic class TenantInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n                              HttpServletResponse response,\n                              Object handler) {\n        // Option 1: Tenant from subdomain (acme.app.com → tenant=acme)\n        String host = request.getServerName();\n        String tenantId = host.split(\"\\\\.\")[0];\n\n        // Option 2: Tenant from JWT claim (more reliable)\n        String jwt = extractJwt(request);\n        String tenantId2 = jwtService.getTenantId(jwt);\n\n        // Option 3: Tenant from request header (for internal APIs)\n        String tenantId3 = request.getHeader(\"X-Tenant-ID\");\n\n        TenantContext.setCurrentTenant(tenantId2);\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,\n                                 Object handler, Exception ex) {\n        TenantContext.clear();  // CRITICAL: clean up thread-local or risk tenant leakage\n    }\n}\n\n// Hibernate multi-tenancy — pass tenant_id to every query automatically:\n@Component\npublic class TenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n    @Override\n    public String resolveCurrentTenantIdentifier() {\n        String tenantId = TenantContext.getCurrentTenant();\n        return tenantId != null ? tenantId : \"default\";\n    }\n\n    @Override\n    public boolean validateExistingCurrentSessions() {\n        return true;\n    }\n}\n\n// Entity: tenant_id on every table:\n@Entity\n@Table(name = \"orders\")\n@FilterDef(name = \"tenantFilter\", parameters = @ParamDef(name = \"tenantId\", type = String.class))\n@Filter(name = \"tenantFilter\", condition = \"tenant_id = :tenantId\")\npublic class Order {\n\n    @Id\n    private UUID id;\n\n    @Column(name = \"tenant_id\", nullable = false, updatable = false)\n    private UUID tenantId;\n\n    // ... other fields\n}\n</code></pre>\n<p><strong>The critical risk in shared schema: accidental cross-tenant queries</strong></p>\n<pre><code class=\"language-java\">// VULNERABLE: Developer forgets to add tenant filter\npublic List&#x3C;Order> findRecentOrders() {\n    return em.createQuery(\"FROM Order WHERE created_at > :date\", Order.class)\n        .setParameter(\"date\", LocalDate.now().minusDays(7))\n        .getResultList();\n    // Returns orders from ALL tenants — data breach\n}\n\n// SAFE: Always include tenant_id\npublic List&#x3C;Order> findRecentOrders() {\n    String tenantId = TenantContext.getCurrentTenant();\n    return em.createQuery(\n        \"FROM Order WHERE tenant_id = :tenantId AND created_at > :date\", Order.class)\n        .setParameter(\"tenantId\", UUID.fromString(tenantId))\n        .setParameter(\"date\", LocalDate.now().minusDays(7))\n        .getResultList();\n}\n\n// SAFER: Use Hibernate @Filter applied globally (can't forget it):\n// Session.enableFilter(\"tenantFilter\").setParameter(\"tenantId\", tenantId)\n// This adds the filter condition to ALL queries for the session\n</code></pre>\n<h2>Model 2: Schema-Per-Tenant</h2>\n<pre><code class=\"language-java\">// Hibernate connection pool routing:\n@Configuration\npublic class MultiTenantDataSourceConfig implements MultiTenantConnectionProvider {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Override\n    public Connection getConnection(String tenantIdentifier) throws SQLException {\n        Connection connection = dataSource.getConnection();\n        // Switch schema to tenant's schema:\n        connection.createStatement().execute(\n            \"SET search_path TO tenant_\" + sanitize(tenantIdentifier) + \", public\"\n        );\n        return connection;\n    }\n\n    @Override\n    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {\n        connection.createStatement().execute(\"SET search_path TO public\");\n        connection.close();\n    }\n\n    private String sanitize(String tenantId) {\n        // CRITICAL: Sanitize to prevent SQL injection via tenant ID\n        if (!tenantId.matches(\"^[a-zA-Z0-9_-]+$\")) {\n            throw new SecurityException(\"Invalid tenant ID\");\n        }\n        return tenantId;\n    }\n}\n\n// Schema provisioning (when a new tenant signs up):\n@Service\npublic class TenantProvisioningService {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Transactional\n    public void provisionTenant(String tenantId) {\n        String schema = \"tenant_\" + sanitize(tenantId);\n\n        // Create schema:\n        jdbcTemplate.execute(\"CREATE SCHEMA IF NOT EXISTS \" + schema);\n\n        // Run migrations for this schema:\n        Flyway.configure()\n            .dataSource(dataSource)\n            .schemas(schema)\n            .locations(\"classpath:db/migration\")\n            .load()\n            .migrate();\n\n        log.info(\"Provisioned schema for tenant: {}\", tenantId);\n    }\n}\n</code></pre>\n<p>Schema-per-tenant allows schema customization per tenant (enterprise customers often want custom fields). However, running migrations across thousands of schemas becomes a management challenge — a migration that takes 1 second per schema takes 17 minutes across 1,000 tenants.</p>\n<h2>Model 3: Database-Per-Tenant with Dynamic Routing</h2>\n<pre><code class=\"language-java\">// Connection pool per tenant (HikariCP):\n@Service\npublic class TenantDataSourceService {\n\n    private final Map&#x3C;String, DataSource> dataSources = new ConcurrentHashMap&#x3C;>();\n    private final TenantConfigRepository tenantConfigRepository;\n\n    public DataSource getDataSource(String tenantId) {\n        return dataSources.computeIfAbsent(tenantId, this::createDataSource);\n    }\n\n    private DataSource createDataSource(String tenantId) {\n        TenantConfig config = tenantConfigRepository.findById(tenantId)\n            .orElseThrow(() -> new TenantNotFoundException(tenantId));\n\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setJdbcUrl(config.getDatabaseUrl());\n        hikariConfig.setUsername(config.getDbUser());\n        hikariConfig.setPassword(config.getDbPassword());\n        hikariConfig.setMaximumPoolSize(5);     // Small pool per tenant\n        hikariConfig.setMinimumIdle(1);\n        hikariConfig.setConnectionTimeout(5000);\n        hikariConfig.setPoolName(\"tenant-\" + tenantId);\n\n        return new HikariDataSource(hikariConfig);\n    }\n}\n\n// Spring AbstractRoutingDataSource:\n@Component\npublic class TenantAwareDataSource extends AbstractRoutingDataSource {\n\n    @Autowired\n    private TenantDataSourceService tenantDataSourceService;\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return TenantContext.getCurrentTenant();\n    }\n\n    @Override\n    protected DataSource determineTargetDataSource() {\n        String tenantId = TenantContext.getCurrentTenant();\n        return tenantDataSourceService.getDataSource(tenantId);\n    }\n}\n</code></pre>\n<p><strong>Database-per-tenant operational challenges:</strong></p>\n<ul>\n<li>1,000 tenants = 1,000 database connection pools = potential for many idle connections</li>\n<li>Schema migrations must run against all tenant databases (usually via a migration runner that loops over all tenants)</li>\n<li>Monitoring 1,000 separate databases requires aggregated observability</li>\n<li>Cost scales linearly with tenant count (no sharing)</li>\n</ul>\n<h2>Tenant Onboarding and Lifecycle</h2>\n<pre><code class=\"language-java\">@Service\npublic class TenantLifecycleService {\n\n    // Asynchronous provisioning (tenant creation shouldn't block the signup response):\n    @Async\n    public CompletableFuture&#x3C;Void> provisionNewTenant(TenantSignupRequest request) {\n        String tenantId = UUID.randomUUID().toString();\n\n        // 1. Create database record for tenant:\n        Tenant tenant = tenantRepository.save(new Tenant(tenantId, request.getCompanyName()));\n\n        // 2. Provision infrastructure (database/schema):\n        tenantProvisioningService.provision(tenantId);\n\n        // 3. Seed default data (roles, settings, sample data):\n        tenantSeedingService.seedDefaults(tenantId);\n\n        // 4. Send welcome email:\n        emailService.sendWelcome(tenant, request.getAdminEmail());\n\n        // 5. Update provisioning status:\n        tenant.setStatus(TenantStatus.ACTIVE);\n        tenantRepository.save(tenant);\n\n        return CompletableFuture.completedFuture(null);\n    }\n\n    @Transactional\n    public void suspendTenant(String tenantId) {\n        Tenant tenant = tenantRepository.findById(tenantId)\n            .orElseThrow(() -> new TenantNotFoundException(tenantId));\n        tenant.setStatus(TenantStatus.SUSPENDED);\n        tenantRepository.save(tenant);\n\n        // Revoke active sessions:\n        sessionService.revokeAllForTenant(tenantId);\n    }\n}\n</code></pre>\n<h2>Cross-Tenant Analytics (Admin Queries)</h2>\n<p>Admin queries (aggregate statistics across all tenants) require bypassing tenant isolation:</p>\n<pre><code class=\"language-java\">// Dedicated admin data source — separate connection with elevated permissions:\n@Configuration\npublic class AdminDataSourceConfig {\n\n    @Bean(\"adminDataSource\")\n    public DataSource adminDataSource() {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(adminDbUrl);\n        config.setUsername(adminDbUser);\n        config.setPassword(adminDbPassword);\n        return new HikariDataSource(config);\n    }\n}\n\n@Repository\npublic class AdminAnalyticsRepository {\n\n    @Autowired\n    @Qualifier(\"adminDataSource\")\n    private DataSource adminDataSource;\n\n    // Admin-only: revenue across all tenants\n    public List&#x3C;TenantRevenue> getRevenueByTenant(LocalDate startDate) {\n        // In shared schema: query without tenant filter\n        // In schema-per-tenant: UNION across all schemas\n        // In db-per-tenant: federated query or aggregated via ETL pipeline\n    }\n}\n\n// Protect with role-based access:\n@PreAuthorize(\"hasRole('PLATFORM_ADMIN')\")\n@GetMapping(\"/admin/analytics/revenue\")\npublic ResponseEntity&#x3C;List&#x3C;TenantRevenue>> getRevenue(@RequestParam LocalDate startDate) {\n    return ResponseEntity.ok(adminAnalyticsRepository.getRevenueByTenant(startDate));\n}\n</code></pre>\n<h2>Choosing the Right Model</h2>\n<table>\n<thead>\n<tr>\n<th>Factor</th>\n<th>Shared Schema</th>\n<th>Schema-per-Tenant</th>\n<th>DB-per-Tenant</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Setup complexity</td>\n<td>Low</td>\n<td>Medium</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Per-tenant cost</td>\n<td>Lowest</td>\n<td>Low</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Data isolation</td>\n<td>Logical only</td>\n<td>Stronger</td>\n<td>Strongest</td>\n</tr>\n<tr>\n<td>Enterprise compliance</td>\n<td>Difficult</td>\n<td>Possible</td>\n<td>Easy</td>\n</tr>\n<tr>\n<td>Schema customization</td>\n<td>Hard</td>\n<td>Possible</td>\n<td>Easy</td>\n</tr>\n<tr>\n<td>Migration complexity</td>\n<td>Low</td>\n<td>Medium</td>\n<td>High (per-DB)</td>\n</tr>\n<tr>\n<td>Max tenant scale</td>\n<td>100,000+</td>\n<td>10,000</td>\n<td>~1,000</td>\n</tr>\n</tbody>\n</table>\n<p>Start with shared schema unless your target customers have strict data residency requirements on day one. Add schema-per-tenant for enterprise tiers where compliance demands it. Reserve database-per-tenant for your largest, highest-paying customers who need dedicated infrastructure guarantees.</p>\n<p>The multi-tenancy model shapes every subsequent architectural decision — data backup, disaster recovery, schema evolution, performance isolation, and compliance reporting. Make this choice deliberately, with full awareness of where you want to be in 3-5 years, not just what's easiest to build today.</p>\n","tableOfContents":[{"id":"the-three-isolation-models","text":"The Three Isolation Models","level":2},{"id":"model-1-shared-schema-with-row-level-security","text":"Model 1: Shared Schema with Row-Level Security","level":2},{"id":"model-2-schema-per-tenant","text":"Model 2: Schema-Per-Tenant","level":2},{"id":"model-3-database-per-tenant-with-dynamic-routing","text":"Model 3: Database-Per-Tenant with Dynamic Routing","level":2},{"id":"tenant-onboarding-and-lifecycle","text":"Tenant Onboarding and Lifecycle","level":2},{"id":"cross-tenant-analytics-admin-queries","text":"Cross-Tenant Analytics (Admin Queries)","level":2},{"id":"choosing-the-right-model","text":"Choosing the Right Model","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why — by exploring system state through metrics, traces, and logs without needing to know in advance…"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory — store events instead of state, derive state by replaying events — is sou…"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t…"}]},"__N_SSG":true}