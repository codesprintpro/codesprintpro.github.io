{"pageProps":{"post":{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t…","contentHtml":"<p>API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to their protobuf schemas. GraphQL queries written for a mobile app in 2019 are still constrained by the data graph that was designed then. Getting this choice right — or understanding the trade-offs well enough to migrate later — matters.</p>\n<h2>REST: The Default for Good Reason</h2>\n<p>REST over HTTP/JSON is the dominant API paradigm. Its dominance comes not from technical superiority but from universal support: every HTTP client, every programming language, every debugging tool, every proxy, every API gateway supports it.</p>\n<p><strong>Technical characteristics:</strong></p>\n<ul>\n<li>Text-based (JSON): human-readable, easy to debug with curl/Postman</li>\n<li>HTTP/1.1 or HTTP/2 transport</li>\n<li>Stateless request-response</li>\n<li>Standard HTTP semantics: GET (idempotent read), POST (create), PUT/PATCH (update), DELETE</li>\n<li>Cacheable at every layer (browser, CDN, reverse proxy)</li>\n</ul>\n<p><strong>REST payload size vs gRPC:</strong></p>\n<pre><code>User object (4 fields):\nJSON: {\"id\":12345,\"name\":\"Alice Smith\",\"email\":\"alice@example.com\",\"role\":\"admin\"}\n      → 73 bytes\n\nProtobuf (equivalent):\n      → 32 bytes (~56% smaller)\n\nAt 100K requests/second:\nJSON: 7.3 MB/s wire data\nProtobuf: 3.2 MB/s wire data\n</code></pre>\n<p>The size difference compounds with complex nested objects. At 10K requests/second it's irrelevant. At 1M requests/second it affects infrastructure costs.</p>\n<h2>gRPC: Performance and Strong Contracts</h2>\n<p>gRPC is RPC over HTTP/2 with Protocol Buffers as the serialization format.</p>\n<p><strong>Define the service contract:</strong></p>\n<pre><code class=\"language-protobuf\">// user_service.proto\nsyntax = \"proto3\";\n\npackage user.v1;\n\nservice UserService {\n    rpc GetUser (GetUserRequest) returns (GetUserResponse);\n    rpc CreateUser (CreateUserRequest) returns (CreateUserResponse);\n    rpc WatchUserEvents (WatchEventsRequest) returns (stream UserEvent);\n    // ^ Server streaming: server sends multiple responses for one request\n    rpc BulkImportUsers (stream ImportUserRequest) returns (ImportResult);\n    // ^ Client streaming: client sends stream, server sends single response\n}\n\nmessage GetUserRequest {\n    int64 user_id = 1;\n}\n\nmessage GetUserResponse {\n    int64 user_id = 1;\n    string name = 2;\n    string email = 3;\n    UserRole role = 4;\n    google.protobuf.Timestamp created_at = 5;\n}\n\nenum UserRole {\n    USER_ROLE_UNSPECIFIED = 0;\n    USER_ROLE_ADMIN = 1;\n    USER_ROLE_VIEWER = 2;\n}\n</code></pre>\n<p>Generate code: <code>protoc --java_out=. --grpc-java_out=. user_service.proto</code></p>\n<p><strong>Java Spring Boot gRPC server:</strong></p>\n<pre><code class=\"language-java\">@GrpcService\npublic class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {\n\n    @Override\n    public void getUser(GetUserRequest request, StreamObserver&#x3C;GetUserResponse> observer) {\n        try {\n            User user = userRepository.findById(request.getUserId())\n                .orElseThrow(() -> Status.NOT_FOUND\n                    .withDescription(\"User not found: \" + request.getUserId())\n                    .asRuntimeException());\n\n            observer.onNext(GetUserResponse.newBuilder()\n                .setUserId(user.getId())\n                .setName(user.getName())\n                .setEmail(user.getEmail())\n                .setRole(UserRole.forNumber(user.getRoleOrdinal()))\n                .setCreatedAt(Timestamps.fromMillis(user.getCreatedAt().toEpochMilli()))\n                .build());\n            observer.onCompleted();\n        } catch (StatusRuntimeException e) {\n            observer.onError(e);\n        }\n    }\n\n    // Server streaming:\n    @Override\n    public void watchUserEvents(WatchEventsRequest request,\n                                 StreamObserver&#x3C;UserEvent> observer) {\n        eventBus.subscribe(request.getUserId(), event -> {\n            if (observer.isReady()) {\n                observer.onNext(UserEvent.from(event));\n            }\n        });\n        // Stream stays open until client disconnects\n    }\n}\n</code></pre>\n<p><strong>gRPC advantages:</strong></p>\n<ul>\n<li>HTTP/2 multiplexing: multiple RPC calls over one TCP connection</li>\n<li>Bidirectional streaming: real-time updates without WebSockets</li>\n<li>Strong typing: protobuf schema enforced at compile time</li>\n<li>Code generation: client stubs auto-generated for 12+ languages</li>\n<li>Deadlines/timeouts: first-class in the protocol</li>\n</ul>\n<p><strong>gRPC disadvantages:</strong></p>\n<ul>\n<li>Not browser-native: requires gRPC-Web proxy (Envoy) for browser clients</li>\n<li>Binary format: cannot debug with curl; need grpcurl or Postman with gRPC support</li>\n<li>Schema changes: require careful backward compatibility (<code>reserved</code> field numbers, avoid renaming)</li>\n<li>Operational complexity: TLS required in many environments</li>\n</ul>\n<h2>GraphQL: Flexible Queries for Complex Data Graphs</h2>\n<p>GraphQL lets clients specify exactly the data they need — no over-fetching, no under-fetching.</p>\n<pre><code class=\"language-graphql\"># Schema definition:\ntype User {\n    id: ID!\n    name: String!\n    email: String!\n    orders(first: Int, after: String): OrderConnection\n    recommendedProducts(limit: Int): [Product]\n}\n\ntype Order {\n    id: ID!\n    total: Float!\n    status: OrderStatus!\n    items: [OrderItem!]!\n    createdAt: DateTime!\n}\n\n# Client query — ask for exactly what's needed:\nquery GetUserDashboard($userId: ID!) {\n    user(id: $userId) {\n        name\n        email\n        orders(first: 5) {\n            edges {\n                node {\n                    id\n                    total\n                    status\n                    createdAt\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>The N+1 problem in GraphQL:</strong></p>\n<p>Without a DataLoader, a query for 10 users with their orders runs 1 + 10 = 11 queries:</p>\n<pre><code>SELECT * FROM users LIMIT 10;\nSELECT * FROM orders WHERE user_id = 1;\nSELECT * FROM orders WHERE user_id = 2;\n...\n</code></pre>\n<p>DataLoader batches these into 2 queries:</p>\n<pre><code class=\"language-java\">@Component\npublic class OrderDataLoader implements BatchLoader&#x3C;Long, List&#x3C;Order>> {\n    @Override\n    public CompletionStage&#x3C;List&#x3C;List&#x3C;Order>>> load(List&#x3C;Long> userIds) {\n        return CompletableFuture.supplyAsync(() ->\n            orderRepository.findByUserIdIn(userIds)\n                .stream()\n                .collect(groupingBy(Order::getUserId))\n                .entrySet()\n                .stream()\n                .map(entry -> entry.getValue())\n                .collect(toList())\n        );\n    }\n}\n</code></pre>\n<p><strong>GraphQL disadvantages:</strong></p>\n<ul>\n<li>Complex queries (deep nesting, broad fan-out) can be computationally expensive — add query depth limiting and cost analysis</li>\n<li>HTTP caching: all queries go to POST /graphql — CDN caching is harder</li>\n<li>Over-flexible: clients can request any combination → hard to predict/optimize backend performance</li>\n<li>Error handling: HTTP always returns 200, errors are in the response body — breaks standard monitoring</li>\n</ul>\n<h2>Performance Comparison</h2>\n<pre><code>Latency benchmark (local, 8-core, simple object fetch):\nREST JSON (HTTP/1.1):    8ms P50,  15ms P99\nREST JSON (HTTP/2):      5ms P50,  10ms P99\ngRPC (HTTP/2 + protobuf): 2ms P50,   5ms P99\nGraphQL (simple query):   6ms P50,  14ms P99\n\nThroughput (requests/second, single connection):\nREST JSON:     5,000 RPS\ngRPC:         15,000 RPS   (~3× due to HTTP/2 + binary serialization)\nGraphQL:       4,000 RPS   (schema validation overhead)\n</code></pre>\n<p>gRPC's throughput advantage comes from HTTP/2 multiplexing (no head-of-line blocking) and binary protobuf serialization. For internal service-to-service calls at high volume, this matters.</p>\n<h2>Schema Evolution and Backward Compatibility</h2>\n<p><strong>REST:</strong> No formal mechanism. In practice: URL versioning (<code>/v1/</code>, <code>/v2/</code>), add-only field changes, deprecation headers. Works but requires documentation discipline.</p>\n<p><strong>gRPC/protobuf schema evolution:</strong></p>\n<pre><code class=\"language-protobuf\">// Original message:\nmessage CreateUserRequest {\n    string name = 1;\n    string email = 2;\n}\n\n// SAFE additions:\nmessage CreateUserRequest {\n    string name = 1;\n    string email = 2;\n    string phone = 3;      // New optional field — old clients ignore it\n    UserPreferences prefs = 4;\n}\n\n// DANGEROUS (breaks clients):\nmessage CreateUserRequest {\n    string full_name = 1;  // Renamed field 1 → binary format compatible, but confusing\n    string email = 2;\n    // name field removed → old clients sending field 1 still work (it's just ignored)\n    reserved 3;            // Reserve old field number if you remove field phone\n    reserved \"phone\";      // Reserve old field name\n}\n</code></pre>\n<p><strong>GraphQL deprecation:</strong></p>\n<pre><code class=\"language-graphql\">type User {\n    name: String\n    fullName: String @deprecated(reason: \"Use `name` instead\")\n}\n</code></pre>\n<p>gRPC's protobuf rules are the most explicit: field numbers are permanent, removal requires <code>reserved</code>. REST's flexibility is also its fragility — without discipline, breaking changes slip through.</p>\n<h2>When to Use Each</h2>\n<p><strong>Use REST when:</strong></p>\n<ul>\n<li>External-facing API (third-party developers, mobile apps, browsers)</li>\n<li>Team lacks protobuf expertise</li>\n<li>Standard HTTP caching is important (CDN, browser cache)</li>\n<li>Simple CRUD operations with no streaming requirements</li>\n</ul>\n<p><strong>Use gRPC when:</strong></p>\n<ul>\n<li>Internal service-to-service communication at high throughput</li>\n<li>Polyglot environment (Go services talking to Java services)</li>\n<li>Streaming is required (real-time event subscriptions)</li>\n<li>Strong typing and auto-generated clients reduce contract drift risk</li>\n</ul>\n<p><strong>Use GraphQL when:</strong></p>\n<ul>\n<li>Frontend teams need flexibility to compose data without backend changes</li>\n<li>Complex data graph with many entity relationships (social graph, product catalog with variants/options)</li>\n<li>Multiple clients with different data requirements (mobile needs less data than web)</li>\n<li>BFF (Backend for Frontend) layer serving a specific client type</li>\n</ul>\n<p><strong>Common pattern in production:</strong></p>\n<pre><code>External clients (browser, mobile)\n    → REST/GraphQL API Gateway\n\nInternal services\n    → gRPC for synchronous service calls\n    → Kafka/SQS for async event-driven communication\n</code></pre>\n<p>The API surface visible to external developers should be stable and REST/GraphQL. Internal service communication can afford gRPC's operational requirements in exchange for performance and type safety.</p>\n","tableOfContents":[{"id":"rest-the-default-for-good-reason","text":"REST: The Default for Good Reason","level":2},{"id":"grpc-performance-and-strong-contracts","text":"gRPC: Performance and Strong Contracts","level":2},{"id":"graphql-flexible-queries-for-complex-data-graphs","text":"GraphQL: Flexible Queries for Complex Data Graphs","level":2},{"id":"performance-comparison","text":"Performance Comparison","level":2},{"id":"schema-evolution-and-backward-compatibility","text":"Schema Evolution and Backward Compatibility","level":2},{"id":"when-to-use-each","text":"When to Use Each","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why — by exploring system state through metrics, traces, and logs without needing to know in advance…"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory — store events instead of state, derive state by replaying events — is sou…"},{"title":"Multi-Tenancy Architecture: Database, Application, and Infrastructure Patterns","description":"Production multi-tenancy: database isolation models (shared schema, shared database, separate database), tenant routing, data partitioning strategies, cross-tenant query prevention, Spring Boot tenant context propagation, and the trade-offs at each isolation level.","date":"2025-05-24","category":"System Design","tags":["multi-tenancy","saas","system design","database","spring boot","architecture","isolation"],"featured":false,"affiliateSection":"system-design-courses","slug":"multi-tenancy-architecture","readingTime":"8 min read","excerpt":"Multi-tenancy is the architecture pattern where a single deployed instance of a software system serves multiple customers (tenants), with each tenant's data logically or physically isolated from others. It's the foundati…"}]},"__N_SSG":true}