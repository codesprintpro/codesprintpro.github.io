{"pageProps":{"post":{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength — and its complexity. Misconfigured security is worse than no security, because it give…","contentHtml":"<p>Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength — and its complexity. Misconfigured security is worse than no security, because it gives false assurance. This article covers production-grade Spring Security OAuth2 implementation: token validation, authorization rules, and the attack vectors you must close.</p>\n<h2>The OAuth2 / JWT Architecture</h2>\n<p>Modern web applications use OAuth2 Bearer tokens — typically JWTs — for stateless authentication:</p>\n<pre><code>Client → POST /api/orders\n         Authorization: Bearer eyJhbGci...\n\nSpring Security filter chain:\n1. JwtAuthenticationFilter extracts token from Authorization header\n2. JwtDecoder validates signature, expiry, issuer, audience\n3. JwtAuthenticationConverter extracts roles from claims\n4. SecurityContextHolder stores Authentication\n5. @PreAuthorize or SecurityConfig.authorizeHttpRequests() checks roles\n6. Controller method executes with authenticated principal\n</code></pre>\n<p>The token is issued by an Authorization Server (Auth0, Keycloak, AWS Cognito, or your own Spring Authorization Server). The API (Resource Server) validates tokens without calling the Auth Server on each request — it uses the Auth Server's public key to verify the JWT signature locally.</p>\n<h2>Resource Server Configuration</h2>\n<pre><code class=\"language-java\">@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity  // Enables @PreAuthorize, @PostAuthorize, @Secured\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // Disable CSRF for stateless REST APIs (JWT carries CSRF protection implicitly):\n            .csrf(csrf -> csrf.disable())\n            // Stateless sessions — no HttpSession created:\n            .sessionManagement(session ->\n                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            // Authorization rules:\n            .authorizeHttpRequests(auth -> auth\n                // Public endpoints:\n                .requestMatchers(\"/actuator/health\", \"/actuator/info\").permitAll()\n                .requestMatchers(HttpMethod.POST, \"/api/auth/**\").permitAll()\n                // All other endpoints require authentication:\n                .anyRequest().authenticated()\n            )\n            // Configure as OAuth2 Resource Server with JWT:\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt\n                    .jwtAuthenticationConverter(jwtAuthenticationConverter())\n                )\n                // Custom 401 response (default is an empty 401):\n                .authenticationEntryPoint((request, response, ex) -> {\n                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                    response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n                    response.getWriter().write(\n                        \"{\\\"error\\\":\\\"unauthorized\\\",\\\"message\\\":\\\"\" + ex.getMessage() + \"\\\"}\"\n                    );\n                })\n            );\n\n        return http.build();\n    }\n\n    @Bean\n    public JwtAuthenticationConverter jwtAuthenticationConverter() {\n        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter =\n            new JwtGrantedAuthoritiesConverter();\n        // Read roles from 'roles' claim (not 'scope' — which is the default):\n        grantedAuthoritiesConverter.setAuthoritiesClaimName(\"roles\");\n        // Prefix roles with ROLE_ for Spring Security's hasRole() to work:\n        grantedAuthoritiesConverter.setAuthorityPrefix(\"ROLE_\");\n\n        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();\n        jwtConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);\n        return jwtConverter;\n    }\n}\n</code></pre>\n<p><strong>JWT decoder configuration — critical security property:</strong></p>\n<pre><code class=\"language-java\">@Bean\npublic JwtDecoder jwtDecoder() {\n    // Option 1: JWKS (recommended for production — Auth Server rotates keys)\n    // Spring fetches public keys from the Auth Server's JWKS endpoint:\n    NimbusJwtDecoder decoder = NimbusJwtDecoder\n        .withJwkSetUri(\"https://auth.example.com/.well-known/jwks.json\")\n        .build();\n\n    // Add custom validation (in addition to signature and expiry):\n    OAuth2TokenValidator&#x3C;Jwt> audienceValidator = token -> {\n        if (token.getAudience().contains(\"order-service\")) {\n            return OAuth2TokenValidatorResult.success();\n        }\n        return OAuth2TokenValidatorResult.failure(\n            new OAuth2Error(\"invalid_token\", \"Wrong audience\", null));\n    };\n\n    OAuth2TokenValidator&#x3C;Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(\n        \"https://auth.example.com\"\n    );\n\n    decoder.setJwtValidator(new DelegatingOAuth2TokenValidator&#x3C;>(\n        withIssuer,\n        audienceValidator\n    ));\n\n    return decoder;\n}\n\n// Option 2: Symmetric secret (simpler, no key rotation — for internal services only):\n@Bean\npublic JwtDecoder jwtDecoderSymmetric(@Value(\"${jwt.secret}\") String secret) {\n    SecretKeySpec key = new SecretKeySpec(secret.getBytes(), \"HmacSHA256\");\n    return NimbusJwtDecoder.withSecretKey(key).build();\n}\n</code></pre>\n<p><strong>Always validate the <code>aud</code> (audience) claim.</strong> A JWT issued for <code>frontend-app</code> should not be valid for <code>order-service</code>. Without audience validation, any service that trusts the same Auth Server can use tokens issued for other services — a privilege escalation vulnerability.</p>\n<h2>Method-Level Security</h2>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"/api/orders\")\npublic class OrderController {\n\n    // Anyone with ROLE_USER or ROLE_ADMIN can read:\n    @GetMapping(\"/{id}\")\n    @PreAuthorize(\"hasAnyRole('USER', 'ADMIN')\")\n    public ResponseEntity&#x3C;OrderDto> getOrder(@PathVariable Long id,\n                                              Authentication auth) {\n        return ResponseEntity.ok(orderService.findById(id));\n    }\n\n    // Only ADMIN can delete:\n    @DeleteMapping(\"/{id}\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public ResponseEntity&#x3C;Void> deleteOrder(@PathVariable Long id) {\n        orderService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n\n    // User can only see their own orders (SpEL expression):\n    @GetMapping(\"/my-orders\")\n    @PreAuthorize(\"isAuthenticated()\")\n    public ResponseEntity&#x3C;List&#x3C;OrderDto>> getMyOrders(Authentication auth) {\n        String userId = auth.getName();  // Subject from JWT\n        return ResponseEntity.ok(orderService.findByUserId(userId));\n    }\n\n    // Complex rule: Admin can view any order; user can view only their own:\n    @GetMapping(\"/{id}/details\")\n    @PreAuthorize(\"hasRole('ADMIN') or @orderSecurity.isOwner(authentication, #id)\")\n    public ResponseEntity&#x3C;OrderDetailsDto> getOrderDetails(@PathVariable Long id) {\n        return ResponseEntity.ok(orderService.getDetails(id));\n    }\n}\n\n// Custom security bean for complex rules:\n@Component(\"orderSecurity\")\npublic class OrderSecurityService {\n\n    @Autowired\n    private OrderRepository orderRepository;\n\n    public boolean isOwner(Authentication auth, Long orderId) {\n        String currentUserId = auth.getName();\n        return orderRepository.findById(orderId)\n            .map(order -> order.getUserId().equals(currentUserId))\n            .orElse(false);\n    }\n}\n</code></pre>\n<h2>Extracting the Authenticated User</h2>\n<pre><code class=\"language-java\">// Method 1: Authentication parameter (Spring injects automatically):\n@GetMapping(\"/profile\")\npublic ResponseEntity&#x3C;UserProfile> getProfile(Authentication auth) {\n    Jwt jwt = (Jwt) auth.getPrincipal();\n    String userId = jwt.getSubject();           // 'sub' claim\n    String email = jwt.getClaimAsString(\"email\");\n    List&#x3C;String> roles = jwt.getClaimAsStringList(\"roles\");\n    return ResponseEntity.ok(userService.getProfile(userId));\n}\n\n// Method 2: @AuthenticationPrincipal annotation:\n@GetMapping(\"/profile\")\npublic ResponseEntity&#x3C;UserProfile> getProfile(@AuthenticationPrincipal Jwt jwt) {\n    String userId = jwt.getSubject();\n    // ... same as above, cleaner signature\n}\n\n// Method 3: SecurityContextHolder (for non-controller code):\npublic String getCurrentUserId() {\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth instanceof JwtAuthenticationToken jwtAuth) {\n        return jwtAuth.getToken().getSubject();\n    }\n    throw new IllegalStateException(\"No authenticated user in context\");\n}\n\n// Custom annotation for cleaner controller signatures:\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\n@AuthenticationPrincipal(expression = \"subject\")  // Extract 'sub' directly\npublic @interface CurrentUserId {}\n\n// Usage:\n@GetMapping(\"/profile\")\npublic ResponseEntity&#x3C;UserProfile> getProfile(@CurrentUserId String userId) {\n    return ResponseEntity.ok(userService.getProfile(userId));\n}\n</code></pre>\n<h2>Custom UserDetailsService with Database Lookup</h2>\n<p>When using username/password authentication (not OAuth2 external IdP):</p>\n<pre><code class=\"language-java\">@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    @Transactional(readOnly = true)\n    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {\n        User user = userRepository.findByEmail(email)\n            .orElseThrow(() -> new UsernameNotFoundException(\"User not found: \" + email));\n\n        if (!user.isEnabled()) {\n            throw new DisabledException(\"Account disabled\");\n        }\n\n        return org.springframework.security.core.userdetails.User.builder()\n            .username(user.getId().toString())  // Use ID as username (avoids email exposure)\n            .password(user.getPasswordHash())\n            .authorities(user.getRoles().stream()\n                .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role.name()))\n                .collect(Collectors.toList()))\n            .accountExpired(false)\n            .accountLocked(user.isLocked())\n            .credentialsExpired(false)\n            .disabled(!user.isEnabled())\n            .build();\n    }\n}\n\n@Configuration\npublic class PasswordConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        // BCrypt with cost factor 12 (default is 10):\n        // Higher = more CPU per hash = harder to brute force\n        return new BCryptPasswordEncoder(12);\n    }\n}\n</code></pre>\n<h2>JWT Token Issuing (Authorization Server Side)</h2>\n<p>If you're building your own token endpoint (not using an external IdP):</p>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n\n    @Autowired private AuthenticationManager authenticationManager;\n    @Autowired private JwtService jwtService;\n    @Autowired private RefreshTokenService refreshTokenService;\n\n    @PostMapping(\"/login\")\n    public ResponseEntity&#x3C;TokenResponse> login(@Valid @RequestBody LoginRequest request) {\n        Authentication auth = authenticationManager.authenticate(\n            new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())\n        );\n\n        UserDetails user = (UserDetails) auth.getPrincipal();\n        String accessToken = jwtService.generateAccessToken(user);\n        String refreshToken = refreshTokenService.createRefreshToken(user.getUsername());\n\n        return ResponseEntity.ok(new TokenResponse(accessToken, refreshToken));\n    }\n\n    @PostMapping(\"/refresh\")\n    public ResponseEntity&#x3C;TokenResponse> refresh(@RequestBody RefreshRequest request) {\n        RefreshToken token = refreshTokenService.findByToken(request.getRefreshToken())\n            .orElseThrow(() -> new ResponseStatusException(HttpStatus.UNAUTHORIZED, \"Invalid refresh token\"));\n\n        if (token.isExpired()) {\n            refreshTokenService.delete(token);\n            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, \"Refresh token expired\");\n        }\n\n        // Rotation: invalidate old refresh token, issue new one:\n        refreshTokenService.delete(token);\n        String newRefreshToken = refreshTokenService.createRefreshToken(token.getUserId());\n        String newAccessToken = jwtService.generateAccessToken(token.getUserId());\n\n        return ResponseEntity.ok(new TokenResponse(newAccessToken, newRefreshToken));\n    }\n}\n\n@Service\npublic class JwtService {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    @Value(\"${jwt.expiry-seconds:900}\")  // 15 minutes default\n    private long expirySeconds;\n\n    public String generateAccessToken(UserDetails user) {\n        Map&#x3C;String, Object> claims = new HashMap&#x3C;>();\n        claims.put(\"roles\", user.getAuthorities().stream()\n            .map(GrantedAuthority::getAuthority)\n            .map(r -> r.replace(\"ROLE_\", \"\"))\n            .collect(Collectors.toList()));\n\n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(user.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + expirySeconds * 1000))\n            .setIssuer(\"https://api.example.com\")\n            .setAudience(\"order-service\")\n            .signWith(Keys.hmacShaKeyFor(secret.getBytes()), SignatureAlgorithm.HS256)\n            .compact();\n    }\n}\n</code></pre>\n<h2>Security Pitfalls</h2>\n<p><strong>1. Algorithm confusion attack (alg=none)</strong></p>\n<pre><code class=\"language-java\">// VULNERABLE: trusting the 'alg' header from the token itself\n// An attacker sets alg=none in the JWT header → no signature verification\n\n// SAFE: Use a typed decoder that enforces the algorithm:\nNimbusJwtDecoder decoder = NimbusJwtDecoder\n    .withJwkSetUri(\"...\")\n    .jwsAlgorithm(SignatureAlgorithm.RS256)  // Enforce RS256 only\n    .build();\n</code></pre>\n<p><strong>2. Missing audience validation</strong></p>\n<pre><code class=\"language-java\">// VULNERABLE: Any service trusting the same IdP accepts this token\n// SAFE: Validate 'aud' claim (shown above in jwtDecoder() configuration)\n</code></pre>\n<p><strong>3. Sensitive data in JWT payload</strong></p>\n<pre><code class=\"language-java\">// JWT payload is Base64-encoded, NOT encrypted — anyone can decode it\n// Never put in JWT payload:\n// - Passwords (obviously)\n// - PII beyond user ID\n// - Internal system IDs that reveal architecture\n// - Anything you don't want logged when tokens are logged\n\n// JWT payload is visible to the client and any intermediate proxy:\nString payload = new String(Base64.getDecoder().decode(token.split(\"\\\\.\")[1]));\n// → {\"sub\":\"user123\",\"roles\":[\"USER\"],\"email\":\"alice@example.com\"}\n</code></pre>\n<p><strong>4. Long-lived access tokens</strong></p>\n<pre><code>Access token lifetime: 15 minutes (recommended for sensitive operations)\nRefresh token lifetime: 7-30 days\n\nShort access tokens limit the window of exposure if stolen.\nRefresh tokens enable staying logged in without re-authentication.\nRefresh token rotation (issue new refresh token on each use) limits replay attacks.\n</code></pre>\n<p><strong>5. CORS misconfiguration allowing any origin</strong></p>\n<pre><code class=\"language-java\">// VULNERABLE:\n.cors(cors -> cors.configurationSource(request -> {\n    CorsConfiguration config = new CorsConfiguration();\n    config.addAllowedOrigin(\"*\");  // ANY origin — allows cross-site token theft\n    config.addAllowedHeader(\"*\");\n    config.addAllowedMethod(\"*\");\n    return config;\n}))\n\n// SAFE: Explicit allowed origins only:\n.cors(cors -> cors.configurationSource(request -> {\n    CorsConfiguration config = new CorsConfiguration();\n    config.setAllowedOrigins(List.of(\"https://app.example.com\", \"https://admin.example.com\"));\n    config.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\n    config.setAllowedHeaders(List.of(\"Authorization\", \"Content-Type\"));\n    config.setAllowCredentials(true);\n    config.setMaxAge(3600L);\n    return config;\n}))\n</code></pre>\n<p>Spring Security's layered defense — filter chain, method security, CORS configuration, JWT validation — is effective when each layer is properly configured. The common failure mode is not in individual configuration items but in the gaps: a misconfigured audience validator, a wildcard CORS origin, an overly long token lifetime. Review each configuration decision against the threat model for your specific application.</p>\n","tableOfContents":[{"id":"the-oauth2-jwt-architecture","text":"The OAuth2 / JWT Architecture","level":2},{"id":"resource-server-configuration","text":"Resource Server Configuration","level":2},{"id":"method-level-security","text":"Method-Level Security","level":2},{"id":"extracting-the-authenticated-user","text":"Extracting the Authenticated User","level":2},{"id":"custom-userdetailsservice-with-database-lookup","text":"Custom UserDetailsService with Database Lookup","level":2},{"id":"jwt-token-issuing-authorization-server-side","text":"JWT Token Issuing (Authorization Server Side)","level":2},{"id":"security-pitfalls","text":"Security Pitfalls","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th…"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin…"},{"title":"Scaling Spring Boot Applications to Handle 10 Million Daily Active Users","description":"A practical performance engineering guide: load balancing, horizontal scaling, database tuning, JVM optimization, autoscaling, and the observability stack to find and fix bottlenecks before they page you.","date":"2025-05-28","category":"Java","tags":["spring boot","java","scaling","performance","jvm","kubernetes","prometheus","grafana"],"featured":false,"affiliateSection":"java-courses","slug":"scaling-spring-boot-10m-dau","readingTime":"10 min read","excerpt":"10 million daily active users is not an exotic scale — it's where a successful mid-stage startup or a growing enterprise service lands. At this scale, the things that worked for 100,000 users start breaking in interestin…"}]},"__N_SSG":true}