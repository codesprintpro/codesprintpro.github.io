{"pageProps":{"post":{"title":"WebSocket and SSE for Real-Time Systems: Architecture and Production Patterns","description":"Building real-time features at scale: WebSocket vs SSE trade-offs, Spring Boot WebSocket implementation with STOMP, connection management, horizontal scaling with Redis pub/sub, SSE for one-directional streaming, and handling reconnection and backpressure.","date":"2025-05-04","category":"System Design","tags":["websocket","sse","real-time","spring boot","redis","stomp","pub-sub","system design"],"featured":false,"affiliateSection":"system-design-courses","slug":"websocket-sse-real-time","readingTime":"7 min read","excerpt":"Real-time features — live notifications, collaborative editing, live dashboards, streaming data — require pushing data from server to client without the client repeatedly polling. HTTP polling wastes resources and adds l…","contentHtml":"<p>Real-time features — live notifications, collaborative editing, live dashboards, streaming data — require pushing data from server to client without the client repeatedly polling. HTTP polling wastes resources and adds latency. WebSocket and Server-Sent Events (SSE) solve this differently, and choosing the wrong protocol for your use case leads to unnecessary complexity.</p>\n<h2>WebSocket vs. SSE: Choosing the Right Protocol</h2>\n<pre><code>WebSocket:\n┌─────────┐  HTTP Upgrade   ┌────────┐\n│ Client  │ ──────────────→ │ Server │\n│         │ ←────────────── │        │\n│         │    TCP socket    │        │\n│         │ ←────────────── │        │  (bidirectional)\n│         │ ──────────────→ │        │\n└─────────┘                 └────────┘\n\nSSE (Server-Sent Events):\n┌─────────┐  HTTP GET       ┌────────┐\n│ Client  │ ──────────────→ │ Server │\n│         │ ←────────────── │        │  data: event1\n│         │ ←────────────── │        │  data: event2  (one-directional)\n│         │ ←────────────── │        │  data: event3\n└─────────┘                 └────────┘\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Factor</th>\n<th>WebSocket</th>\n<th>SSE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Direction</td>\n<td>Bidirectional</td>\n<td>Server → Client only</td>\n</tr>\n<tr>\n<td>Protocol</td>\n<td>ws:// (TCP upgrade)</td>\n<td>HTTP (text/event-stream)</td>\n</tr>\n<tr>\n<td>Reconnection</td>\n<td>Manual</td>\n<td>Automatic (browser handles)</td>\n</tr>\n<tr>\n<td>Load balancer support</td>\n<td>Complex (sticky sessions)</td>\n<td>Standard HTTP</td>\n</tr>\n<tr>\n<td>CDN/proxy compatible</td>\n<td>Rarely</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Max connections/server</td>\n<td>~50,000</td>\n<td>~50,000</td>\n</tr>\n<tr>\n<td>Browser support</td>\n<td>All</td>\n<td>All (no IE)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Use WebSocket when:</strong> bidirectional communication is required (chat, collaborative editing, multiplayer games).</p>\n<p><strong>Use SSE when:</strong> server pushes updates, client only reads (live dashboards, notifications, activity feeds, progress updates). SSE is simpler, works through standard HTTP infrastructure, and handles reconnection automatically.</p>\n<h2>SSE Implementation</h2>\n<p>SSE is the often-overlooked simpler alternative. For one-directional streaming, it's almost always the right choice:</p>\n<pre><code class=\"language-java\">// Spring Boot SSE endpoint:\n@RestController\n@RequestMapping(\"/api/notifications\")\npublic class NotificationController {\n\n    @Autowired\n    private SseEmitterRegistry emitterRegistry;\n\n    @GetMapping(value = \"/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n    public SseEmitter streamNotifications(@AuthenticationPrincipal Jwt jwt) {\n        String userId = jwt.getSubject();\n\n        // SseEmitter with 5-minute timeout (reconnect handles longer sessions):\n        SseEmitter emitter = new SseEmitter(5 * 60 * 1000L);\n\n        // Register emitter so other parts of the system can push to this user:\n        emitterRegistry.register(userId, emitter);\n\n        // Cleanup on connection close:\n        emitter.onCompletion(() -> emitterRegistry.remove(userId, emitter));\n        emitter.onTimeout(() -> emitterRegistry.remove(userId, emitter));\n        emitter.onError(ex -> emitterRegistry.remove(userId, emitter));\n\n        // Send initial state (so client doesn't wait for first event):\n        try {\n            emitter.send(SseEmitter.event()\n                .name(\"connected\")\n                .data(\"{\\\"status\\\":\\\"connected\\\",\\\"userId\\\":\\\"\" + userId + \"\\\"}\")\n                .id(\"0\")\n            );\n        } catch (IOException e) {\n            emitter.completeWithError(e);\n        }\n\n        return emitter;\n    }\n}\n\n// Registry of active SSE connections:\n@Component\npublic class SseEmitterRegistry {\n\n    // CopyOnWriteArrayList: multiple emitters per user (same user, multiple tabs)\n    private final Map&#x3C;String, CopyOnWriteArrayList&#x3C;SseEmitter>> userEmitters =\n        new ConcurrentHashMap&#x3C;>();\n\n    public void register(String userId, SseEmitter emitter) {\n        userEmitters.computeIfAbsent(userId, k -> new CopyOnWriteArrayList&#x3C;>()).add(emitter);\n    }\n\n    public void remove(String userId, SseEmitter emitter) {\n        CopyOnWriteArrayList&#x3C;SseEmitter> emitters = userEmitters.get(userId);\n        if (emitters != null) {\n            emitters.remove(emitter);\n            if (emitters.isEmpty()) {\n                userEmitters.remove(userId);\n            }\n        }\n    }\n\n    public void sendToUser(String userId, String eventName, Object data) {\n        CopyOnWriteArrayList&#x3C;SseEmitter> emitters = userEmitters.get(userId);\n        if (emitters == null || emitters.isEmpty()) return;\n\n        String json = objectMapper.writeValueAsString(data);\n        List&#x3C;SseEmitter> dead = new ArrayList&#x3C;>();\n\n        for (SseEmitter emitter : emitters) {\n            try {\n                emitter.send(SseEmitter.event()\n                    .name(eventName)\n                    .data(json)\n                    .id(String.valueOf(System.currentTimeMillis()))\n                );\n            } catch (IOException e) {\n                dead.add(emitter);  // Connection is dead\n            }\n        }\n\n        dead.forEach(e -> remove(userId, e));\n    }\n}\n</code></pre>\n<p><strong>Client-side SSE (automatic reconnection built in):</strong></p>\n<pre><code class=\"language-javascript\">const eventSource = new EventSource('/api/notifications/stream', {\n  withCredentials: true  // Send cookies for authentication\n});\n\neventSource.addEventListener('order-update', (event) => {\n  const update = JSON.parse(event.data);\n  updateOrderStatus(update.orderId, update.status);\n});\n\neventSource.addEventListener('notification', (event) => {\n  const notification = JSON.parse(event.data);\n  showNotification(notification.message);\n});\n\n// Browser automatically reconnects on disconnect\n// The Last-Event-ID header is sent on reconnect — server can replay missed events\neventSource.onerror = (error) => {\n  console.log('SSE error:', error);\n  // Browser will retry automatically — exponential backoff\n};\n</code></pre>\n<h2>WebSocket with STOMP (Spring Boot)</h2>\n<p>STOMP (Simple Text Oriented Messaging Protocol) adds message routing over WebSocket — subscribe to topics, send to specific users:</p>\n<pre><code class=\"language-java\">@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        // Use built-in simple broker for topics and queues:\n        config.enableSimpleBroker(\"/topic\", \"/queue\");\n        // Or use external broker (RabbitMQ/ActiveMQ) for production:\n        // config.enableStompBrokerRelay(\"/topic\", \"/queue\")\n        //     .setRelayHost(\"rabbitmq.internal\")\n        //     .setRelayPort(61613);\n\n        // Application destination prefix (for @MessageMapping):\n        config.setApplicationDestinationPrefixes(\"/app\");\n\n        // User-specific destination prefix (for SimpMessagingTemplate.convertAndSendToUser):\n        config.setUserDestinationPrefix(\"/user\");\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(\"/ws\")\n            .setAllowedOrigins(\"https://app.example.com\")  // CORS\n            .withSockJS();  // SockJS fallback for environments blocking WebSocket\n    }\n}\n\n// Controller: handle messages FROM client:\n@Controller\npublic class ChatController {\n\n    @Autowired\n    private SimpMessagingTemplate messagingTemplate;\n\n    // Client sends to /app/chat.sendMessage → broadcast to /topic/chat\n    @MessageMapping(\"/chat.sendMessage\")\n    @SendTo(\"/topic/chat\")  // Broadcast to all subscribers\n    public ChatMessage sendMessage(@Payload ChatMessage message,\n                                   Principal principal) {\n        message.setSender(principal.getName());\n        message.setTimestamp(Instant.now());\n        return message;\n    }\n\n    // Send to specific user's private queue:\n    public void sendPrivateMessage(String userId, Notification notification) {\n        // Client subscribes to /user/queue/notifications\n        // This sends to THAT specific user's queue:\n        messagingTemplate.convertAndSendToUser(\n            userId,\n            \"/queue/notifications\",\n            notification\n        );\n    }\n}\n</code></pre>\n<p><strong>WebSocket authentication (often overlooked):</strong></p>\n<pre><code class=\"language-java\">@Component\npublic class WebSocketAuthInterceptor implements ChannelInterceptor {\n\n    @Autowired\n    private JwtService jwtService;\n\n    @Override\n    public Message&#x3C;?> preSend(Message&#x3C;?> message, MessageChannel channel) {\n        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(\n            message, StompHeaderAccessor.class);\n\n        if (accessor != null &#x26;&#x26; StompCommand.CONNECT.equals(accessor.getCommand())) {\n            // Extract JWT from Authorization header in CONNECT frame:\n            String authHeader = accessor.getFirstNativeHeader(\"Authorization\");\n            if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n                throw new MessagingException(\"Missing or invalid Authorization header\");\n            }\n\n            String token = authHeader.substring(7);\n            Authentication auth = jwtService.validateAndGetAuth(token);\n\n            // Set the authenticated principal on the WebSocket session:\n            accessor.setUser(auth);\n        }\n\n        return message;\n    }\n}\n</code></pre>\n<h2>Horizontal Scaling: The Core Problem</h2>\n<p>Each server instance maintains its own in-memory set of WebSocket/SSE connections. When an event occurs (e.g., \"order shipped\"), it needs to reach the user's connection — which may be on a different server instance.</p>\n<pre><code>Without Redis pub/sub (BROKEN at scale):\n\nUser connects → Server A (SSE connection stored here)\nOrder ships   → Event processed by Server B\nServer B sends SSE → Nobody receives it (connection is on Server A)\n\nWith Redis pub/sub (CORRECT):\n\nUser connects → Server A (SSE stored)\nOrder ships   → Server B publishes to Redis: channel=\"user:{userId}\", msg=event\nRedis broadcasts → Server A receives it (subscribed to all user channels)\nServer A sends SSE → User receives event ✓\n</code></pre>\n<pre><code class=\"language-java\">// Redis pub/sub for cross-instance SSE delivery:\n@Service\npublic class NotificationPublisher {\n\n    @Autowired\n    private RedisTemplate&#x3C;String, String> redisTemplate;\n\n    public void publishToUser(String userId, NotificationEvent event) {\n        String channel = \"user-notifications:\" + userId;\n        String payload = objectMapper.writeValueAsString(event);\n        redisTemplate.convertAndSend(channel, payload);\n    }\n}\n\n@Service\npublic class NotificationSubscriber implements MessageListener {\n\n    @Autowired\n    private SseEmitterRegistry emitterRegistry;\n\n    @Autowired\n    private RedisMessageListenerContainer container;\n\n    @PostConstruct\n    public void subscribeToAllUsers() {\n        // Subscribe to all user notification channels:\n        container.addMessageListener(this,\n            new PatternTopic(\"user-notifications:*\"));\n    }\n\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        String channel = new String(message.getChannel());\n        String userId = channel.replace(\"user-notifications:\", \"\");\n        String payload = new String(message.getBody());\n\n        // Push to local SSE connection (if user is connected to this instance):\n        emitterRegistry.sendToUser(userId, \"notification\", payload);\n    }\n}\n</code></pre>\n<h2>Backpressure and Slow Clients</h2>\n<p>A client that consumes events slowly creates backpressure. The server must not buffer unboundedly:</p>\n<pre><code class=\"language-java\">// Bounded SSE with overflow handling:\npublic class BoundedSseEmitter {\n\n    private final SseEmitter emitter;\n    private final BlockingQueue&#x3C;SseEvent> queue = new LinkedBlockingQueue&#x3C;>(100);\n    private final AtomicBoolean running = new AtomicBoolean(true);\n\n    public BoundedSseEmitter(SseEmitter emitter) {\n        this.emitter = emitter;\n        // Background thread drains queue to emitter:\n        Thread.ofVirtual().start(this::drain);\n    }\n\n    public boolean offer(SseEvent event) {\n        boolean accepted = queue.offer(event);  // Returns false if queue full\n        if (!accepted) {\n            log.warn(\"SSE queue full for connection — dropping event\");\n            // Or: disconnect slow client\n        }\n        return accepted;\n    }\n\n    private void drain() {\n        while (running.get()) {\n            try {\n                SseEvent event = queue.poll(1, TimeUnit.SECONDS);\n                if (event != null) {\n                    emitter.send(event);\n                }\n            } catch (Exception e) {\n                running.set(false);\n            }\n        }\n    }\n}\n</code></pre>\n<p>Real-time features are rarely the hardest part of a system — they feel complex because HTTP's request-response model is the mental default. Once you internalize that SSE is just a long-lived HTTP response that trickles data, and WebSocket is a bidirectional TCP channel negotiated via HTTP, the implementation patterns become straightforward. The operational complexity (scaling with Redis pub/sub, handling reconnections, managing connection counts) is where production experience matters.</p>\n","tableOfContents":[{"id":"websocket-vs-sse-choosing-the-right-protocol","text":"WebSocket vs. SSE: Choosing the Right Protocol","level":2},{"id":"sse-implementation","text":"SSE Implementation","level":2},{"id":"websocket-with-stomp-spring-boot","text":"WebSocket with STOMP (Spring Boot)","level":2},{"id":"horizontal-scaling-the-core-problem","text":"Horizontal Scaling: The Core Problem","level":2},{"id":"backpressure-and-slow-clients","text":"Backpressure and Slow Clients","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why — by exploring system state through metrics, traces, and logs without needing to know in advance…"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory — store events instead of state, derive state by replaying events — is sou…"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t…"}]},"__N_SSG":true}