{"pageProps":{"post":{"title":"API Design: REST vs GraphQL vs gRPC — When to Use Each","description":"Deep comparison of REST, GraphQL, and gRPC for API design. Learn the trade-offs, use cases, and implementation patterns to choose the right protocol for your system.","date":"2025-03-01","category":"System Design","tags":["api","rest","graphql","grpc","system design","microservices"],"featured":false,"affiliateSection":"system-design-courses","slug":"api-design-rest-graphql-grpc","readingTime":"13 min read","excerpt":"Every microservices architecture makes an implicit bet on an API protocol. REST is familiar but verbose. GraphQL is flexible but complex. gRPC is fast but opinionated. Choosing wrong costs you months of refactoring. This…","contentHtml":"<p>Every microservices architecture makes an implicit bet on an API protocol. REST is familiar but verbose. GraphQL is flexible but complex. gRPC is fast but opinionated. Choosing wrong costs you months of refactoring. This article gives you the mental model to choose right the first time.</p>\n<h2>The Core Trade-off</h2>\n<p>Before diving into code, it helps to internalize the fundamental personality of each protocol. Think of them as different tools in a workshop — a hammer, a screwdriver, and a wrench each solve problems the others can't. The table below is the mental shortcut you'll return to whenever you're evaluating a new API surface.</p>\n<pre><code>REST:     Standard, cacheable, human-readable. Overfetching is the enemy.\nGraphQL:  Client-defined queries. Solves overfetching. Adds query complexity.\ngRPC:     Binary protocol, bidirectional streaming, 10x faster than REST.\n          Requires Protobuf contracts. Not browser-native.\n</code></pre>\n<h2>REST: The Default Choice</h2>\n<p>REST (Representational State Transfer) models your API around <strong>resources</strong> and <strong>HTTP verbs</strong>.</p>\n<p>REST maps your domain objects to URLs and uses standard HTTP methods to express what you want to do with them. This uniformity is REST's superpower — any developer who has used an HTTP API before can guess how your API works without reading the docs. The example below shows the URL structure and verb mapping you should follow for a standard resource.</p>\n<pre><code>Resource: /orders/{id}\nGET    /orders/123         → Retrieve order 123\nPOST   /orders             → Create new order\nPUT    /orders/123         → Replace order 123\nPATCH  /orders/123         → Partial update order 123\nDELETE /orders/123         → Delete order 123\n\nNested resources:\nGET    /orders/123/items   → Items of order 123\nPOST   /orders/123/items   → Add item to order 123\n</code></pre>\n<h3>REST API Design — Getting It Right</h3>\n<p>Good REST goes beyond just using the right HTTP verb — it uses HTTP's semantics correctly, including response codes and headers. The controller below demonstrates several REST best practices: sparse fieldsets to reduce overfetching, the <code>201 Created</code> status with a <code>Location</code> header on creation, and a dedicated PATCH endpoint for partial updates.</p>\n<pre><code class=\"language-java\">@RestController\n@RequestMapping(\"/api/v1/orders\")\npublic class OrderController {\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&#x3C;OrderResponse> getOrder(\n            @PathVariable String id,\n            @RequestParam(required = false) Set&#x3C;String> fields) {  // Sparse fieldsets\n        Order order = orderService.findById(id)\n            .orElseThrow(() -> new OrderNotFoundException(id));\n        return ResponseEntity.ok(OrderResponse.from(order, fields));\n    }\n\n    @PostMapping\n    public ResponseEntity&#x3C;OrderResponse> createOrder(\n            @Valid @RequestBody CreateOrderRequest request,\n            UriComponentsBuilder uriBuilder) {\n        Order order = orderService.create(request);\n        URI location = uriBuilder.path(\"/api/v1/orders/{id}\")\n            .buildAndExpand(order.getId()).toUri();\n        // Return 201 Created with Location header — this is correct REST\n        return ResponseEntity.created(location).body(OrderResponse.from(order));\n    }\n\n    @PatchMapping(\"/{id}/status\")\n    public ResponseEntity&#x3C;OrderResponse> updateStatus(\n            @PathVariable String id,\n            @Valid @RequestBody UpdateStatusRequest request) {\n        Order order = orderService.updateStatus(id, request.getStatus());\n        return ResponseEntity.ok(OrderResponse.from(order));\n    }\n}\n</code></pre>\n<p>The <code>Location</code> header in the <code>201 Created</code> response is something many APIs skip, but it's essential for good REST design — it tells the client exactly where the newly created resource lives without requiring a separate lookup.</p>\n<h3>REST Error Response Standard</h3>\n<p>Error handling is where many REST APIs diverge and create friction for API consumers. RFC 7807 (Problem Details) defines a standard error envelope that any HTTP client can parse consistently. Using this format means your error responses are as predictable as your success responses.</p>\n<pre><code class=\"language-java\">// Problem Details (RFC 7807) — the standardized error format\n@ExceptionHandler(OrderNotFoundException.class)\npublic ResponseEntity&#x3C;ProblemDetail> handleNotFound(OrderNotFoundException ex) {\n    ProblemDetail problem = ProblemDetail.forStatusAndDetail(\n        HttpStatus.NOT_FOUND,\n        \"Order \" + ex.getId() + \" not found\"\n    );\n    problem.setTitle(\"Order Not Found\");\n    problem.setInstance(URI.create(\"/api/v1/orders/\" + ex.getId()));\n    problem.setProperty(\"orderId\", ex.getId());\n    return ResponseEntity.status(404).body(problem);\n}\n\n// Response:\n// {\n//   \"type\": \"about:blank\",\n//   \"title\": \"Order Not Found\",\n//   \"status\": 404,\n//   \"detail\": \"Order abc-123 not found\",\n//   \"instance\": \"/api/v1/orders/abc-123\",\n//   \"orderId\": \"abc-123\"\n// }\n</code></pre>\n<h3>REST Pagination</h3>\n<p>Pagination is a problem every list endpoint must solve, and the choice of strategy affects scalability significantly. Offset-based pagination (<code>?page=2&#x26;size=20</code>) is intuitive but breaks when records are inserted between pages. Cursor-based pagination is stable regardless of concurrent writes and is what you should use for any dataset that changes frequently.</p>\n<pre><code class=\"language-java\">// Cursor-based pagination (preferred for large/changing datasets)\n@GetMapping\npublic ResponseEntity&#x3C;PagedResponse&#x3C;OrderSummary>> listOrders(\n        @RequestParam(required = false) String cursor,     // Opaque cursor (base64 encoded)\n        @RequestParam(defaultValue = \"20\") int limit) {\n\n    OrderPage page = orderService.findPage(cursor, Math.min(limit, 100));\n\n    return ResponseEntity.ok(PagedResponse.&#x3C;OrderSummary>builder()\n        .data(page.getItems())\n        .nextCursor(page.getNextCursor())          // null if last page\n        .hasMore(page.hasMore())\n        .totalCount(page.getTotalCount())\n        .build());\n}\n\n// Client follows: GET /orders?cursor=eyJpZCI6IjEyMyJ9&#x26;limit=20\n</code></pre>\n<p>The cursor is opaque to the client (base64-encoded), which means you can change the internal pagination implementation — switching from ID-based to timestamp-based, for example — without breaking any clients.</p>\n<p><strong>REST sweet spot:</strong> Public APIs, CRUD services, when HTTP caching matters, mobile clients where you control bandwidth.</p>\n<p><strong>REST problems:</strong> Overfetching (getting 30 fields when you need 3), underfetching (N+1 — getting orders then making N calls for each order's customer).</p>\n<hr>\n<h2>GraphQL: Client-Defined Queries</h2>\n<p>GraphQL lets clients request exactly the data they need — no more, no less. One endpoint (<code>/graphql</code>) handles everything.</p>\n<p>The core idea behind GraphQL is inverting the control of data shaping: instead of the server deciding what fields to return, the client declares exactly what it needs. This is especially powerful when you have multiple clients — a mobile app, a web dashboard, and a partner integration — all with different data requirements hitting the same backend. The schema below defines what the server can provide; the query below it shows how a client selects a precise subset.</p>\n<pre><code class=\"language-graphql\"># Schema (server defines capabilities)\ntype Query {\n  order(id: ID!): Order\n  orders(filter: OrderFilter, limit: Int, cursor: String): OrderConnection!\n  me: User!\n}\n\ntype Order {\n  id: ID!\n  status: OrderStatus!\n  total: Float!\n  customer: Customer!         # Nested object — no extra round trip\n  items: [OrderItem!]!\n  createdAt: DateTime!\n}\n\ntype Customer {\n  id: ID!\n  name: String!\n  email: String!\n}\n\n# Client query — requests exactly what it needs\nquery GetOrderWithCustomer($orderId: ID!) {\n  order(id: $orderId) {\n    id\n    status\n    total\n    customer {\n      name        # Only name — not email, address, etc.\n    }\n    items {\n      productName\n      quantity\n      price\n    }\n  }\n}\n</code></pre>\n<p>Notice that the client requests <code>customer.name</code> but not <code>customer.email</code> — the server only fetches and returns what was requested. This is in direct contrast to REST, where you'd get the entire customer object whether you needed it or not.</p>\n<h3>Spring Boot GraphQL Implementation</h3>\n<p>The Spring GraphQL implementation maps GraphQL query fields to Java methods through annotations. The critical piece here is the <code>DataLoader</code> for the <code>customer</code> field — without it, loading 10 orders would trigger 10 separate customer queries (the GraphQL equivalent of the N+1 problem you saw in the REST section).</p>\n<pre><code class=\"language-java\">// build.gradle\n// implementation 'org.springframework.boot:spring-boot-starter-graphql'\n\n@Controller\npublic class OrderGraphQLController {\n\n    @QueryMapping\n    public Order order(@Argument String id) {\n        return orderService.findById(id)\n            .orElseThrow(() -> new GraphQLException(\"Order not found: \" + id));\n    }\n\n    @QueryMapping\n    public Connection&#x3C;Order> orders(@Argument OrderFilter filter,\n                                    @Argument int limit,\n                                    @Argument String cursor) {\n        return orderService.findPage(filter, limit, cursor);\n    }\n\n    // DataLoader: batch-load customers to avoid N+1\n    @SchemaMapping(typeName = \"Order\", field = \"customer\")\n    public CompletableFuture&#x3C;Customer> customer(Order order,\n                                                 DataLoader&#x3C;String, Customer> customerLoader) {\n        return customerLoader.load(order.getCustomerId());\n        // All customer loads within one request are batched into a single DB query\n    }\n}\n\n// DataLoader registration (batches N customer loads into 1 DB query)\n@Bean\npublic BatchLoaderRegistry batchLoaderRegistry() {\n    BatchLoaderRegistry registry = new DefaultBatchLoaderRegistry();\n    registry.forTypePair(String.class, Customer.class)\n        .withName(\"customerLoader\")\n        .registerBatchLoader((ids, env) ->\n            Mono.fromCallable(() -> customerService.findAllByIds(ids))\n        );\n    return registry;\n}\n</code></pre>\n<p>The <code>BatchLoaderRegistry</code> is where the magic happens: instead of loading each customer immediately, it collects all customer IDs from a single request and fires one batched database query. This is a non-negotiable pattern — GraphQL without DataLoaders at scale is a performance disaster.</p>\n<h3>GraphQL Mutations</h3>\n<p>While queries read data, mutations modify it. GraphQL mutations differ from REST POST/PUT in one important way: they return a payload type that can contain both the result and business-level errors as data, rather than relying on HTTP status codes to signal what went wrong.</p>\n<pre><code class=\"language-graphql\">type Mutation {\n  createOrder(input: CreateOrderInput!): CreateOrderPayload!\n  updateOrderStatus(id: ID!, status: OrderStatus!): Order!\n}\n\ninput CreateOrderInput {\n  customerId: ID!\n  items: [OrderItemInput!]!\n  shippingAddress: AddressInput!\n}\n\ntype CreateOrderPayload {\n  order: Order            # The created order\n  errors: [UserError!]    # Business errors (not HTTP 4xx)\n}\n\ntype UserError {\n  field: String\n  message: String!\n}\n</code></pre>\n<pre><code class=\"language-java\">@MutationMapping\npublic CreateOrderPayload createOrder(@Argument CreateOrderInput input) {\n    try {\n        Order order = orderService.create(input);\n        return CreateOrderPayload.success(order);\n    } catch (ValidationException e) {\n        return CreateOrderPayload.error(e.getField(), e.getMessage());\n    }\n}\n</code></pre>\n<p>Returning business errors in the payload (rather than throwing HTTP 422 errors) is a deliberate GraphQL convention — it means the GraphQL response always has HTTP 200, and clients handle business logic errors through the <code>errors</code> field in the response body. This keeps your error handling consistent regardless of the operation.</p>\n<p><strong>GraphQL sweet spot:</strong> Mobile apps (bandwidth-sensitive), complex dashboards with many different data shapes, BFF (Backend For Frontend) pattern, when you have multiple clients needing different views of the same data.</p>\n<p><strong>GraphQL problems:</strong> Query complexity attacks (clients can request deeply nested data), N+1 problem (requires DataLoader), caching is harder (no HTTP GET caching), learning curve.</p>\n<hr>\n<h2>gRPC: High-Performance Service Communication</h2>\n<p>gRPC uses HTTP/2 and Protocol Buffers (binary serialization). It's 5-10x faster than REST/JSON for inter-service communication.</p>\n<p>Where REST uses human-readable JSON over HTTP/1.1, gRPC uses compact binary encoding over HTTP/2. Think of the difference between sending a hand-written letter and sending a compressed file — both carry information, but one is far more efficient to transmit and parse. The Protobuf schema below is the contract that both sides of a gRPC call agree on; it generates type-safe client and server code in any supported language.</p>\n<pre><code class=\"language-protobuf\">// order_service.proto\nsyntax = \"proto3\";\n\npackage order.v1;\n\nservice OrderService {\n  rpc GetOrder (GetOrderRequest) returns (Order);\n  rpc CreateOrder (CreateOrderRequest) returns (Order);\n  rpc UpdateOrderStatus (UpdateStatusRequest) returns (Order);\n\n  // Server streaming: stream order updates to client\n  rpc WatchOrder (WatchOrderRequest) returns (stream OrderEvent);\n\n  // Client streaming: bulk upload orders\n  rpc BulkCreateOrders (stream CreateOrderRequest) returns (BulkCreateResponse);\n\n  // Bidirectional streaming: real-time order management\n  rpc ManageOrders (stream OrderCommand) returns (stream OrderEvent);\n}\n\nmessage Order {\n  string id = 1;\n  string customer_id = 2;\n  OrderStatus status = 3;\n  repeated OrderItem items = 4;\n  int64 total_cents = 5;           // Avoid floats for money\n  google.protobuf.Timestamp created_at = 6;\n}\n\nenum OrderStatus {\n  ORDER_STATUS_UNSPECIFIED = 0;   // Proto3: always define 0 case\n  ORDER_STATUS_PENDING = 1;\n  ORDER_STATUS_CONFIRMED = 2;\n  ORDER_STATUS_SHIPPED = 3;\n  ORDER_STATUS_DELIVERED = 4;\n  ORDER_STATUS_CANCELLED = 5;\n}\n\nmessage GetOrderRequest {\n  string id = 1;\n}\n</code></pre>\n<p>Notice that <code>total_cents</code> stores money as an integer instead of a float — this is a deliberate choice to avoid floating-point precision errors when dealing with currency. The streaming RPCs (<code>WatchOrder</code>, <code>BulkCreateOrders</code>, <code>ManageOrders</code>) are capabilities that REST simply cannot match cleanly. The Java server implementation maps directly to these proto definitions.</p>\n<pre><code class=\"language-java\">// Server implementation\n@GrpcService\npublic class OrderGrpcService extends OrderServiceGrpc.OrderServiceImplBase {\n\n    @Override\n    public void getOrder(GetOrderRequest request, StreamObserver&#x3C;Order> responseObserver) {\n        try {\n            com.example.Order order = orderService.findById(request.getId())\n                .orElseThrow(() -> Status.NOT_FOUND\n                    .withDescription(\"Order not found: \" + request.getId())\n                    .asRuntimeException());\n\n            responseObserver.onNext(toProto(order));\n            responseObserver.onCompleted();\n        } catch (StatusRuntimeException e) {\n            responseObserver.onError(e);\n        }\n    }\n\n    @Override\n    public void watchOrder(WatchOrderRequest request,\n                           StreamObserver&#x3C;OrderEvent> responseObserver) {\n        // Server streaming: push updates as order progresses\n        String orderId = request.getOrderId();\n        orderEventService.subscribe(orderId, event -> {\n            if (!responseObserver.isReady()) return;\n            responseObserver.onNext(toProto(event));\n            if (event.isFinal()) responseObserver.onCompleted();\n        });\n    }\n}\n\n// Client (another service calling OrderService)\n@Service\npublic class PaymentService {\n\n    private final OrderServiceGrpc.OrderServiceBlockingStub orderStub;\n\n    public void processPayment(String orderId) {\n        // Unary call with deadline\n        Order order = orderStub\n            .withDeadlineAfter(500, TimeUnit.MILLISECONDS)\n            .getOrder(GetOrderRequest.newBuilder().setId(orderId).build());\n\n        // order is type-safe — proto-generated class\n    }\n}\n</code></pre>\n<p>The <code>.withDeadlineAfter(500, TimeUnit.MILLISECONDS)</code> call on the client stub is critical for production resilience — without deadlines, a slow upstream service can hold your threads indefinitely and cascade into a timeout storm across your entire service mesh. Always set deadlines on outbound gRPC calls.</p>\n<h3>gRPC Performance Numbers</h3>\n<p>The performance gap between gRPC and REST isn't theoretical — here are concrete numbers from a representative benchmark. The two main drivers are binary serialization (Protobuf vs JSON) and HTTP/2 multiplexing, which eliminates head-of-line blocking and reduces connection overhead.</p>\n<pre><code>Benchmark: 10,000 requests/sec, 1KB payload, same machine\n\nREST/JSON (Spring MVC):\n  p50 latency: 8ms\n  p99 latency: 45ms\n  CPU: 65%\n\ngRPC/Protobuf (same logic):\n  p50 latency: 1.2ms     ← 6.7x faster\n  p99 latency: 7ms       ← 6.4x faster\n  CPU: 28%               ← 2.3x less CPU\n\nWhy: Binary serialization + HTTP/2 multiplexing + header compression\n</code></pre>\n<p>The CPU reduction is especially important in microservice architectures — every percentage point of CPU saved at 10,000 RPS translates directly to infrastructure cost. For internal service calls that happen millions of times per day, this difference is significant.</p>\n<p><strong>gRPC sweet spot:</strong> Internal microservice-to-microservice communication, streaming use cases, polyglot environments (Go, Java, Python talking to each other), when you need maximum throughput and minimum latency.</p>\n<p><strong>gRPC problems:</strong> No browser support natively (needs gRPC-Web proxy), harder to debug (binary protocol), requires Protobuf toolchain, contract management.</p>\n<hr>\n<h2>The Decision Framework</h2>\n<p>With all three protocols understood in depth, you need a practical way to make the call for a new API surface. The two questions below cut through most of the deliberation: who is calling your API, and what shape does your data have?</p>\n<pre><code>┌─────────────────────────────────────────────────────────────────┐\n│                    Who are your clients?                         │\n│                                                                   │\n│  External/Public API ──────────────────────────► REST           │\n│  (browsers, third-party, mobile)                                  │\n│                                                                   │\n│  Internal service-to-service ──────────────────► gRPC           │\n│  (no browser, max performance)                                    │\n│                                                                   │\n│  Multiple clients, different data needs ───────► GraphQL        │\n│  (mobile + web, BFF pattern)                                      │\n└─────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────────────────────────────────────────────────┐\n│                    What's your data shape?                        │\n│                                                                   │\n│  Simple CRUD, well-defined resources ──────────► REST           │\n│  Deeply nested, relationship-heavy data ───────► GraphQL        │\n│  Streaming, real-time, bidirectional ──────────► gRPC           │\n└─────────────────────────────────────────────────────────────────┘\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Factor</th>\n<th>REST</th>\n<th>GraphQL</th>\n<th>gRPC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Browser support</strong></td>\n<td>Native</td>\n<td>Native</td>\n<td>Needs proxy</td>\n</tr>\n<tr>\n<td><strong>Caching</strong></td>\n<td>Excellent (HTTP cache)</td>\n<td>Hard</td>\n<td>Manual</td>\n</tr>\n<tr>\n<td><strong>Overfetching</strong></td>\n<td>Common problem</td>\n<td>Solved</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><strong>Streaming</strong></td>\n<td>Limited (SSE)</td>\n<td>Subscriptions</td>\n<td>Native</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Good</td>\n<td>Good</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td><strong>Learning curve</strong></td>\n<td>Low</td>\n<td>Medium</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><strong>Tooling/ecosystem</strong></td>\n<td>Excellent</td>\n<td>Good</td>\n<td>Good</td>\n</tr>\n<tr>\n<td><strong>Contract-first</strong></td>\n<td>Optional (OpenAPI)</td>\n<td>Schema required</td>\n<td>Protobuf required</td>\n</tr>\n<tr>\n<td><strong>Best for</strong></td>\n<td>Public APIs</td>\n<td>Complex clients</td>\n<td>Internal services</td>\n</tr>\n</tbody>\n</table>\n<h2>Real-World Architecture: Use All Three</h2>\n<p>In practice, mature production systems don't pick one protocol and force it everywhere — they use each protocol where it excels. The architecture below is representative of how companies like Uber and Netflix structure their API layers. REST faces the public; gRPC connects internal services for speed; GraphQL serves as a flexible aggregation layer for complex client needs.</p>\n<pre><code>External clients (browser, mobile)\n    │\n    ▼\nAPI Gateway (REST)      ← Public-facing, cacheable, familiar\n    │\n    ├──► User Service ──────── gRPC ──► Auth Service\n    │                                       │\n    ├──► Product Service ──── gRPC ──► Inventory Service\n    │                                       │\n    ├──► BFF Service ────── GraphQL ──► (aggregates Product + User)\n    │         │                          (serves mobile app)\n    └──► Order Service ───── gRPC ──► Payment Service\n                                         │\n                                     Notification Service\n                                     (gRPC streaming)\n</code></pre>\n<p>The gateway is REST. Internal hop is gRPC. The mobile BFF is GraphQL. This isn't over-engineering — each protocol does one thing well.</p>\n<p>The worst outcome is picking one protocol for ideological reasons and forcing it everywhere. REST for streaming is painful. gRPC for public APIs is hostile to users. GraphQL for simple CRUD is overengineered. Let the use case choose the protocol.</p>\n","tableOfContents":[{"id":"the-core-trade-off","text":"The Core Trade-off","level":2},{"id":"rest-the-default-choice","text":"REST: The Default Choice","level":2},{"id":"rest-api-design-getting-it-right","text":"REST API Design — Getting It Right","level":3},{"id":"rest-error-response-standard","text":"REST Error Response Standard","level":3},{"id":"rest-pagination","text":"REST Pagination","level":3},{"id":"graphql-client-defined-queries","text":"GraphQL: Client-Defined Queries","level":2},{"id":"spring-boot-graphql-implementation","text":"Spring Boot GraphQL Implementation","level":3},{"id":"graphql-mutations","text":"GraphQL Mutations","level":3},{"id":"grpc-high-performance-service-communication","text":"gRPC: High-Performance Service Communication","level":2},{"id":"grpc-performance-numbers","text":"gRPC Performance Numbers","level":3},{"id":"the-decision-framework","text":"The Decision Framework","level":2},{"id":"real-world-architecture-use-all-three","text":"Real-World Architecture: Use All Three","level":2}]},"relatedPosts":[{"title":"Building Production Observability with OpenTelemetry and Grafana Stack","description":"End-to-end observability implementation: distributed tracing with OpenTelemetry, metrics with Prometheus, structured logging with Loki, and the dashboards and alerts that actually help during incidents.","date":"2025-07-03","category":"System Design","tags":["observability","opentelemetry","prometheus","grafana","loki","tracing","spring boot","monitoring"],"featured":false,"affiliateSection":"system-design-courses","slug":"observability-opentelemetry-production","readingTime":"6 min read","excerpt":"Observability is not the same as monitoring. Monitoring tells you something is wrong. Observability lets you understand why — by exploring system state through metrics, traces, and logs without needing to know in advance…"},{"title":"Event Sourcing and CQRS in Production: Beyond the Theory","description":"What event sourcing actually looks like in production Java systems: event store design, snapshot strategies, projection rebuilding, CQRS read model synchronization, and the operational challenges nobody talks about.","date":"2025-06-23","category":"System Design","tags":["event sourcing","cqrs","system design","java","distributed systems","kafka","spring boot"],"featured":false,"affiliateSection":"distributed-systems-books","slug":"event-sourcing-cqrs-production","readingTime":"7 min read","excerpt":"Event sourcing is one of those patterns that looks elegant in conference talks and becomes surprisingly complex in production systems. The theory — store events instead of state, derive state by replaying events — is sou…"},{"title":"gRPC vs REST vs GraphQL: Choosing the Right API Protocol","description":"A technical comparison of REST, gRPC, and GraphQL across performance, developer experience, schema evolution, streaming, and real production use cases. When each protocol wins and where each falls short.","date":"2025-06-18","category":"System Design","tags":["grpc","rest","graphql","api design","system design","microservices","protocol buffers"],"featured":false,"affiliateSection":"system-design-courses","slug":"grpc-vs-rest-vs-graphql","readingTime":"7 min read","excerpt":"API protocol selection has a longer lifespan than almost any other technical decision. REST APIs from 2010 are still running in production. gRPC services chosen for internal communication in 2018 are tightly coupled to t…"}]},"__N_SSG":true}