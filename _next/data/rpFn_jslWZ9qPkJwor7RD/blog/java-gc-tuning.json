{"pageProps":{"post":{"title":"Java GC Tuning: From G1 to ZGC — Eliminating Pause-Time Spikes","description":"Master Java garbage collection tuning. Understand G1GC, ZGC, and Shenandoah internals, diagnose GC issues from logs, and apply production tuning flags to eliminate pause-time spikes.","date":"2025-02-22","category":"Java","tags":["java","gc","performance","jvm","g1gc","zgc","tuning"],"featured":false,"affiliateSection":"java-courses","slug":"java-gc-tuning","readingTime":"10 min read","excerpt":"Garbage collection pauses are the invisible killer of Java application latency. A service with p99 latency of 20ms can suddenly spike to 500ms because GC paused all threads for a full collection. Understanding GC interna…","contentHtml":"<p>Garbage collection pauses are the invisible killer of Java application latency. A service with p99 latency of 20ms can suddenly spike to 500ms because GC paused all threads for a full collection. Understanding GC internals — not just tuning flags — is what separates engineers who eliminate GC pauses from those who keep adding heap and hoping.</p>\n<h2>The Generational Hypothesis</h2>\n<p>All production JVM GCs exploit the <strong>generational hypothesis</strong>: most objects die young. A freshly allocated <code>HttpRequest</code> object, a <code>StringBuilder</code> built for one response, a DTO for one API call — these live for milliseconds. To see why this insight is so powerful, consider the typical shape of object lifetimes in a real Java web service:</p>\n<pre><code>Object lifetime distribution (typical Java web service):\n\n Count\n   │\n   █\n   █ █\n   █ █ █\n   █ █ █ █                    ·\n   █ █ █ █ █                · · ·\n   ──────────────────────────────────── Age\n   &#x3C;1ms           &#x3C;1s            Long-lived\n\n99% of objects die in the first few milliseconds.\n~1% survive to become long-lived (caches, thread pools, connection pools).\n</code></pre>\n<p>The steep drop-off in that chart is what makes generational collection efficient: the JVM can reclaim the vast majority of memory by scanning only the small, recently-allocated portion of the heap. This is why JVMs divide the heap into generations:</p>\n<ul>\n<li><strong>Young Generation (Eden + Survivor spaces)</strong>: New objects allocated here. Minor GC runs frequently (~seconds) and is fast (~10ms)</li>\n<li><strong>Old Generation (Tenured)</strong>: Objects that survive enough minor GCs are promoted here. Major/Full GC runs rarely but can pause for seconds</li>\n</ul>\n<h2>G1GC: The Default Since Java 9</h2>\n<p>G1 (Garbage First) divides the heap into equal-sized regions (~2MB each) rather than fixed young/old spaces. It predicts which regions have the most garbage and collects those first — hence \"Garbage First.\" The diagram below shows how regions are dynamically assigned roles, which lets G1 balance collection work without requiring you to manually size each generation:</p>\n<pre><code>G1 Heap Layout:\n  ┌───┬───┬───┬───┬───┬───┬───┬───┐\n  │ E │ E │ S │ S │ O │ O │ O │ H │  E=Eden, S=Survivor\n  ├───┼───┼───┼───┼───┼───┼───┼───┤  O=Old, H=Humongous\n  │ E │ O │ O │ E │ O │ S │ H │ E │\n  ├───┼───┼───┼───┼───┼───┼───┼───┤\n  │ O │ O │ E │ E │ O │ O │ O │ O │\n  └───┴───┴───┴───┴───┴───┴───┴───┘\n\nG1 collects whichever regions have highest garbage ratio first.\nRegions dynamically reassigned as young/old based on need.\n</code></pre>\n<h3>Key G1 JVM Flags</h3>\n<p>The following flags give you a solid starting configuration for G1 on a production service. The most important one to understand is <code>MaxGCPauseMillis</code> — it is a <em>soft target</em>, meaning G1 uses it as a goal when deciding how much work to do per cycle, but it cannot always guarantee it will be met under extreme heap pressure:</p>\n<pre><code class=\"language-bash\"># Target: pause &#x3C; 200ms, heap = 8GB\n-XX:+UseG1GC                          # Default since Java 9 — usually don't need to specify\n-Xms8g -Xmx8g                         # Set min = max to avoid resize pauses\n-XX:MaxGCPauseMillis=200              # G1 soft target (not guaranteed)\n-XX:G1HeapRegionSize=16m              # Larger regions for large heaps (up to 32MB)\n-XX:G1NewSizePercent=20               # Min young gen = 20% of heap\n-XX:G1MaxNewSizePercent=40            # Max young gen = 40% of heap\n-XX:G1MixedGCCountTarget=8           # Number of mixed GC cycles\n-XX:G1HeapWastePercent=5             # Don't collect if less than 5% is reclaimable\n-XX:InitiatingHeapOccupancyPercent=45 # Start concurrent marking at 45% heap usage\n-XX:+G1UseAdaptiveIHOP               # Adaptive IHOP (Java 9+)\n</code></pre>\n<h3>Reading GC Logs</h3>\n<p>Flags alone won't help you if you can't observe what GC is actually doing. Always enable GC logging in production — the overhead is negligible and the diagnostic value is enormous:</p>\n<pre><code class=\"language-bash\">-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m\n</code></pre>\n<p>Sample output:</p>\n<pre><code>[2025-02-20T10:15:32.045+0000][2.345s][info][gc] GC(42) Pause Young (Normal) (G1 Evacuation Pause) 2048M->512M(8192M) 45.234ms\n[2025-02-20T10:15:35.891+0000][5.191s][info][gc] GC(43) Pause Young (Normal) (G1 Evacuation Pause) 1536M->400M(8192M) 38.102ms\n[2025-02-20T10:15:50.123+0000][19.423s][warning][gc] GC(44) To-space exhausted\n[2025-02-20T10:15:50.234+0000][19.534s][info][gc] GC(44) Pause Full (G1 Compaction Pause) 7800M->2100M(8192M) 4523.891ms\n</code></pre>\n<p>The <code>4523.891ms</code> Full GC in the last line is a 4.5-second stop-the-world pause — the kind of spike that will blow through any reasonable latency SLA. Learning to recognize the warning signs before that happens is the key skill.</p>\n<p><strong>Red flags in GC logs:</strong></p>\n<ul>\n<li><code>To-space exhausted</code> → Survivor spaces too small, objects forced to Old Gen prematurely</li>\n<li><code>Pause Full</code> → Full GC triggered — expensive, caused by heap exhaustion or humongous object allocation failure</li>\n<li><code>Evacuation Failure</code> → GC couldn't evacuate young gen → heap pressure</li>\n<li>Pause time consistently > <code>MaxGCPauseMillis</code> target → Heap too small or mixed GC tuning needed</li>\n</ul>\n<h3>Common G1 Issues and Fixes</h3>\n<p>Once you know how to read the logs, the next step is mapping the symptoms you see to the right corrective action. Each of the three scenarios below has a distinct cause and a specific set of flags or code changes that address it:</p>\n<pre><code>Issue: Humongous Object Allocation\n  Objects > 50% of region size (>8MB for 16MB regions) are allocated directly in Old Gen.\n  If short-lived, they skip Young Gen and pollute Old Gen.\n\nFix:\n  1. Increase G1HeapRegionSize to make more objects \"normal\" size\n  2. Identify culprits: -XX:+G1PrintRegionRememberedSetInfo (Java 11+)\n  3. Refactor: stream large byte arrays instead of materializing them\n\nIssue: Old Gen fills up → Full GC\n  Mixed GC isn't reclaiming Old Gen fast enough.\n\nFix:\n  -XX:G1MixedGCCountTarget=4          # More frequent mixed GC\n  -XX:G1HeapWastePercent=1            # Collect more aggressively\n  -XX:InitiatingHeapOccupancyPercent=35 # Start concurrent marking earlier\n\nIssue: Long Young GC pauses\n  Too many live objects in Young Gen → evacuation takes long.\n\nFix:\n  -XX:G1NewSizePercent=10             # Smaller young gen = faster minor GC\n  -XX:MaxTenuringThreshold=3          # Promote to Old Gen sooner\n</code></pre>\n<h2>ZGC: Sub-Millisecond Pauses (Java 15+)</h2>\n<p>If G1 tuning still leaves you with pauses that violate your latency requirements, ZGC offers a fundamentally different trade-off. ZGC is a concurrent collector — it does almost all work while application threads run. Stop-the-world pauses are limited to root scanning and reference processing, typically <strong>&#x3C; 1ms</strong> even on 100GB+ heaps. The trade-off is that it requires more heap headroom and uses more CPU for its background collection work. Here is a recommended baseline configuration:</p>\n<pre><code class=\"language-bash\"># ZGC configuration\n-XX:+UseZGC                     # Enable ZGC\n-Xms16g -Xmx16g                 # ZGC needs generous heap headroom (~2-3x live set)\n-XX:SoftMaxHeapSize=14g         # Soft limit: ZGC starts collecting harder above this\n-XX:ZCollectionInterval=0       # 0 = adaptive (recommended)\n-XX:ConcGCThreads=4             # Concurrent GC threads (increase for large heaps)\n-XX:+ZGenerational              # Java 21+: Generational ZGC (much better throughput)\n</code></pre>\n<p>The <code>ZGenerational</code> flag (Java 21+) is particularly important: it adds generational awareness to ZGC, dramatically improving throughput without sacrificing the sub-millisecond pause times that make ZGC appealing in the first place.</p>\n<p><strong>ZGC tradeoffs:</strong></p>\n<ul>\n<li>Pause times: &#x3C; 1ms ✓</li>\n<li>Throughput: 5-10% lower than G1 (concurrent work has CPU cost)</li>\n<li>Memory overhead: Higher (needs extra heap headroom ~2x)</li>\n<li>Best for: Latency-sensitive services (trading, real-time APIs) with large heaps</li>\n</ul>\n<h3>G1 vs ZGC vs Shenandoah</h3>\n<p>Choosing between collectors comes down to understanding your own latency requirements and heap size. Use this table as a quick reference when deciding which collector is appropriate for a given service:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>G1GC</th>\n<th>ZGC (Java 21 Gen)</th>\n<th>Shenandoah</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pause time</td>\n<td>50-500ms</td>\n<td>&#x3C; 1ms</td>\n<td>&#x3C; 10ms</td>\n</tr>\n<tr>\n<td>Throughput</td>\n<td>Excellent</td>\n<td>Good (-5%)</td>\n<td>Good (-5%)</td>\n</tr>\n<tr>\n<td>Heap size</td>\n<td>Any</td>\n<td>Large (> 4GB benefits most)</td>\n<td>Any</td>\n</tr>\n<tr>\n<td>Memory overhead</td>\n<td>Low</td>\n<td>High (2x)</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Java version</td>\n<td>9+</td>\n<td>11+, Gen in 21+</td>\n<td>12+</td>\n</tr>\n<tr>\n<td>Best for</td>\n<td>Default choice</td>\n<td>Latency-critical</td>\n<td>Latency-sensitive</td>\n</tr>\n</tbody>\n</table>\n<h2>Diagnosing GC Problems in Production</h2>\n<p>Knowing which collector to use is only half the battle. When a GC problem surfaces in production, you need a repeatable diagnostic process to find the root cause without guessing. Follow these steps in order — measuring first prevents you from applying the wrong fix.</p>\n<h3>Step 1: Measure before tuning</h3>\n<p>Start by quantifying how much of your CPU time is consumed by GC and which areas of the heap are under pressure. This gives you a baseline to compare against after any change you make:</p>\n<pre><code class=\"language-bash\"># GC overhead: what % of CPU time is GC?\n# Rule of thumb: > 5% GC CPU → GC is a problem\njstat -gcutil &#x3C;pid> 1000 10\n# Output: S0  S1  E   O   M   CCS  YGC  YGCT  FGC  FGCT  CGC  CGCT  GCT\n#           0  50  80  45  95   90   42  0.845    0     0    3   0.234  1.079\n# YGC=42 young GCs in measurement period, YGCT=total young GC time\n\n# Heap histogram: what's consuming heap?\njmap -histo:live &#x3C;pid> | head -30\n# Lists: #instances, bytes, class name\n# Look for: unexpected retention of Request/Response objects, large byte arrays\n</code></pre>\n<h3>Step 2: Heap dump analysis</h3>\n<p>If <code>jstat</code> shows high Old Gen occupancy or frequent Full GCs, the next step is a heap dump. A heap dump lets you see exactly which objects are being retained and why — this is how you find memory leaks:</p>\n<pre><code class=\"language-bash\"># Trigger heap dump (OOM or manual)\njmap -dump:format=b,file=/tmp/heap.hprof &#x3C;pid>\n\n# Or configure JVM to dump on OOM\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/var/log/app/\n\n# Analyze with Eclipse MAT or VisualVM\n# Look for: Retained Heap (memory freed if object is GC'd)\n# Find: Objects with large retained heap that shouldn't be alive\n</code></pre>\n<h3>Step 3: Allocation profiling</h3>\n<p>When your object lifetime distribution is healthy but GC is still frequent, the problem is usually allocation rate — your application is creating objects faster than GC can collect them. Allocation profiling pinpoints exactly which code paths are responsible:</p>\n<pre><code class=\"language-bash\"># Async-profiler: low-overhead allocation profiling\n./profiler.sh -e alloc -d 30 -f alloc.html &#x3C;pid>\n\n# Or JVM built-in (Java Flight Recorder)\njava -XX:+FlightRecorder \\\n     -XX:StartFlightRecording=duration=60s,settings=profile,filename=recording.jfr \\\n     -jar app.jar\n</code></pre>\n<h2>Production Tuning Checklist</h2>\n<p>With all three diagnostic steps complete, you are ready to apply targeted configuration changes. The flags below represent a battle-tested starting point for a Java 21 web service, with comments explaining the intent behind each choice. Apply them incrementally and re-measure after each change so you can attribute improvements to specific flags:</p>\n<pre><code class=\"language-bash\"># Base flags for any Java web service (Java 21)\n-Xms4g -Xmx4g                              # Set min=max (avoid resize pauses)\n-XX:+UseG1GC                               # Default, good starting point\n-XX:MaxGCPauseMillis=200                   # Define your SLA\n-XX:InitiatingHeapOccupancyPercent=35      # Earlier concurrent marking\n-XX:+G1UseAdaptiveIHOP                     # Let JVM tune IHOP\n\n# GC Logging (always on in production)\n-Xlog:gc*:file=/var/log/app/gc.log:time,uptime,level,tags:filecount=5,filesize=20m\n\n# OOM handling\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/var/log/app/heapdump.hprof\n-XX:+ExitOnOutOfMemoryError                # Crash fast rather than limp\n\n# For latency-sensitive services (Java 21)\n-XX:+UseZGC -XX:+ZGenerational            # Switch to ZGC\n-Xms16g -Xmx16g                           # Give ZGC headroom\n\n# Avoid:\n# -Xmn (manually setting young gen size) — let G1 manage it\n# -XX:+UseConcMarkSweepGC — deprecated, removed in Java 14\n# -XX:+UseSerialGC — only for single-CPU containers\n</code></pre>\n<p>The golden rule of GC tuning: <strong>measure first, tune second</strong>. Most GC problems are solved by either sizing the heap appropriately or identifying a memory leak. Only after ruling those out should you reach for GC flags.</p>\n","tableOfContents":[{"id":"the-generational-hypothesis","text":"The Generational Hypothesis","level":2},{"id":"g1gc-the-default-since-java-9","text":"G1GC: The Default Since Java 9","level":2},{"id":"key-g1-jvm-flags","text":"Key G1 JVM Flags","level":3},{"id":"reading-gc-logs","text":"Reading GC Logs","level":3},{"id":"common-g1-issues-and-fixes","text":"Common G1 Issues and Fixes","level":3},{"id":"zgc-sub-millisecond-pauses-java-15","text":"ZGC: Sub-Millisecond Pauses (Java 15+)","level":2},{"id":"g1-vs-zgc-vs-shenandoah","text":"G1 vs ZGC vs Shenandoah","level":3},{"id":"diagnosing-gc-problems-in-production","text":"Diagnosing GC Problems in Production","level":2},{"id":"step-1-measure-before-tuning","text":"Step 1: Measure before tuning","level":3},{"id":"step-2-heap-dump-analysis","text":"Step 2: Heap dump analysis","level":3},{"id":"step-3-allocation-profiling","text":"Step 3: Allocation profiling","level":3},{"id":"production-tuning-checklist","text":"Production Tuning Checklist","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th…"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin…"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength — and its complexity. Misconfigured security is worse than no security, because it give…"}]},"__N_SSG":true}