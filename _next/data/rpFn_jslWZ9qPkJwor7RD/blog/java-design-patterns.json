{"pageProps":{"post":{"title":"Java Design Patterns: When to Use Them, When to Avoid Them","description":"Practical guide to Java design patterns with production examples. Covers Builder, Factory, Strategy, Observer, Decorator, and Command patterns with Spring Boot integration.","date":"2025-03-15","category":"Java","tags":["java","design patterns","spring boot","solid","clean code"],"featured":false,"affiliateSection":"java-courses","slug":"java-design-patterns","readingTime":"10 min read","excerpt":"Design patterns are solutions to recurring design problems. The mistake most engineers make is pattern-matching: \"this code has a factory-like structure, let me add a Factory pattern.\" The right question is: \"what proble…","contentHtml":"<p>Design patterns are solutions to recurring design problems. The mistake most engineers make is pattern-matching: \"this code has a factory-like structure, let me add a Factory pattern.\" The right question is: \"what problem am I solving?\" Most of the time, a well-named class and a clean interface are better than a named pattern. This article shows when patterns genuinely improve code.</p>\n<h2>Builder: Complex Object Construction</h2>\n<p>Use when constructing an object requires many parameters, especially optional ones. The classic symptom that Builder is the right choice is what is often called the \"telescoping constructor\" anti-pattern — a constructor call where you cannot tell what each argument means without looking up the signature. The following comparison makes this concrete:</p>\n<pre><code class=\"language-java\">// Without Builder: telescoping constructors (anti-pattern)\nnew Order(\"cust-123\", \"NEW\", BigDecimal.valueOf(99.99), \"USD\", null, null, true, false);\n// Which field is which? What are those booleans?\n\n// With Builder: readable, validated, immutable\n@Builder\n@Value  // Lombok: all fields final, getters, no setters\npublic class Order {\n    String orderId;\n    String customerId;\n    OrderStatus status;\n    BigDecimal totalAmount;\n    String currency;\n    String shippingAddressId;\n    boolean expressShipping;\n    boolean giftWrapped;\n    Instant createdAt;\n\n    // Custom validation in the builder\n    public static class OrderBuilder {\n        public Order build() {\n            if (totalAmount == null || totalAmount.compareTo(BigDecimal.ZERO) &#x3C;= 0) {\n                throw new IllegalArgumentException(\"Total must be positive\");\n            }\n            if (currency == null) currency = \"USD\";\n            if (createdAt == null) createdAt = Instant.now();\n            return new Order(orderId, customerId, status, totalAmount,\n                           currency, shippingAddressId, expressShipping, giftWrapped, createdAt);\n        }\n    }\n}\n\n// Usage: self-documenting, compile-time checked\nOrder order = Order.builder()\n    .orderId(UUID.randomUUID().toString())\n    .customerId(\"cust-123\")\n    .status(OrderStatus.PENDING)\n    .totalAmount(BigDecimal.valueOf(99.99))\n    .expressShipping(true)\n    .build();\n</code></pre>\n<p>Notice that the custom <code>build()</code> method centralizes validation and applies sensible defaults — logic that would otherwise be scattered across multiple constructors. By overriding the Lombok-generated <code>build()</code>, you get both the convenience of generated code and the safety of explicit invariant checks.</p>\n<h2>Strategy: Swappable Algorithms</h2>\n<p>Use when you have multiple implementations of the same behavior and need to choose at runtime. The Strategy pattern is essentially a way to encode a decision that would otherwise live in a <code>switch</code> or <code>if-else</code> chain directly into the type system, making it easy to add new cases without touching existing code. Payment processing is a natural example — each payment provider has completely different API calls, but from the perspective of the service that processes payments, the interface is the same:</p>\n<pre><code class=\"language-java\">// Payment processing: different strategies for different payment methods\npublic interface PaymentStrategy {\n    PaymentResult process(PaymentRequest request);\n    boolean supports(PaymentMethod method);\n}\n\n@Component\npublic class StripePaymentStrategy implements PaymentStrategy {\n\n    @Override\n    public PaymentResult process(PaymentRequest request) {\n        // Stripe-specific implementation\n        StripeCharge charge = stripeClient.charges().create(\n            ChargeCreateParams.builder()\n                .setAmount(request.getAmountCents())\n                .setCurrency(request.getCurrency())\n                .setSource(request.getToken())\n                .build()\n        );\n        return PaymentResult.success(charge.getId());\n    }\n\n    @Override\n    public boolean supports(PaymentMethod method) {\n        return method == PaymentMethod.CREDIT_CARD || method == PaymentMethod.DEBIT_CARD;\n    }\n}\n\n@Component\npublic class PayPalPaymentStrategy implements PaymentStrategy {\n\n    @Override\n    public PaymentResult process(PaymentRequest request) {\n        // PayPal-specific implementation\n        return payPalClient.execute(request);\n    }\n\n    @Override\n    public boolean supports(PaymentMethod method) {\n        return method == PaymentMethod.PAYPAL;\n    }\n}\n\n// Context: selects and executes the right strategy\n@Service\npublic class PaymentService {\n\n    private final List&#x3C;PaymentStrategy> strategies;  // Spring injects all implementations\n\n    public PaymentService(List&#x3C;PaymentStrategy> strategies) {\n        this.strategies = strategies;\n    }\n\n    public PaymentResult processPayment(PaymentRequest request) {\n        return strategies.stream()\n            .filter(s -> s.supports(request.getPaymentMethod()))\n            .findFirst()\n            .orElseThrow(() -> new UnsupportedPaymentMethodException(request.getPaymentMethod()))\n            .process(request);\n    }\n}\n// Adding a new payment method = add a new @Component class. Zero changes to PaymentService.\n</code></pre>\n<p>The key insight here is how Spring's dependency injection and the Strategy pattern work together: by injecting <code>List&#x3C;PaymentStrategy></code>, Spring automatically collects every <code>@Component</code> that implements the interface. Adding a new payment method means writing a new class and annotating it — <code>PaymentService</code> never needs to know it exists.</p>\n<h2>Factory / Factory Method: Controlled Object Creation</h2>\n<p>Use when the creation logic is complex, when clients shouldn't know the concrete type, or when object creation has side effects. The Factory pattern is appropriate when the act of creating an object requires knowledge that the caller should not need to have — like which dependencies to inject, what normalization to apply to inputs, or how to map a type enum to a concrete class:</p>\n<pre><code class=\"language-java\">// Problem: NotificationService needs to create different notification types\n// with different initialization requirements\n\npublic sealed interface Notification permits EmailNotification, SmsNotification, PushNotification {}\n\n@Factory\npublic class NotificationFactory {\n\n    @Autowired\n    private EmailClient emailClient;\n\n    @Autowired\n    private SmsProvider smsProvider;\n\n    @Autowired\n    private PushNotificationService pushService;\n\n    public Notification create(NotificationRequest request) {\n        return switch (request.getType()) {\n            case EMAIL -> new EmailNotification(\n                emailClient,\n                request.getRecipient(),\n                request.getTemplate(),\n                request.getVariables()\n            );\n            case SMS -> new SmsNotification(\n                smsProvider,\n                normalizePhoneNumber(request.getRecipient()),\n                request.getMessage()\n            );\n            case PUSH -> new PushNotification(\n                pushService,\n                request.getDeviceToken(),\n                request.getTitle(),\n                request.getBody()\n            );\n        };\n    }\n\n    private String normalizePhoneNumber(String phone) {\n        // E.164 format\n        return phone.replaceAll(\"[^0-9+]\", \"\");\n    }\n}\n</code></pre>\n<p>Using a <code>sealed interface</code> here is deliberate: it forces the <code>switch</code> expression to be exhaustive, so if you add a new <code>NotificationType</code> in the future the compiler will tell you that <code>NotificationFactory</code> needs to handle it — the type system enforces completeness.</p>\n<h2>Observer (Event-Driven): Decoupled Reactions</h2>\n<p>Use when one event should trigger multiple independent reactions without coupling them. Think of it like a newspaper subscription: the publisher prints the paper without knowing who subscribes, and each subscriber reads it independently. Spring's <code>ApplicationEvent</code> mechanism is the idiomatic way to implement this in a Spring Boot application, and it integrates naturally with transactions through <code>@TransactionalEventListener</code>:</p>\n<pre><code class=\"language-java\">// Spring's ApplicationEvent is the cleanest Observer implementation in Spring Boot\n\n// The event\npublic record OrderCreatedEvent(Order order) implements ApplicationEvent {\n    public OrderCreatedEvent(Order order) {\n        this.order = order;\n    }\n}\n\n// Publishers just fire events — they don't know about listeners\n@Service\npublic class OrderService {\n\n    @Autowired\n    private ApplicationEventPublisher eventPublisher;\n\n    public Order createOrder(OrderRequest request) {\n        Order order = orderRepository.save(buildOrder(request));\n        // Publish — OrderService has ZERO knowledge of what happens next\n        eventPublisher.publishEvent(new OrderCreatedEvent(order));\n        return order;\n    }\n}\n\n// Listeners react independently\n@Component\npublic class OrderEmailListener {\n\n    @Async  // Don't block the request thread\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        emailService.sendOrderConfirmation(event.order());\n    }\n}\n\n@Component\npublic class InventoryReservationListener {\n\n    @Async\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        inventoryService.reserve(event.order().getItems());\n    }\n}\n\n@Component\npublic class AnalyticsListener {\n\n    @Async\n    @EventListener  // @EventListener fires even on transaction rollback\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        analyticsService.track(\"order_created\", event.order());\n    }\n}\n// Adding a new reaction = add a new @Component. Zero changes to OrderService.\n</code></pre>\n<p>Notice the difference between <code>@TransactionalEventListener</code> (used by email and inventory) and <code>@EventListener</code> (used by analytics). Email and inventory reservation must only happen if the order transaction commits successfully — <code>AFTER_COMMIT</code> guarantees this. Analytics, by contrast, wants to track even failed orders, so it uses plain <code>@EventListener</code> which fires regardless of transaction outcome.</p>\n<h2>Decorator: Composable Behavior</h2>\n<p>Use when you need to add behavior to an object dynamically without inheritance. Inheritance is a rigid relationship — once you make <code>CachingOrderRepository</code> extend <code>JpaOrderRepository</code>, you cannot swap the base implementation. The Decorator pattern solves this by wrapping the interface rather than extending the class, so each decorator only depends on the abstraction and can be composed in any order:</p>\n<pre><code class=\"language-java\">// Repository with optional caching, audit logging, retry\npublic interface UserRepository {\n    Optional&#x3C;User> findById(String id);\n    User save(User user);\n}\n\n@Repository\npublic class JpaUserRepository implements UserRepository {\n    // Base implementation\n    @Override\n    public Optional&#x3C;User> findById(String id) {\n        return jpaRepo.findById(id);\n    }\n}\n\n// Caching decorator\npublic class CachingUserRepository implements UserRepository {\n\n    private final UserRepository delegate;\n    private final Cache&#x3C;String, User> cache;\n\n    public CachingUserRepository(UserRepository delegate, Cache&#x3C;String, User> cache) {\n        this.delegate = delegate;\n        this.cache = cache;\n    }\n\n    @Override\n    public Optional&#x3C;User> findById(String id) {\n        User cached = cache.getIfPresent(id);\n        if (cached != null) return Optional.of(cached);\n\n        Optional&#x3C;User> user = delegate.findById(id);\n        user.ifPresent(u -> cache.put(id, u));\n        return user;\n    }\n\n    @Override\n    public User save(User user) {\n        User saved = delegate.save(user);\n        cache.put(saved.getId(), saved);  // Update cache on write\n        return saved;\n    }\n}\n\n// Audit logging decorator\npublic class AuditingUserRepository implements UserRepository {\n\n    private final UserRepository delegate;\n    private final AuditLog auditLog;\n\n    @Override\n    public User save(User user) {\n        User saved = delegate.save(user);\n        auditLog.record(AuditEntry.builder()\n            .entityType(\"User\").entityId(saved.getId())\n            .action(\"SAVE\").performedBy(SecurityContext.currentUser())\n            .build());\n        return saved;\n    }\n}\n\n// Wire them together in Spring\n@Configuration\npublic class RepositoryConfig {\n\n    @Bean\n    public UserRepository userRepository(JpaUserRepository base) {\n        Cache&#x3C;String, User> cache = Caffeine.newBuilder()\n            .maximumSize(10_000).expireAfterWrite(5, TimeUnit.MINUTES).build();\n\n        return new AuditingUserRepository(\n            new CachingUserRepository(base, cache),\n            auditLog\n        );\n    }\n}\n</code></pre>\n<p>The <code>@Configuration</code> class at the end is where the power of this pattern becomes visible: you are composing three independent behaviors (JPA persistence, caching, and auditing) with no modification to any of the three classes. If you need to add retry logic tomorrow, you write a <code>RetryingUserRepository</code> decorator and add one more wrapper in <code>RepositoryConfig</code>.</p>\n<h2>Command Pattern: Encapsulated Operations</h2>\n<p>Use for undo/redo, queuing operations, or transactional scripts. The Command pattern turns an operation into an object — which means you can store it, queue it, log it, and most importantly, reverse it. This is especially valuable in financial or administrative contexts where operations need to be reversible:</p>\n<pre><code class=\"language-java\">// Command interface\npublic interface Command&#x3C;T> {\n    T execute();\n    void undo();\n}\n\n// Commands are self-contained, reversible operations\npublic class TransferMoneyCommand implements Command&#x3C;TransferResult> {\n\n    private final Account fromAccount;\n    private final Account toAccount;\n    private final BigDecimal amount;\n    private boolean executed = false;\n\n    @Override\n    public TransferResult execute() {\n        if (fromAccount.getBalance().compareTo(amount) &#x3C; 0) {\n            throw new InsufficientFundsException(fromAccount.getId());\n        }\n        fromAccount.debit(amount);\n        toAccount.credit(amount);\n        executed = true;\n        return TransferResult.success(fromAccount.getId(), toAccount.getId(), amount);\n    }\n\n    @Override\n    public void undo() {\n        if (!executed) return;\n        toAccount.debit(amount);\n        fromAccount.credit(amount);\n        executed = false;\n    }\n}\n\n// Command executor with undo history\n@Service\npublic class CommandExecutor {\n\n    private final Deque&#x3C;Command&#x3C;?>> history = new ArrayDeque&#x3C;>();\n\n    public &#x3C;T> T execute(Command&#x3C;T> command) {\n        T result = command.execute();\n        history.push(command);\n        return result;\n    }\n\n    public void undoLast() {\n        if (!history.isEmpty()) {\n            history.pop().undo();\n        }\n    }\n}\n</code></pre>\n<p>The <code>executed</code> flag in <code>TransferMoneyCommand</code> is a subtle but important guard: it prevents <code>undo()</code> from reversing a transfer that was never successfully applied, protecting against double-reversal bugs when error handling calls <code>undo()</code> on a command that threw during <code>execute()</code>.</p>\n<h2>When NOT to Use Patterns</h2>\n<p>With several patterns now in your toolkit, the most important skill to develop is restraint. Every pattern adds indirection, which adds cognitive overhead for anyone reading the code. Apply a pattern only when the problem it solves is actually present, not when the code structure merely resembles a scenario where the pattern could apply:</p>\n<pre><code>Pattern overuse is more common than underuse:\n\nDon't create a Factory when:\n  new OrderService() is perfectly readable\n  → Builder or constructor are clearer\n\nDon't create a Strategy when:\n  You only have one algorithm now (YAGNI)\n  → Add it when the second strategy arrives\n\nDon't create an Observer when:\n  Only one listener will ever exist\n  → Direct method call is simpler\n\nDon't create a Decorator when:\n  You own both the base class and the extension\n  → Just modify the base class\n\nThe design principle behind patterns: SOLID\n  S: Single Responsibility (Strategy, Command)\n  O: Open/Closed (Strategy, Decorator, Observer)\n  L: Liskov Substitution (all well-implemented patterns)\n  I: Interface Segregation (narrow interfaces)\n  D: Dependency Inversion (inject abstractions, not concretions)\n\nApply SOLID principles first. Patterns emerge naturally.\n</code></pre>\n<p>The most dangerous design pattern is the one you apply to feel like you're doing \"proper engineering.\" Good code is readable code. A <code>UserRepository</code> with caching and auditing composed via Decorator is elegant. A <code>UserServiceFactoryImpl</code> with a <code>UserServiceFactoryImplFactory</code> is a joke. Patterns serve the code; the code doesn't serve the patterns.</p>\n","tableOfContents":[{"id":"builder-complex-object-construction","text":"Builder: Complex Object Construction","level":2},{"id":"strategy-swappable-algorithms","text":"Strategy: Swappable Algorithms","level":2},{"id":"factory-factory-method-controlled-object-creation","text":"Factory / Factory Method: Controlled Object Creation","level":2},{"id":"observer-event-driven-decoupled-reactions","text":"Observer (Event-Driven): Decoupled Reactions","level":2},{"id":"decorator-composable-behavior","text":"Decorator: Composable Behavior","level":2},{"id":"command-pattern-encapsulated-operations","text":"Command Pattern: Encapsulated Operations","level":2},{"id":"when-not-to-use-patterns","text":"When NOT to Use Patterns","level":2}]},"relatedPosts":[{"title":"Java Concurrency Patterns: CompletableFuture, Structured Concurrency, and Thread-Safe Design","description":"Production Java concurrency: CompletableFuture pipelines, handling exceptions in async chains, Java 21 structured concurrency, thread-safe collection patterns, and the concurrency bugs that cause data corruption.","date":"2025-07-08","category":"Java","tags":["java","concurrency","completablefuture","virtual threads","java21","thread-safe","async"],"featured":false,"affiliateSection":"java-courses","slug":"java-concurrency-patterns","readingTime":"7 min read","excerpt":"Java concurrency has three eras: raw  and  (Java 1-4), the  framework (Java 5+), and the virtual thread/structured concurrency era (Java 21+). Each era's patterns still exist in production codebases. Understanding all th…"},{"title":"Java Memory Management Deep Dive: Heap, GC, and Production Tuning","description":"How the JVM allocates memory, how G1GC and ZGC work under the hood, heap analysis with JVM tools, and the GC tuning decisions that eliminate latency spikes in production Java services.","date":"2025-06-13","category":"Java","tags":["java","jvm","garbage collection","g1gc","zgc","heap","memory management","performance"],"featured":false,"affiliateSection":"java-courses","slug":"java-memory-management-deep-dive","readingTime":"7 min read","excerpt":"Java's garbage collector is the single biggest source of unexplained latency spikes in production services. A GC pause of 2 seconds is invisible in most logs but visible to every user who happened to make a request durin…"},{"title":"Spring Security OAuth2 and JWT: Production Implementation Guide","description":"Complete Spring Security OAuth2 implementation: JWT token validation, Resource Server configuration, method-level security, custom UserDetailsService, refresh token rotation, and the security pitfalls that lead to authentication bypasses.","date":"2025-06-03","category":"Java","tags":["spring security","oauth2","jwt","spring boot","authentication","authorization","java","security"],"featured":false,"affiliateSection":"java-courses","slug":"spring-security-oauth2-jwt","readingTime":"7 min read","excerpt":"Spring Security is one of the most powerful and most misunderstood frameworks in the Java ecosystem. Its flexibility is its strength — and its complexity. Misconfigured security is worse than no security, because it give…"}]},"__N_SSG":true}